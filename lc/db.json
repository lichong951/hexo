{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/pic/me.jpg","path":"pic/me.jpg","modified":1,"renderable":0},{"_id":"source/pic/stack01.png","path":"pic/stack01.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"d47d3b2b82b6296d13ea866546e40b4d9dd2afc5","modified":1542899087000},{"_id":"source/google73d573756c531a32.html","hash":"6677e6ae64758e5b48ac46482aa3d1cf3e5a149e","modified":1509543415000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1509544070000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1509544070000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1509544070000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1552171145000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1509544070000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1509544070000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1509544070000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1509544070000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1509544070000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1509544070000},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1552171145000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1552171145000},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1552171145000},{"_id":"themes/next/_config.yml","hash":"266ad8feb957a04336d1bb6de47849fa92a1221b","modified":1552174308000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1509544070000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1552171145000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1563173480433},{"_id":"source/_posts/DataStructuresAndAlgorlthms.md","hash":"6b01a4e2749d7abb9428ea7219e71de6002b9e1a","modified":1563172917257},{"_id":"source/_posts/Jenkins01.md","hash":"a1568c9b29c7ff906d8a4d3ce9b38b28e00ca8d4","modified":1563172923337},{"_id":"source/_posts/arithmetic.md","hash":"aa49dd2e46851f715b0b392c5c0a6296fecd34a4","modified":1563172917274},{"_id":"source/_posts/android-lichong.md","hash":"4e7f792150b6419704c9c6a3acf640a63fa0ec63","modified":1563173246978},{"_id":"source/_posts/book-1.md","hash":"0194b64b3b29a9d76e629f21e02e497b3da6e543","modified":1509543415000},{"_id":"source/_posts/book-2-clean-code.md","hash":"75cbd1fbc74c0e7d656c44eea6dd3a67589683c2","modified":1509543415000},{"_id":"source/_posts/book-3_data-structure.md","hash":"ed7766014898ffea194b509beaa8c47a42b5d25a","modified":1563172917274},{"_id":"source/_posts/debug-androidstudio.md","hash":"8a25d9af30f5d0fb5f99da90821f9c3c7e4d964f","modified":1509543415000},{"_id":"source/_posts/debug-history.md","hash":"f6919c4a0326c3f2e6007abbd339bc55ea958a54","modified":1509543415000},{"_id":"source/_posts/designpattern-state1.md","hash":"94eb9c31701e65f2c5ca3aed0d6cd6b78aecaa20","modified":1563172917275},{"_id":"source/_posts/framework-imageloader.md","hash":"92d31585d34c2922331cb809b2a858e6da545538","modified":1509543415000},{"_id":"source/_posts/handler-framework.md","hash":"dc98742ad6687583b37dbd42e62dc319b0de1c0c","modified":1563172917276},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1486112724000},{"_id":"source/_posts/resume.md","hash":"cb474099de6e5c9b5002552787069e83b6dfd387","modified":1563172917277},{"_id":"source/_posts/serial-prot-helper.md","hash":"1ddcaabf351cd1dcc92fe96660b9b8b44231df22","modified":1563172923338},{"_id":"source/_posts/unity3d-android-debug.md","hash":"140882b1632ce22d03d5b3eebf16791a19ed8fd8","modified":1563172923357},{"_id":"source/_posts/【Jenkins】构建后生成下载二维码并邮件通知.md","hash":"0238afc19811aca1af041fc1e80c64e9779ac93f","modified":1563172923358},{"_id":"source/categories/index.md","hash":"3b7275570e6e8a309b66cf4c518194a7928f7816","modified":1509543415000},{"_id":"source/pic/me.jpg","hash":"00f769adba82030d5779c097354adb71730802c9","modified":1563172917294},{"_id":"source/tags/index.md","hash":"ab8d09c31fc327a3eecc11aa762e425dd212e958","modified":1509543415000},{"_id":"source/pic/stack01.png","hash":"3817b3bef94154ff67db043c6bd17edb9e194ee4","modified":1563172917313},{"_id":"themes/next/.git/FETCH_HEAD","hash":"778b51a21e3c53e17a5b722a6329f3f7c0eb829f","modified":1552172371000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1509544070000},{"_id":"themes/next/.git/ORIG_HEAD","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1552172371000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1509544070000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1509543799000},{"_id":"themes/next/.git/index","hash":"0fee3696224e1cb4feecf465abd4f15d6f54aa2a","modified":1552172367000},{"_id":"themes/next/.git/packed-refs","hash":"3d90ea66b3b07a3cc335729080c305916def9d29","modified":1509544070000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1509544070000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1552171145000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1509544070000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1509544070000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1509544070000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1509544070000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1509544070000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1509544070000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1509544070000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1509544070000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1509544070000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1509544070000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1509544070000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1509544070000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1509544070000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1509544070000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1552171145000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1509544070000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1509544070000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1509544070000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1552171145000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1509544070000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1509544070000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1509544070000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1509544070000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1509544070000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1509544070000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1509544070000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1552171145000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1509544070000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1509544070000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1509544070000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1509544070000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509544070000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1509543799000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1509543799000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1509543799000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1509543799000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1509543799000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1509543799000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1509543799000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1509543799000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1509543799000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1509543799000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1509543799000},{"_id":"themes/next/.git/logs/HEAD","hash":"39cb0a984c49b974d79c39bb9207f03481c5e544","modified":1552171145000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1509544070000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1509544070000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1509544070000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1509544070000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1552171145000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1509544070000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1552171145000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1509544070000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1552171145000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1509544070000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1509544070000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1509544070000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1509544070000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1509544070000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1509544070000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1509544070000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1509544070000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1509544070000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1509544070000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1509544070000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1509544070000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1509544070000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1509544070000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1509544070000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1509544070000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1509544070000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1509544070000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1509544070000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1509544070000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1509544070000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1509544070000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1509544070000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1509544070000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1509544070000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1509544070000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1509544070000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1509544070000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1509544070000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1509544070000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1509544070000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1509544070000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1509544070000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1509544070000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1509544070000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1509544070000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1509544070000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1509544070000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1509544070000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1509544070000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1509544070000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1509544070000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1509544070000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1509544070000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509544070000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509544070000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509544070000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509544070000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509544070000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509544070000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509544070000},{"_id":"themes/next/.git/objects/pack/pack-9ae6c78bf3a9a7b830d6ae186dd8e9e98a611925.idx","hash":"6787fb6394c39296069ae4f65244e97f1b03e31f","modified":1552171145000},{"_id":"themes/next/.git/refs/heads/master","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1552171145000},{"_id":"themes/next/.git/refs/tags/v5.1.4","hash":"66e8b5048a20ce41a8a240072e535d725d62aef4","modified":1552171145000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1509544070000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1509544070000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1509544070000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1509544070000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1509544070000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1509544070000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1509544070000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1509544070000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1509544070000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1509544070000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1509544070000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1509544070000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1509544070000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1509544070000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1509544070000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1509544070000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1509544070000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1509544070000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1509544070000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1552171145000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1509544070000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1509544070000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1509544070000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1509544070000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1509544070000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1509544070000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1509544070000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1509544070000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1509544070000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1509544070000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1509544070000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1509544070000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1552171145000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1509544070000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1509544070000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1509544070000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1509544070000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1509544070000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1509544070000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1509544070000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1509544070000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1509544070000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1509544070000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1509544070000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1509544070000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1509544070000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1509544070000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1509544070000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1509544070000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1509544070000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1509544070000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1509544070000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1509544070000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1509544070000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1509544070000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1509544070000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1552171145000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1509544070000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1509544070000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1509544070000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1509544070000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1509544070000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1509544070000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1509544070000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1509544070000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1509544070000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1509544070000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1509544070000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1509544070000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1509544070000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1509544070000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1509544070000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1509544070000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1509544070000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1509544070000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1509544070000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1509544070000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1509544070000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1509544070000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1509544070000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1509544070000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1509544070000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1509544070000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1509544070000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"39cb0a984c49b974d79c39bb9207f03481c5e544","modified":1552171145000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1509544070000},{"_id":"themes/next/.git/refs/remotes/origin/master","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1552171145000},{"_id":"themes/next/.git/objects/pack/pack-9ae6c78bf3a9a7b830d6ae186dd8e9e98a611925.pack","hash":"16cdb8a392cb10ef0e3e79aadf8fa039aaf3088a","modified":1552171145000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1509544070000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1509544070000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1509544070000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1509544070000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1509544070000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1509544070000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1509544070000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1509544070000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1552171145000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1552171145000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1509544070000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1509544070000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1509544070000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1509544070000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1509544070000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1509544070000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1509544070000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1509544070000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1509544070000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1509544070000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"7c9ecb7dd20ade36584587a22d0abc1259de64f8","modified":1509544070000},{"_id":"themes/next/.git/logs/refs/remotes/origin/master","hash":"34231e46bd5a116561a7c617c9668304946b5a3f","modified":1552171145000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1552171145000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1552171145000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1509544070000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1509544070000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1509544070000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1509544070000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1509544070000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1509544070000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1509544070000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1509544070000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1509544070000},{"_id":"themes/next/.git/objects/pack/pack-887f512cbfca03943166cc81b8036ba873e3f75f.idx","hash":"4d5441f8aa2cacecd9f34f7c147642f24ac515f7","modified":1509544070000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1509544070000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1509544070000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1509544070000},{"_id":"themes/next/.git/objects/pack/pack-887f512cbfca03943166cc81b8036ba873e3f75f.pack","hash":"a501420dc1801da7b3661634e390975b9a4cc4c8","modified":1509544070000}],"Category":[],"Data":[],"Page":[{"_content":"google-site-verification: google73d573756c531a32.html","source":"google73d573756c531a32.html","raw":"google-site-verification: google73d573756c531a32.html","date":"2017-11-01T13:36:55.000Z","updated":"2017-11-01T13:36:55.000Z","path":"google73d573756c531a32.html","title":"","comments":1,"layout":"page","_id":"cjy416sho000080s6qzzjcrvw","content":"google-site-verification: google73d573756c531a32.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google73d573756c531a32.html"},{"title":"categories","date":"2017-03-28T13:17:02.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-03-28 21:17:02\n---\n","updated":"2017-11-01T13:36:55.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjy416sk0000280s64dw1aim5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tagcloud","date":"2017-03-28T13:18:27.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tagcloud\ndate: 2017-03-28 21:18:27\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-11-01T13:36:55.000Z","path":"tags/index.html","layout":"page","_id":"cjy416sk2000480s622zlaa7u","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"数据结构和算法","date":"2019-03-07T21:30:03.000Z","_content":"# 数据结构和算法\n\n## 目录\n\n1. 简单的数据结构\n\t* 栈、队列、链表、数组、哈希表\n\t* 栈和队列的相同和不同之处\n\t* 栈通常采用的两种存储结构 \n2. 树\n\t* 二叉树、字典树、平衡树、排序树\n\t* B 树、B+ 树、R 树、多路树、红黑树\n\n3. 堆\n\t* 大根堆、小根堆\n\n4. 图\n\t* 有向图、无向图、拓扑\n\n5. 排序算法\n\t* 稳定的排序\n\t\t* 冒泡排序\n\t\t* 插入排序\n\t\t* 鸡尾酒排序\n\t\t* 桶排序\n\t\t* 计数排序\n\t\t* 归并排序\n\t\t* 原地归并排序\n\t\t* 二叉排序树排序\n\t\t* 鸽巢排序\n\t\t* 基数排序\n\t\t* 侏儒排序\n\t\t* 图书馆排序\n\t\t* 块排序\n\t* 不稳定的排序\n\t\t* 选择排序\n\t\t* 希尔排序\n\t\t* Clover 排序算法\n\t\t* 梳排序\n\t\t* 堆排序\n\t\t* 平滑排序\n\t\t* 快速排序\n\t\t* 内省排序\n\t\t* 耐心排序  \n\n6.  两个栈实现队列，和两个队列实现栈\n7. 深度优先和广度优先搜索\n8. 全排列、贪心算法、KMP 算法、hash 算法\n9.  海量数据处理\n\t* 分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce \n\n## 数据结构\n### 栈\n栈是一种“先进后出”的一种数据结构，有压栈出栈两种操作方式\n#### 栈的分类\n栈主要分为两类：\n\n* 静态栈\n* 动态栈\n\n**【静态栈】**\n\n静态栈的核心是数组，类似于一个连续内存的数组，我们只能操作其栈顶元素。\n\n**【动态栈】**\n\n静态栈的核心是数组，类似于一个连续内存的数组，我们只能操作其栈顶节点。\n![MacDown logo](../pic/stack01.png)\n\n#### 栈的算法\n首先要明白以下思路：\n\n* 栈操作的是一个一个节点\n* 栈本身也是一种存储的数据结构\n* 栈有初始化、压栈、出栈、判空、遍历、清空等主要方法\n\n#### 栈的应用\n*  数制转换\n*  括号匹配的检验\n#### 栈通常采用的两种存储结构\n#### 参考地址\n* [https://www.cnblogs.com/xiaoyouPrince/p/8082640.html](https://www.cnblogs.com/xiaoyouPrince/p/8082640.html)\n\n\n### 队列\n\n#### 栈和队列的相同与不同\n### 链表\n### 数组\n### 哈希表\n\n![MacDown logo](../pic/me.jpg)\n","source":"_posts/DataStructuresAndAlgorlthms.md","raw":"---\ntitle: 数据结构和算法\ndate: 2019-03-08 05:30:03\ntags: 数据结构 算法\n---\n# 数据结构和算法\n\n## 目录\n\n1. 简单的数据结构\n\t* 栈、队列、链表、数组、哈希表\n\t* 栈和队列的相同和不同之处\n\t* 栈通常采用的两种存储结构 \n2. 树\n\t* 二叉树、字典树、平衡树、排序树\n\t* B 树、B+ 树、R 树、多路树、红黑树\n\n3. 堆\n\t* 大根堆、小根堆\n\n4. 图\n\t* 有向图、无向图、拓扑\n\n5. 排序算法\n\t* 稳定的排序\n\t\t* 冒泡排序\n\t\t* 插入排序\n\t\t* 鸡尾酒排序\n\t\t* 桶排序\n\t\t* 计数排序\n\t\t* 归并排序\n\t\t* 原地归并排序\n\t\t* 二叉排序树排序\n\t\t* 鸽巢排序\n\t\t* 基数排序\n\t\t* 侏儒排序\n\t\t* 图书馆排序\n\t\t* 块排序\n\t* 不稳定的排序\n\t\t* 选择排序\n\t\t* 希尔排序\n\t\t* Clover 排序算法\n\t\t* 梳排序\n\t\t* 堆排序\n\t\t* 平滑排序\n\t\t* 快速排序\n\t\t* 内省排序\n\t\t* 耐心排序  \n\n6.  两个栈实现队列，和两个队列实现栈\n7. 深度优先和广度优先搜索\n8. 全排列、贪心算法、KMP 算法、hash 算法\n9.  海量数据处理\n\t* 分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce \n\n## 数据结构\n### 栈\n栈是一种“先进后出”的一种数据结构，有压栈出栈两种操作方式\n#### 栈的分类\n栈主要分为两类：\n\n* 静态栈\n* 动态栈\n\n**【静态栈】**\n\n静态栈的核心是数组，类似于一个连续内存的数组，我们只能操作其栈顶元素。\n\n**【动态栈】**\n\n静态栈的核心是数组，类似于一个连续内存的数组，我们只能操作其栈顶节点。\n![MacDown logo](../pic/stack01.png)\n\n#### 栈的算法\n首先要明白以下思路：\n\n* 栈操作的是一个一个节点\n* 栈本身也是一种存储的数据结构\n* 栈有初始化、压栈、出栈、判空、遍历、清空等主要方法\n\n#### 栈的应用\n*  数制转换\n*  括号匹配的检验\n#### 栈通常采用的两种存储结构\n#### 参考地址\n* [https://www.cnblogs.com/xiaoyouPrince/p/8082640.html](https://www.cnblogs.com/xiaoyouPrince/p/8082640.html)\n\n\n### 队列\n\n#### 栈和队列的相同与不同\n### 链表\n### 数组\n### 哈希表\n\n![MacDown logo](../pic/me.jpg)\n","slug":"DataStructuresAndAlgorlthms","published":1,"updated":"2019-07-15T06:41:57.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416sjw000180s6fs9ddltu","content":"<h1 id=\"数据结构和算法\"><a href=\"#数据结构和算法\" class=\"headerlink\" title=\"数据结构和算法\"></a>数据结构和算法</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li>简单的数据结构<ul>\n<li>栈、队列、链表、数组、哈希表</li>\n<li>栈和队列的相同和不同之处</li>\n<li>栈通常采用的两种存储结构 </li>\n</ul>\n</li>\n<li><p>树</p>\n<ul>\n<li>二叉树、字典树、平衡树、排序树</li>\n<li>B 树、B+ 树、R 树、多路树、红黑树</li>\n</ul>\n</li>\n<li><p>堆</p>\n<ul>\n<li>大根堆、小根堆</li>\n</ul>\n</li>\n<li><p>图</p>\n<ul>\n<li>有向图、无向图、拓扑</li>\n</ul>\n</li>\n<li><p>排序算法</p>\n<ul>\n<li>稳定的排序<ul>\n<li>冒泡排序</li>\n<li>插入排序</li>\n<li>鸡尾酒排序</li>\n<li>桶排序</li>\n<li>计数排序</li>\n<li>归并排序</li>\n<li>原地归并排序</li>\n<li>二叉排序树排序</li>\n<li>鸽巢排序</li>\n<li>基数排序</li>\n<li>侏儒排序</li>\n<li>图书馆排序</li>\n<li>块排序</li>\n</ul>\n</li>\n<li>不稳定的排序<ul>\n<li>选择排序</li>\n<li>希尔排序</li>\n<li>Clover 排序算法</li>\n<li>梳排序</li>\n<li>堆排序</li>\n<li>平滑排序</li>\n<li>快速排序</li>\n<li>内省排序</li>\n<li>耐心排序  </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>两个栈实现队列，和两个队列实现栈</p>\n</li>\n<li>深度优先和广度优先搜索</li>\n<li>全排列、贪心算法、KMP 算法、hash 算法</li>\n<li>海量数据处理<ul>\n<li>分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce </li>\n</ul>\n</li>\n</ol>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>栈是一种“先进后出”的一种数据结构，有压栈出栈两种操作方式</p>\n<h4 id=\"栈的分类\"><a href=\"#栈的分类\" class=\"headerlink\" title=\"栈的分类\"></a>栈的分类</h4><p>栈主要分为两类：</p>\n<ul>\n<li>静态栈</li>\n<li>动态栈</li>\n</ul>\n<p><strong>【静态栈】</strong></p>\n<p>静态栈的核心是数组，类似于一个连续内存的数组，我们只能操作其栈顶元素。</p>\n<p><strong>【动态栈】</strong></p>\n<p>静态栈的核心是数组，类似于一个连续内存的数组，我们只能操作其栈顶节点。<br><img src=\"../pic/stack01.png\" alt=\"MacDown logo\"></p>\n<h4 id=\"栈的算法\"><a href=\"#栈的算法\" class=\"headerlink\" title=\"栈的算法\"></a>栈的算法</h4><p>首先要明白以下思路：</p>\n<ul>\n<li>栈操作的是一个一个节点</li>\n<li>栈本身也是一种存储的数据结构</li>\n<li>栈有初始化、压栈、出栈、判空、遍历、清空等主要方法</li>\n</ul>\n<h4 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h4><ul>\n<li>数制转换</li>\n<li>括号匹配的检验<h4 id=\"栈通常采用的两种存储结构\"><a href=\"#栈通常采用的两种存储结构\" class=\"headerlink\" title=\"栈通常采用的两种存储结构\"></a>栈通常采用的两种存储结构</h4><h4 id=\"参考地址\"><a href=\"#参考地址\" class=\"headerlink\" title=\"参考地址\"></a>参考地址</h4></li>\n<li><a href=\"https://www.cnblogs.com/xiaoyouPrince/p/8082640.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xiaoyouPrince/p/8082640.html</a></li>\n</ul>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><h4 id=\"栈和队列的相同与不同\"><a href=\"#栈和队列的相同与不同\" class=\"headerlink\" title=\"栈和队列的相同与不同\"></a>栈和队列的相同与不同</h4><h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><p><img src=\"../pic/me.jpg\" alt=\"MacDown logo\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数据结构和算法\"><a href=\"#数据结构和算法\" class=\"headerlink\" title=\"数据结构和算法\"></a>数据结构和算法</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li>简单的数据结构<ul>\n<li>栈、队列、链表、数组、哈希表</li>\n<li>栈和队列的相同和不同之处</li>\n<li>栈通常采用的两种存储结构 </li>\n</ul>\n</li>\n<li><p>树</p>\n<ul>\n<li>二叉树、字典树、平衡树、排序树</li>\n<li>B 树、B+ 树、R 树、多路树、红黑树</li>\n</ul>\n</li>\n<li><p>堆</p>\n<ul>\n<li>大根堆、小根堆</li>\n</ul>\n</li>\n<li><p>图</p>\n<ul>\n<li>有向图、无向图、拓扑</li>\n</ul>\n</li>\n<li><p>排序算法</p>\n<ul>\n<li>稳定的排序<ul>\n<li>冒泡排序</li>\n<li>插入排序</li>\n<li>鸡尾酒排序</li>\n<li>桶排序</li>\n<li>计数排序</li>\n<li>归并排序</li>\n<li>原地归并排序</li>\n<li>二叉排序树排序</li>\n<li>鸽巢排序</li>\n<li>基数排序</li>\n<li>侏儒排序</li>\n<li>图书馆排序</li>\n<li>块排序</li>\n</ul>\n</li>\n<li>不稳定的排序<ul>\n<li>选择排序</li>\n<li>希尔排序</li>\n<li>Clover 排序算法</li>\n<li>梳排序</li>\n<li>堆排序</li>\n<li>平滑排序</li>\n<li>快速排序</li>\n<li>内省排序</li>\n<li>耐心排序  </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>两个栈实现队列，和两个队列实现栈</p>\n</li>\n<li>深度优先和广度优先搜索</li>\n<li>全排列、贪心算法、KMP 算法、hash 算法</li>\n<li>海量数据处理<ul>\n<li>分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce </li>\n</ul>\n</li>\n</ol>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>栈是一种“先进后出”的一种数据结构，有压栈出栈两种操作方式</p>\n<h4 id=\"栈的分类\"><a href=\"#栈的分类\" class=\"headerlink\" title=\"栈的分类\"></a>栈的分类</h4><p>栈主要分为两类：</p>\n<ul>\n<li>静态栈</li>\n<li>动态栈</li>\n</ul>\n<p><strong>【静态栈】</strong></p>\n<p>静态栈的核心是数组，类似于一个连续内存的数组，我们只能操作其栈顶元素。</p>\n<p><strong>【动态栈】</strong></p>\n<p>静态栈的核心是数组，类似于一个连续内存的数组，我们只能操作其栈顶节点。<br><img src=\"../pic/stack01.png\" alt=\"MacDown logo\"></p>\n<h4 id=\"栈的算法\"><a href=\"#栈的算法\" class=\"headerlink\" title=\"栈的算法\"></a>栈的算法</h4><p>首先要明白以下思路：</p>\n<ul>\n<li>栈操作的是一个一个节点</li>\n<li>栈本身也是一种存储的数据结构</li>\n<li>栈有初始化、压栈、出栈、判空、遍历、清空等主要方法</li>\n</ul>\n<h4 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h4><ul>\n<li>数制转换</li>\n<li>括号匹配的检验<h4 id=\"栈通常采用的两种存储结构\"><a href=\"#栈通常采用的两种存储结构\" class=\"headerlink\" title=\"栈通常采用的两种存储结构\"></a>栈通常采用的两种存储结构</h4><h4 id=\"参考地址\"><a href=\"#参考地址\" class=\"headerlink\" title=\"参考地址\"></a>参考地址</h4></li>\n<li><a href=\"https://www.cnblogs.com/xiaoyouPrince/p/8082640.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xiaoyouPrince/p/8082640.html</a></li>\n</ul>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><h4 id=\"栈和队列的相同与不同\"><a href=\"#栈和队列的相同与不同\" class=\"headerlink\" title=\"栈和队列的相同与不同\"></a>栈和队列的相同与不同</h4><h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><p><img src=\"../pic/me.jpg\" alt=\"MacDown logo\"></p>\n"},{"title":"算法（java版）","date":"2017-03-30T13:43:22.000Z","_content":"## 冒泡排序\n\t\n\tpublic static void bubbleSort(int[] a) {\n\t\tif (a == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = a.length - 1; j > i; j--) {\n\t\t\t\tif (a[j - 1] > a[j]) {\n\t\t\t\t\tint temp = a[j];\n\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\ta[j - 1] = temp;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tSystem.out.println(a[i]);\n\t\t}\n\t}\n\t\n## 朴素模式匹配算法\n\n\t//朴素模式匹配算法\n\t\tpublic static int index(String s,String t,int pos){\n\t\tint i=pos;//主串中第几个位置开始比较\n\t\tint j=0;//模式串中的第一个位置\n\t\twhile(i<s.length()&&j<t.length()){\n\t\t\tif(s.charAt(i)==t.charAt(j)){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}else{\n\t\t\t\ti=i-j+1;//主串的下一个位置\n\t\t\t\tj=0;//继续第一个位置\n\t\t\t}\n\t\t}\n\t\tif(j>=t.length()){\n\t\t\treturn i-t.length();\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n## KMP模式匹配算法\t\n\n\t//////////KMP模式匹配算法////////////////\n\t\tpublic static int[] getNext(String t){\n\t\t\tSystem.out.println(t);\n\t\t\tint[] next=new int[t.length()];\n\t\t\tint i=1;\n\t\t\tint j=0;\n\t\t\t\n\t\t\tnext[i]=j;\n\t\t\t\n\t\t\twhile(i<t.length()-1){\n\t\t\t\t\n\t\t\t\tif(j==0||t.charAt(i)==t.charAt(j)){\n\t//\t\t\t\tSystem.out.print(\"i=\"+i+\" \"+t.charAt(i)+\"、\");\n\t//\t\t\t\tSystem.out.print(\"j=\"+j+\" \"+t.charAt(j)+\";\");\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tnext[i]=j;\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t\tj=next[j];//若字符不相等，则j值进行回溯。\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tfor(int k=0;k<next.length;k++){\n\t\t\t\tSystem.out.print(next[k]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\treturn next;\n\t\t}\n\t\t\n\t\tpublic static int indexKMP(String s,String t,int pos){\n\t\t\tint i=pos;//表示从主串中第几个字符串开始匹配\n\t\t\tint j=0;//表示从模式串中第几个字符串开始\n\t\t\tint[] next=getNext(t);\n\t\t\twhile(i<s.length()&&j<t.length()){\n\t\t\t\tif(j==0||s.charAt(i)==t.charAt(j)){\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}else{\n\t\t\t\t\tj=next[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j>=t.length()){\n\t\t\t\treturn i-t.length();\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t","source":"_posts/arithmetic.md","raw":"---\ntitle: 算法（java版）\ndate: 2017-03-30 21:43:22\ntags: 冒泡 排序\n---\n## 冒泡排序\n\t\n\tpublic static void bubbleSort(int[] a) {\n\t\tif (a == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = a.length - 1; j > i; j--) {\n\t\t\t\tif (a[j - 1] > a[j]) {\n\t\t\t\t\tint temp = a[j];\n\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\ta[j - 1] = temp;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tSystem.out.println(a[i]);\n\t\t}\n\t}\n\t\n## 朴素模式匹配算法\n\n\t//朴素模式匹配算法\n\t\tpublic static int index(String s,String t,int pos){\n\t\tint i=pos;//主串中第几个位置开始比较\n\t\tint j=0;//模式串中的第一个位置\n\t\twhile(i<s.length()&&j<t.length()){\n\t\t\tif(s.charAt(i)==t.charAt(j)){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}else{\n\t\t\t\ti=i-j+1;//主串的下一个位置\n\t\t\t\tj=0;//继续第一个位置\n\t\t\t}\n\t\t}\n\t\tif(j>=t.length()){\n\t\t\treturn i-t.length();\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n## KMP模式匹配算法\t\n\n\t//////////KMP模式匹配算法////////////////\n\t\tpublic static int[] getNext(String t){\n\t\t\tSystem.out.println(t);\n\t\t\tint[] next=new int[t.length()];\n\t\t\tint i=1;\n\t\t\tint j=0;\n\t\t\t\n\t\t\tnext[i]=j;\n\t\t\t\n\t\t\twhile(i<t.length()-1){\n\t\t\t\t\n\t\t\t\tif(j==0||t.charAt(i)==t.charAt(j)){\n\t//\t\t\t\tSystem.out.print(\"i=\"+i+\" \"+t.charAt(i)+\"、\");\n\t//\t\t\t\tSystem.out.print(\"j=\"+j+\" \"+t.charAt(j)+\";\");\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tnext[i]=j;\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t\tj=next[j];//若字符不相等，则j值进行回溯。\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tfor(int k=0;k<next.length;k++){\n\t\t\t\tSystem.out.print(next[k]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\treturn next;\n\t\t}\n\t\t\n\t\tpublic static int indexKMP(String s,String t,int pos){\n\t\t\tint i=pos;//表示从主串中第几个字符串开始匹配\n\t\t\tint j=0;//表示从模式串中第几个字符串开始\n\t\t\tint[] next=getNext(t);\n\t\t\twhile(i<s.length()&&j<t.length()){\n\t\t\t\tif(j==0||s.charAt(i)==t.charAt(j)){\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}else{\n\t\t\t\t\tj=next[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j>=t.length()){\n\t\t\t\treturn i-t.length();\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t","slug":"arithmetic","published":1,"updated":"2019-07-15T06:41:57.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416sk0000380s69nlakfkt","content":"<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><pre><code>public static void bubbleSort(int[] a) {\n    if (a == null) {\n        return;\n    }\n\n    for (int i = 0; i &lt; a.length; i++) {\n        for (int j = a.length - 1; j &gt; i; j--) {\n            if (a[j - 1] &gt; a[j]) {\n                int temp = a[j];\n                a[j] = a[j - 1];\n                a[j - 1] = temp;\n            }\n\n        }\n    }\n\n    for (int i = 0; i &lt; a.length; i++) {\n        System.out.println(a[i]);\n    }\n}\n</code></pre><h2 id=\"朴素模式匹配算法\"><a href=\"#朴素模式匹配算法\" class=\"headerlink\" title=\"朴素模式匹配算法\"></a>朴素模式匹配算法</h2><pre><code>//朴素模式匹配算法\n    public static int index(String s,String t,int pos){\n    int i=pos;//主串中第几个位置开始比较\n    int j=0;//模式串中的第一个位置\n    while(i&lt;s.length()&amp;&amp;j&lt;t.length()){\n        if(s.charAt(i)==t.charAt(j)){\n            i++;\n            j++;\n        }else{\n            i=i-j+1;//主串的下一个位置\n            j=0;//继续第一个位置\n        }\n    }\n    if(j&gt;=t.length()){\n        return i-t.length();\n    }else{\n        return -1;\n    }\n}\n</code></pre><h2 id=\"KMP模式匹配算法\"><a href=\"#KMP模式匹配算法\" class=\"headerlink\" title=\"KMP模式匹配算法\"></a>KMP模式匹配算法</h2><pre><code>//////////KMP模式匹配算法////////////////\n    public static int[] getNext(String t){\n        System.out.println(t);\n        int[] next=new int[t.length()];\n        int i=1;\n        int j=0;\n\n        next[i]=j;\n\n        while(i&lt;t.length()-1){\n\n            if(j==0||t.charAt(i)==t.charAt(j)){\n//                System.out.print(&quot;i=&quot;+i+&quot; &quot;+t.charAt(i)+&quot;、&quot;);\n//                System.out.print(&quot;j=&quot;+j+&quot; &quot;+t.charAt(j)+&quot;;&quot;);\n                i++;\n                j++;\n                next[i]=j;\n            }else{\n                System.out.println();\n                j=next[j];//若字符不相等，则j值进行回溯。\n            }\n\n        }\n        System.out.println();\n        for(int k=0;k&lt;next.length;k++){\n            System.out.print(next[k]);\n        }\n        System.out.println();\n        return next;\n    }\n\n    public static int indexKMP(String s,String t,int pos){\n        int i=pos;//表示从主串中第几个字符串开始匹配\n        int j=0;//表示从模式串中第几个字符串开始\n        int[] next=getNext(t);\n        while(i&lt;s.length()&amp;&amp;j&lt;t.length()){\n            if(j==0||s.charAt(i)==t.charAt(j)){\n                i++;\n                j++;\n            }else{\n                j=next[j];\n            }\n        }\n        if(j&gt;=t.length()){\n            return i-t.length();\n        }else{\n            return 0;\n        }\n\n    }\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><pre><code>public static void bubbleSort(int[] a) {\n    if (a == null) {\n        return;\n    }\n\n    for (int i = 0; i &lt; a.length; i++) {\n        for (int j = a.length - 1; j &gt; i; j--) {\n            if (a[j - 1] &gt; a[j]) {\n                int temp = a[j];\n                a[j] = a[j - 1];\n                a[j - 1] = temp;\n            }\n\n        }\n    }\n\n    for (int i = 0; i &lt; a.length; i++) {\n        System.out.println(a[i]);\n    }\n}\n</code></pre><h2 id=\"朴素模式匹配算法\"><a href=\"#朴素模式匹配算法\" class=\"headerlink\" title=\"朴素模式匹配算法\"></a>朴素模式匹配算法</h2><pre><code>//朴素模式匹配算法\n    public static int index(String s,String t,int pos){\n    int i=pos;//主串中第几个位置开始比较\n    int j=0;//模式串中的第一个位置\n    while(i&lt;s.length()&amp;&amp;j&lt;t.length()){\n        if(s.charAt(i)==t.charAt(j)){\n            i++;\n            j++;\n        }else{\n            i=i-j+1;//主串的下一个位置\n            j=0;//继续第一个位置\n        }\n    }\n    if(j&gt;=t.length()){\n        return i-t.length();\n    }else{\n        return -1;\n    }\n}\n</code></pre><h2 id=\"KMP模式匹配算法\"><a href=\"#KMP模式匹配算法\" class=\"headerlink\" title=\"KMP模式匹配算法\"></a>KMP模式匹配算法</h2><pre><code>//////////KMP模式匹配算法////////////////\n    public static int[] getNext(String t){\n        System.out.println(t);\n        int[] next=new int[t.length()];\n        int i=1;\n        int j=0;\n\n        next[i]=j;\n\n        while(i&lt;t.length()-1){\n\n            if(j==0||t.charAt(i)==t.charAt(j)){\n//                System.out.print(&quot;i=&quot;+i+&quot; &quot;+t.charAt(i)+&quot;、&quot;);\n//                System.out.print(&quot;j=&quot;+j+&quot; &quot;+t.charAt(j)+&quot;;&quot;);\n                i++;\n                j++;\n                next[i]=j;\n            }else{\n                System.out.println();\n                j=next[j];//若字符不相等，则j值进行回溯。\n            }\n\n        }\n        System.out.println();\n        for(int k=0;k&lt;next.length;k++){\n            System.out.print(next[k]);\n        }\n        System.out.println();\n        return next;\n    }\n\n    public static int indexKMP(String s,String t,int pos){\n        int i=pos;//表示从主串中第几个字符串开始匹配\n        int j=0;//表示从模式串中第几个字符串开始\n        int[] next=getNext(t);\n        while(i&lt;s.length()&amp;&amp;j&lt;t.length()){\n            if(j==0||s.charAt(i)==t.charAt(j)){\n                i++;\n                j++;\n            }else{\n                j=next[j];\n            }\n        }\n        if(j&gt;=t.length()){\n            return i-t.length();\n        }else{\n            return 0;\n        }\n\n    }\n</code></pre>"},{"title":"【Jenkins】自动构建配置","date":"2018-05-13T07:10:46.000Z","_content":"### 时间设置说明\n\n\t\t\t* * * * *\n\t\t\t(五颗星，中间用空格隔开）\n\t\t\t第一颗*表示分钟，取值0~59\n\t\t\t第二颗*表示小时，取值0~23\n\t\t\t第三颗*表示一个月的第几天，取值1~31\n\t\t\t第四颗*表示第几月，取值1~12\n\t\t\t第五颗*表示一周中的第几天，取值0~7，其中0和7代表的都是周日\n\t\t\t\n例子如下：\n\n\t\t\t\t每15分钟构建一次：H/15 * * * *   或*/5 * * * *\n\t\t\t\t每天8点构建一次：0 8 * * *\n\t\t\t\t每天8点~17点，两小时构建一次：0 8-17/2 * * *\n\t\t\t\t周一到周五，8点~17点，两小时构建一次：0 8-17/2 * * 1-5\n\t\t\t\t每月1号、15号各构建一次，除12月：H H 1,15 1-11 *\n\t\t\t\t*/5 * * * * （每5分钟检查一次源码变化）\n\t\t\t\t0 2 * * * （每天2:00 必须build一次源码）\n\n### 触发远程构建 例如,使用脚本\n\n### Build after other projects are built\nProjects to watch “XXXXX”\n\n\t* Trigger only if build is stable：只有在构建稳定时才触发\n\t* \n\t* Trigger even if the build is unstable：即使构建不稳定，也要触发\n\t* \n\t* Trigger even if the build fails：即使构建失败，也要触发\n\t* \n\n### Build periodically\n周期性进行项目构建，这个是到指定的时间必须触发构建任务\n比如我想在每天的9点，17点，朝九晚五各构建一次，在Build periodically里设置如下\n![](http://i2.51cto.com/images/blog/201803/26/9bafd3a8ed881183ce75f56363f54270.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)\n\n\n### Build when a change is pushed to GitLab. GitLab CI Service URL: XXXXX\n\n* \tEnabled GitLab triggers\t：启用GitLab触发器\n* \tPush Events：push 事件\n* \tOpened Merge Request Events：打开合并请求事件\n* \tAccepted Merge Request Events\t\t：接受合并请求事件\n* \t Closed Merge Request Events\t\t：关闭合并请求事件\n* \t Rebuild open Merge Requests\t\t：重建开放合并请求\n* \t Comments\t\t：评论\n* \t Comment for triggering a build：注释触发构建\n\n### GitHub hook trigger for GITScm polling\nGitHub钩子触发GITScm轮询\n\n### Poll SCM\n1.Poll SCM:定时检查源码变更（根据SCM软件的版本号），如果有更新就checkout最新code下来，然后执行构建动作\n\n2.如果我想每隔30分钟（H/30 * * * *）检查一次源码变化，有变化就执行\n\nIgnore post-commit hooks(可选项):忽略post-commit钩子\n\n\n## 联系我\n> Email:lichongmac@163.com\n\n支付宝打赏：[https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A](https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A)\n\n微信打赏：[https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ](https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ)\n\n公众号推荐：\n\n![](http://i2.51cto.com/images/blog/201805/11/0e2ece55187caabd7b246e9550a8d5a0.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)","source":"_posts/Jenkins01.md","raw":"---\ntitle: 【Jenkins】自动构建配置\ndate: 2018-05-13 15:10:46\ntags: Jenkins 自动构建 \n---\n### 时间设置说明\n\n\t\t\t* * * * *\n\t\t\t(五颗星，中间用空格隔开）\n\t\t\t第一颗*表示分钟，取值0~59\n\t\t\t第二颗*表示小时，取值0~23\n\t\t\t第三颗*表示一个月的第几天，取值1~31\n\t\t\t第四颗*表示第几月，取值1~12\n\t\t\t第五颗*表示一周中的第几天，取值0~7，其中0和7代表的都是周日\n\t\t\t\n例子如下：\n\n\t\t\t\t每15分钟构建一次：H/15 * * * *   或*/5 * * * *\n\t\t\t\t每天8点构建一次：0 8 * * *\n\t\t\t\t每天8点~17点，两小时构建一次：0 8-17/2 * * *\n\t\t\t\t周一到周五，8点~17点，两小时构建一次：0 8-17/2 * * 1-5\n\t\t\t\t每月1号、15号各构建一次，除12月：H H 1,15 1-11 *\n\t\t\t\t*/5 * * * * （每5分钟检查一次源码变化）\n\t\t\t\t0 2 * * * （每天2:00 必须build一次源码）\n\n### 触发远程构建 例如,使用脚本\n\n### Build after other projects are built\nProjects to watch “XXXXX”\n\n\t* Trigger only if build is stable：只有在构建稳定时才触发\n\t* \n\t* Trigger even if the build is unstable：即使构建不稳定，也要触发\n\t* \n\t* Trigger even if the build fails：即使构建失败，也要触发\n\t* \n\n### Build periodically\n周期性进行项目构建，这个是到指定的时间必须触发构建任务\n比如我想在每天的9点，17点，朝九晚五各构建一次，在Build periodically里设置如下\n![](http://i2.51cto.com/images/blog/201803/26/9bafd3a8ed881183ce75f56363f54270.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)\n\n\n### Build when a change is pushed to GitLab. GitLab CI Service URL: XXXXX\n\n* \tEnabled GitLab triggers\t：启用GitLab触发器\n* \tPush Events：push 事件\n* \tOpened Merge Request Events：打开合并请求事件\n* \tAccepted Merge Request Events\t\t：接受合并请求事件\n* \t Closed Merge Request Events\t\t：关闭合并请求事件\n* \t Rebuild open Merge Requests\t\t：重建开放合并请求\n* \t Comments\t\t：评论\n* \t Comment for triggering a build：注释触发构建\n\n### GitHub hook trigger for GITScm polling\nGitHub钩子触发GITScm轮询\n\n### Poll SCM\n1.Poll SCM:定时检查源码变更（根据SCM软件的版本号），如果有更新就checkout最新code下来，然后执行构建动作\n\n2.如果我想每隔30分钟（H/30 * * * *）检查一次源码变化，有变化就执行\n\nIgnore post-commit hooks(可选项):忽略post-commit钩子\n\n\n## 联系我\n> Email:lichongmac@163.com\n\n支付宝打赏：[https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A](https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A)\n\n微信打赏：[https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ](https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ)\n\n公众号推荐：\n\n![](http://i2.51cto.com/images/blog/201805/11/0e2ece55187caabd7b246e9550a8d5a0.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)","slug":"Jenkins01","published":1,"updated":"2019-07-15T06:42:03.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416sk5000680s69zukmmsl","content":"<h3 id=\"时间设置说明\"><a href=\"#时间设置说明\" class=\"headerlink\" title=\"时间设置说明\"></a>时间设置说明</h3><pre><code>* * * * *\n(五颗星，中间用空格隔开）\n第一颗*表示分钟，取值0~59\n第二颗*表示小时，取值0~23\n第三颗*表示一个月的第几天，取值1~31\n第四颗*表示第几月，取值1~12\n第五颗*表示一周中的第几天，取值0~7，其中0和7代表的都是周日\n</code></pre><p>例子如下：</p>\n<pre><code>每15分钟构建一次：H/15 * * * *   或*/5 * * * *\n每天8点构建一次：0 8 * * *\n每天8点~17点，两小时构建一次：0 8-17/2 * * *\n周一到周五，8点~17点，两小时构建一次：0 8-17/2 * * 1-5\n每月1号、15号各构建一次，除12月：H H 1,15 1-11 *\n*/5 * * * * （每5分钟检查一次源码变化）\n0 2 * * * （每天2:00 必须build一次源码）\n</code></pre><h3 id=\"触发远程构建-例如-使用脚本\"><a href=\"#触发远程构建-例如-使用脚本\" class=\"headerlink\" title=\"触发远程构建 例如,使用脚本\"></a>触发远程构建 例如,使用脚本</h3><h3 id=\"Build-after-other-projects-are-built\"><a href=\"#Build-after-other-projects-are-built\" class=\"headerlink\" title=\"Build after other projects are built\"></a>Build after other projects are built</h3><p>Projects to watch “XXXXX”</p>\n<pre><code>* Trigger only if build is stable：只有在构建稳定时才触发\n* \n* Trigger even if the build is unstable：即使构建不稳定，也要触发\n* \n* Trigger even if the build fails：即使构建失败，也要触发\n* \n</code></pre><h3 id=\"Build-periodically\"><a href=\"#Build-periodically\" class=\"headerlink\" title=\"Build periodically\"></a>Build periodically</h3><p>周期性进行项目构建，这个是到指定的时间必须触发构建任务<br>比如我想在每天的9点，17点，朝九晚五各构建一次，在Build periodically里设置如下<br><img src=\"http://i2.51cto.com/images/blog/201803/26/9bafd3a8ed881183ce75f56363f54270.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=\" alt></p>\n<h3 id=\"Build-when-a-change-is-pushed-to-GitLab-GitLab-CI-Service-URL-XXXXX\"><a href=\"#Build-when-a-change-is-pushed-to-GitLab-GitLab-CI-Service-URL-XXXXX\" class=\"headerlink\" title=\"Build when a change is pushed to GitLab. GitLab CI Service URL: XXXXX\"></a>Build when a change is pushed to GitLab. GitLab CI Service URL: XXXXX</h3><ul>\n<li>Enabled GitLab triggers    ：启用GitLab触发器</li>\n<li>Push Events：push 事件</li>\n<li>Opened Merge Request Events：打开合并请求事件</li>\n<li>Accepted Merge Request Events        ：接受合并请求事件</li>\n<li>Closed Merge Request Events        ：关闭合并请求事件</li>\n<li>Rebuild open Merge Requests        ：重建开放合并请求</li>\n<li>Comments        ：评论</li>\n<li>Comment for triggering a build：注释触发构建</li>\n</ul>\n<h3 id=\"GitHub-hook-trigger-for-GITScm-polling\"><a href=\"#GitHub-hook-trigger-for-GITScm-polling\" class=\"headerlink\" title=\"GitHub hook trigger for GITScm polling\"></a>GitHub hook trigger for GITScm polling</h3><p>GitHub钩子触发GITScm轮询</p>\n<h3 id=\"Poll-SCM\"><a href=\"#Poll-SCM\" class=\"headerlink\" title=\"Poll SCM\"></a>Poll SCM</h3><p>1.Poll SCM:定时检查源码变更（根据SCM软件的版本号），如果有更新就checkout最新code下来，然后执行构建动作</p>\n<p>2.如果我想每隔30分钟（H/30 <em> </em> <em> </em>）检查一次源码变化，有变化就执行</p>\n<p>Ignore post-commit hooks(可选项):忽略post-commit钩子</p>\n<h2 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h2><blockquote>\n<p>Email:<a href=\"mailto:lichongmac@163.com\" target=\"_blank\" rel=\"noopener\">lichongmac@163.com</a></p>\n</blockquote>\n<p>支付宝打赏：<a href=\"https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A</a></p>\n<p>微信打赏：<a href=\"https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ</a></p>\n<p>公众号推荐：</p>\n<p><img src=\"http://i2.51cto.com/images/blog/201805/11/0e2ece55187caabd7b246e9550a8d5a0.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"时间设置说明\"><a href=\"#时间设置说明\" class=\"headerlink\" title=\"时间设置说明\"></a>时间设置说明</h3><pre><code>* * * * *\n(五颗星，中间用空格隔开）\n第一颗*表示分钟，取值0~59\n第二颗*表示小时，取值0~23\n第三颗*表示一个月的第几天，取值1~31\n第四颗*表示第几月，取值1~12\n第五颗*表示一周中的第几天，取值0~7，其中0和7代表的都是周日\n</code></pre><p>例子如下：</p>\n<pre><code>每15分钟构建一次：H/15 * * * *   或*/5 * * * *\n每天8点构建一次：0 8 * * *\n每天8点~17点，两小时构建一次：0 8-17/2 * * *\n周一到周五，8点~17点，两小时构建一次：0 8-17/2 * * 1-5\n每月1号、15号各构建一次，除12月：H H 1,15 1-11 *\n*/5 * * * * （每5分钟检查一次源码变化）\n0 2 * * * （每天2:00 必须build一次源码）\n</code></pre><h3 id=\"触发远程构建-例如-使用脚本\"><a href=\"#触发远程构建-例如-使用脚本\" class=\"headerlink\" title=\"触发远程构建 例如,使用脚本\"></a>触发远程构建 例如,使用脚本</h3><h3 id=\"Build-after-other-projects-are-built\"><a href=\"#Build-after-other-projects-are-built\" class=\"headerlink\" title=\"Build after other projects are built\"></a>Build after other projects are built</h3><p>Projects to watch “XXXXX”</p>\n<pre><code>* Trigger only if build is stable：只有在构建稳定时才触发\n* \n* Trigger even if the build is unstable：即使构建不稳定，也要触发\n* \n* Trigger even if the build fails：即使构建失败，也要触发\n* \n</code></pre><h3 id=\"Build-periodically\"><a href=\"#Build-periodically\" class=\"headerlink\" title=\"Build periodically\"></a>Build periodically</h3><p>周期性进行项目构建，这个是到指定的时间必须触发构建任务<br>比如我想在每天的9点，17点，朝九晚五各构建一次，在Build periodically里设置如下<br><img src=\"http://i2.51cto.com/images/blog/201803/26/9bafd3a8ed881183ce75f56363f54270.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=\" alt></p>\n<h3 id=\"Build-when-a-change-is-pushed-to-GitLab-GitLab-CI-Service-URL-XXXXX\"><a href=\"#Build-when-a-change-is-pushed-to-GitLab-GitLab-CI-Service-URL-XXXXX\" class=\"headerlink\" title=\"Build when a change is pushed to GitLab. GitLab CI Service URL: XXXXX\"></a>Build when a change is pushed to GitLab. GitLab CI Service URL: XXXXX</h3><ul>\n<li>Enabled GitLab triggers    ：启用GitLab触发器</li>\n<li>Push Events：push 事件</li>\n<li>Opened Merge Request Events：打开合并请求事件</li>\n<li>Accepted Merge Request Events        ：接受合并请求事件</li>\n<li>Closed Merge Request Events        ：关闭合并请求事件</li>\n<li>Rebuild open Merge Requests        ：重建开放合并请求</li>\n<li>Comments        ：评论</li>\n<li>Comment for triggering a build：注释触发构建</li>\n</ul>\n<h3 id=\"GitHub-hook-trigger-for-GITScm-polling\"><a href=\"#GitHub-hook-trigger-for-GITScm-polling\" class=\"headerlink\" title=\"GitHub hook trigger for GITScm polling\"></a>GitHub hook trigger for GITScm polling</h3><p>GitHub钩子触发GITScm轮询</p>\n<h3 id=\"Poll-SCM\"><a href=\"#Poll-SCM\" class=\"headerlink\" title=\"Poll SCM\"></a>Poll SCM</h3><p>1.Poll SCM:定时检查源码变更（根据SCM软件的版本号），如果有更新就checkout最新code下来，然后执行构建动作</p>\n<p>2.如果我想每隔30分钟（H/30 <em> </em> <em> </em>）检查一次源码变化，有变化就执行</p>\n<p>Ignore post-commit hooks(可选项):忽略post-commit钩子</p>\n<h2 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h2><blockquote>\n<p>Email:<a href=\"mailto:lichongmac@163.com\" target=\"_blank\" rel=\"noopener\">lichongmac@163.com</a></p>\n</blockquote>\n<p>支付宝打赏：<a href=\"https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A</a></p>\n<p>微信打赏：<a href=\"https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ</a></p>\n<p>公众号推荐：</p>\n<p><img src=\"http://i2.51cto.com/images/blog/201805/11/0e2ece55187caabd7b246e9550a8d5a0.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=\" alt></p>\n"},{"title":"简历-李冲","date":"2017-03-11T12:11:01.000Z","_content":"\n\n> ### 个人信息\n\n**姓 名：李冲**\t\n\n工作年限：7 年\t\t                 \n\n岗位：Android高级工程师\n\n学 历：本科\n\n邮  箱：*lichongmac@163.com*        \n\n专 业：计算机科学与技术\n\n博客地址：*[http://blog.51cto.com/4789781](http://blog.51cto.com/4789781)*  \n\n# 工作经历\n\n## 亮风台信息科技有限公司\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/hiscene_logo.jpg)\n\n2018/02--至今 \n\n**项目：HiARSDK定制化开发**\n\n**简介：** \n\t\n\t主要服务于：\n\t\t\t\t汽车之家\n\t\t\t\t玉泉旅游景区\n\t\t\t\t上汽AR说明书\n\t\t\t\t民生银行研究院\n\t\t\t\t河北师大AR实验室等\n\n\n**关键技术：**\n\n\t图像识别、图像跟踪、slam位姿跟踪等底层算法集成；\n\t\t\t\t\n\tCamera相机方案优化等；\n\n主要职责：\n\n\t按客户AR业务场景需求选择合适的图像方案，设计开发交付符合客户要求（包体大小、性能等）的HiARSDK集成包；\n\t提供Android技术支持2D图像算法组、Slam位姿识别算法组、CNN卷积网络或神经网络算法组；\n\t设计开发Android工程化开发测试流程；\n\t\n\n**项目：AR教学之化学分子方程式展示**\n\n**简介：**\n\t\n\t应某大学在科技教育的背景下，提倡使用AR/VR技术进行物理、化学教学。提高教学质量，同时也开拓同学们队新技术新概念的认知\n\t主要展示：\n\t\t1、元素周期表的常见元素的物理属性\n\t\t2、常见较为简单的化学方程式反应过程模拟\n\t\t3、使用AR中包括的图像识别、图像跟踪、模型渲染等技术\n\t\t\n**职责：**\n\n\t1、参考实际的元素、分子式、实物等物理属性设计合理的渲染模型\n\t2、参考实际的化学反应方程式设计合理的化学反应过程。例如：H + O 在燃烧的情况下生成水\n\t3、针对识别图的规范提供提高识别率的建议\n\t4、设计一系列化学反应方程式的反应逻辑过程并实现开发\n\t5、结合同事、客户以及专业老师的使用体验情况；快速迭代版本并发布，提高开发质量，交互体验质量等\n\t6、快速迭代发布android、IOS、PC、MAC等平台安装测试包\n\n**作品展示：**\n\n![](http://i2.51cto.com/images/blog/201805/13/ea45c42043d80fd1bf1d93ef96c9c508.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)\n\n![](http://i2.51cto.com/images/blog/201805/13/d7272069477d7aa4a9399b0e2aa8a13f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)\n\n2017/05--2017.12\n\n**项目：汽车之家AR 组件开发**\n\n**简介：**\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/hiscene_autohome.jpg)\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/autohome2.png)\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/autohome1.png)\n\n\n## 北京萝卜科技有限公司\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/luobotec_logo.jpg)\n\n2015/06--2017/03  (现已搬到深圳办公)\n\n**项目：小萝卜伙伴机器人**\n\n**简介：**\n\t\n\t一个童年 一个机器人陪伴，是送给孩子最好的礼物，小萝卜大功能：情感成长、陪玩耍、记忆成长、陪聊天、陪学习、智慧成长等。\n\n\t陪玩耍：小萝卜伙伴机器人的动作有8个自由度、灵活智能。可以像赛道一样奔跑，可以翩翩起舞，可以跳小苹果。\n\t\n\t陪学习：实现多维度的早教方式，提供进阶式学习内容，满足不同年龄阶段小孩的启蒙教育。\n\t\n\t陪聊天：具备准确的语音识别，强大的语义分析，可以流畅对话。内置英语词典。\n\t\n\t智慧成长：通过云平台，持续更新服务内容\n\t\n\t记忆成长：记录孩子的语言资料，图像资料、视频资料，是童年的记录者\n\t\n\t情感成长：了解孩子的行为习惯，逐渐产生感性反馈习惯\n\n**项目整体结构：**外设硬件+android系统+手机App+后台云服务\n\n**职责：**主要是android端（即机器人端）功能\n\t\n\t1、用户功能：唱歌、跳舞、讲故事、对话等语音交互，涉及语音识别、语义理解、定制语音合成音播放\n\t\n\t2、外设部分：协商通信协议完成眼睛闪烁、手臂、轮子等硬件的运动控制\n\t\n\t3、手机APP部分：App通过蓝牙连接机器人，app发出指令完成跳舞、讲故事、编程等功能。协商制定通信协议\n\t\n\t4、协商制定机器人端每个阶段的开发细则任务，担任机器人端的开发组leader角色\n\t\n\t5、对接第三方技术集成（android系统定制；语音技术提供；语义理解；语音合成；行为统计）\n\t\n\t6、重构抽取业务层快速交付第三方机器人的定制开发（如：浦发银行小浦、海淀安全馆安全大使））\n\t\n\t7、技术面试应聘的Android开发工程师，组建Android开发团队\n\t\n\t8、对外提供技术支持服务，对公司的工厂提供android技术支持促进机器人量产\n小萝卜展出留影\n\t\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/8af2f0c5a8fde293cbc8f82b7a074fa9.jpg)\n\n## 车讯互联\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/chexun_logo.png)\n\n2012/05--2015/06 （清华科技园办公）\n\n**项目：买车通**\n\n**简介：**\n\t\n\t《买车通》助你轻松买到好车；买车通是车讯专为购车用户精心打造的一款看车、比车、询价等功能齐全的移动App\n\t\n\t\t全新的用户体验：界面交互全面升级，买车更迅捷\n\t\n\t\t流畅的UI设计：各种车型图片车内装饰，还有性感动人的车模MM相伴，如此香车美人\n\t\n\t\t价格优惠 一看便知：各大城市4s店的最新车型，车款、价格优惠详情等一目了然\n\t\n\t\t购车计算：内置各大城市的购车计算方式，裸车价、购置税、车船使用税等计算方式和花费项目。\n\t\n\t\t拆车坊：《拆车坊》节目视频播放。\n\t\t\n**职责：**\n\n\t1、刚开始独立开发，后来随着业务扩展；进行技术面试把关组建android技术团队\n\t\n\t2、按产品需求制定app开发计划时间表；拆分需求制定app版本迭代计划\n\t\n\t3、按市场营销活动计划，制定相应的营销功能\n\t\n\t4、统计分析购车客户的使用习惯，迭代交互设计方案\n\t\n\t5、统计分析图片浏览习惯，提供更多客户浏览量高的相关香车图片\n\t\n\t6、统计分析使用app的分布情况，定期给市场以及其他部门提供数据报告，提高了4s广告的精准投放\n\t\n\t7、解析竞争app的技术、使用习惯、UI迭代趋势、内容质量、用户粘性等，提供详尽的竟品报告\n\t\n\t8、常规的性能优化、UI适配、分辨率适配、机型适配、省电策略以及android技术解决方案等\n\n> ### 专业技能\n\t\n\tjava：熟悉java的编程原理，理解OpenGL 熟练使用常见设计模式、熟练使用Android studio\n\t\n\tC#\t:\t熟悉C# 编译原理。会使用Unity3D构建业务模型\n\t\n\tC/C++:了解c、c++编译运行过程。熟悉JNI接口编辑\n\t\n\tPython:了解Python的编程设计，能使用Python构建Tenflow的模型训练\n\t\n\t工具链：Android studio、Unity3D、Jenkins、Junit、Espresso、Gradle、pepline、MyQR、Git等\n\n\n","source":"_posts/android-lichong.md","raw":"---\ntitle: 简历-李冲\ndate: 2017-03-11 20:11:01\ntags: 简历 android\n---\n\n\n> ### 个人信息\n\n**姓 名：李冲**\t\n\n工作年限：7 年\t\t                 \n\n岗位：Android高级工程师\n\n学 历：本科\n\n邮  箱：*lichongmac@163.com*        \n\n专 业：计算机科学与技术\n\n博客地址：*[http://blog.51cto.com/4789781](http://blog.51cto.com/4789781)*  \n\n# 工作经历\n\n## 亮风台信息科技有限公司\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/hiscene_logo.jpg)\n\n2018/02--至今 \n\n**项目：HiARSDK定制化开发**\n\n**简介：** \n\t\n\t主要服务于：\n\t\t\t\t汽车之家\n\t\t\t\t玉泉旅游景区\n\t\t\t\t上汽AR说明书\n\t\t\t\t民生银行研究院\n\t\t\t\t河北师大AR实验室等\n\n\n**关键技术：**\n\n\t图像识别、图像跟踪、slam位姿跟踪等底层算法集成；\n\t\t\t\t\n\tCamera相机方案优化等；\n\n主要职责：\n\n\t按客户AR业务场景需求选择合适的图像方案，设计开发交付符合客户要求（包体大小、性能等）的HiARSDK集成包；\n\t提供Android技术支持2D图像算法组、Slam位姿识别算法组、CNN卷积网络或神经网络算法组；\n\t设计开发Android工程化开发测试流程；\n\t\n\n**项目：AR教学之化学分子方程式展示**\n\n**简介：**\n\t\n\t应某大学在科技教育的背景下，提倡使用AR/VR技术进行物理、化学教学。提高教学质量，同时也开拓同学们队新技术新概念的认知\n\t主要展示：\n\t\t1、元素周期表的常见元素的物理属性\n\t\t2、常见较为简单的化学方程式反应过程模拟\n\t\t3、使用AR中包括的图像识别、图像跟踪、模型渲染等技术\n\t\t\n**职责：**\n\n\t1、参考实际的元素、分子式、实物等物理属性设计合理的渲染模型\n\t2、参考实际的化学反应方程式设计合理的化学反应过程。例如：H + O 在燃烧的情况下生成水\n\t3、针对识别图的规范提供提高识别率的建议\n\t4、设计一系列化学反应方程式的反应逻辑过程并实现开发\n\t5、结合同事、客户以及专业老师的使用体验情况；快速迭代版本并发布，提高开发质量，交互体验质量等\n\t6、快速迭代发布android、IOS、PC、MAC等平台安装测试包\n\n**作品展示：**\n\n![](http://i2.51cto.com/images/blog/201805/13/ea45c42043d80fd1bf1d93ef96c9c508.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)\n\n![](http://i2.51cto.com/images/blog/201805/13/d7272069477d7aa4a9399b0e2aa8a13f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)\n\n2017/05--2017.12\n\n**项目：汽车之家AR 组件开发**\n\n**简介：**\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/hiscene_autohome.jpg)\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/autohome2.png)\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/autohome1.png)\n\n\n## 北京萝卜科技有限公司\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/luobotec_logo.jpg)\n\n2015/06--2017/03  (现已搬到深圳办公)\n\n**项目：小萝卜伙伴机器人**\n\n**简介：**\n\t\n\t一个童年 一个机器人陪伴，是送给孩子最好的礼物，小萝卜大功能：情感成长、陪玩耍、记忆成长、陪聊天、陪学习、智慧成长等。\n\n\t陪玩耍：小萝卜伙伴机器人的动作有8个自由度、灵活智能。可以像赛道一样奔跑，可以翩翩起舞，可以跳小苹果。\n\t\n\t陪学习：实现多维度的早教方式，提供进阶式学习内容，满足不同年龄阶段小孩的启蒙教育。\n\t\n\t陪聊天：具备准确的语音识别，强大的语义分析，可以流畅对话。内置英语词典。\n\t\n\t智慧成长：通过云平台，持续更新服务内容\n\t\n\t记忆成长：记录孩子的语言资料，图像资料、视频资料，是童年的记录者\n\t\n\t情感成长：了解孩子的行为习惯，逐渐产生感性反馈习惯\n\n**项目整体结构：**外设硬件+android系统+手机App+后台云服务\n\n**职责：**主要是android端（即机器人端）功能\n\t\n\t1、用户功能：唱歌、跳舞、讲故事、对话等语音交互，涉及语音识别、语义理解、定制语音合成音播放\n\t\n\t2、外设部分：协商通信协议完成眼睛闪烁、手臂、轮子等硬件的运动控制\n\t\n\t3、手机APP部分：App通过蓝牙连接机器人，app发出指令完成跳舞、讲故事、编程等功能。协商制定通信协议\n\t\n\t4、协商制定机器人端每个阶段的开发细则任务，担任机器人端的开发组leader角色\n\t\n\t5、对接第三方技术集成（android系统定制；语音技术提供；语义理解；语音合成；行为统计）\n\t\n\t6、重构抽取业务层快速交付第三方机器人的定制开发（如：浦发银行小浦、海淀安全馆安全大使））\n\t\n\t7、技术面试应聘的Android开发工程师，组建Android开发团队\n\t\n\t8、对外提供技术支持服务，对公司的工厂提供android技术支持促进机器人量产\n小萝卜展出留影\n\t\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/8af2f0c5a8fde293cbc8f82b7a074fa9.jpg)\n\n## 车讯互联\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/chexun_logo.png)\n\n2012/05--2015/06 （清华科技园办公）\n\n**项目：买车通**\n\n**简介：**\n\t\n\t《买车通》助你轻松买到好车；买车通是车讯专为购车用户精心打造的一款看车、比车、询价等功能齐全的移动App\n\t\n\t\t全新的用户体验：界面交互全面升级，买车更迅捷\n\t\n\t\t流畅的UI设计：各种车型图片车内装饰，还有性感动人的车模MM相伴，如此香车美人\n\t\n\t\t价格优惠 一看便知：各大城市4s店的最新车型，车款、价格优惠详情等一目了然\n\t\n\t\t购车计算：内置各大城市的购车计算方式，裸车价、购置税、车船使用税等计算方式和花费项目。\n\t\n\t\t拆车坊：《拆车坊》节目视频播放。\n\t\t\n**职责：**\n\n\t1、刚开始独立开发，后来随着业务扩展；进行技术面试把关组建android技术团队\n\t\n\t2、按产品需求制定app开发计划时间表；拆分需求制定app版本迭代计划\n\t\n\t3、按市场营销活动计划，制定相应的营销功能\n\t\n\t4、统计分析购车客户的使用习惯，迭代交互设计方案\n\t\n\t5、统计分析图片浏览习惯，提供更多客户浏览量高的相关香车图片\n\t\n\t6、统计分析使用app的分布情况，定期给市场以及其他部门提供数据报告，提高了4s广告的精准投放\n\t\n\t7、解析竞争app的技术、使用习惯、UI迭代趋势、内容质量、用户粘性等，提供详尽的竟品报告\n\t\n\t8、常规的性能优化、UI适配、分辨率适配、机型适配、省电策略以及android技术解决方案等\n\n> ### 专业技能\n\t\n\tjava：熟悉java的编程原理，理解OpenGL 熟练使用常见设计模式、熟练使用Android studio\n\t\n\tC#\t:\t熟悉C# 编译原理。会使用Unity3D构建业务模型\n\t\n\tC/C++:了解c、c++编译运行过程。熟悉JNI接口编辑\n\t\n\tPython:了解Python的编程设计，能使用Python构建Tenflow的模型训练\n\t\n\t工具链：Android studio、Unity3D、Jenkins、Junit、Espresso、Gradle、pepline、MyQR、Git等\n\n\n","slug":"android-lichong","published":1,"updated":"2019-07-15T06:47:26.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416sk6000780s6k1lxd5sx","content":"<blockquote>\n<h3 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h3></blockquote>\n<p><strong>姓 名：李冲</strong>    </p>\n<p>工作年限：7 年                         </p>\n<p>岗位：Android高级工程师</p>\n<p>学 历：本科</p>\n<p>邮  箱：<a href=\"mailto:*lichongmac@163.com\" target=\"_blank\" rel=\"noopener\">*lichongmac@163.com</a>*        </p>\n<p>专 业：计算机科学与技术</p>\n<p>博客地址：<em><a href=\"http://blog.51cto.com/4789781\" target=\"_blank\" rel=\"noopener\">http://blog.51cto.com/4789781</a></em>  </p>\n<h1 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h1><h2 id=\"亮风台信息科技有限公司\"><a href=\"#亮风台信息科技有限公司\" class=\"headerlink\" title=\"亮风台信息科技有限公司\"></a>亮风台信息科技有限公司</h2><p><img src=\"http://omnk3xsvf.bkt.clouddn.com/hiscene_logo.jpg\" alt=\"Alt text\"></p>\n<p>2018/02–至今 </p>\n<p><strong>项目：HiARSDK定制化开发</strong></p>\n<p><strong>简介：</strong> </p>\n<pre><code>主要服务于：\n            汽车之家\n            玉泉旅游景区\n            上汽AR说明书\n            民生银行研究院\n            河北师大AR实验室等\n</code></pre><p><strong>关键技术：</strong></p>\n<pre><code>图像识别、图像跟踪、slam位姿跟踪等底层算法集成；\n\nCamera相机方案优化等；\n</code></pre><p>主要职责：</p>\n<pre><code>按客户AR业务场景需求选择合适的图像方案，设计开发交付符合客户要求（包体大小、性能等）的HiARSDK集成包；\n提供Android技术支持2D图像算法组、Slam位姿识别算法组、CNN卷积网络或神经网络算法组；\n设计开发Android工程化开发测试流程；\n</code></pre><p><strong>项目：AR教学之化学分子方程式展示</strong></p>\n<p><strong>简介：</strong></p>\n<pre><code>应某大学在科技教育的背景下，提倡使用AR/VR技术进行物理、化学教学。提高教学质量，同时也开拓同学们队新技术新概念的认知\n主要展示：\n    1、元素周期表的常见元素的物理属性\n    2、常见较为简单的化学方程式反应过程模拟\n    3、使用AR中包括的图像识别、图像跟踪、模型渲染等技术\n</code></pre><p><strong>职责：</strong></p>\n<pre><code>1、参考实际的元素、分子式、实物等物理属性设计合理的渲染模型\n2、参考实际的化学反应方程式设计合理的化学反应过程。例如：H + O 在燃烧的情况下生成水\n3、针对识别图的规范提供提高识别率的建议\n4、设计一系列化学反应方程式的反应逻辑过程并实现开发\n5、结合同事、客户以及专业老师的使用体验情况；快速迭代版本并发布，提高开发质量，交互体验质量等\n6、快速迭代发布android、IOS、PC、MAC等平台安装测试包\n</code></pre><p><strong>作品展示：</strong></p>\n<p><img src=\"http://i2.51cto.com/images/blog/201805/13/ea45c42043d80fd1bf1d93ef96c9c508.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=\" alt></p>\n<p><img src=\"http://i2.51cto.com/images/blog/201805/13/d7272069477d7aa4a9399b0e2aa8a13f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=\" alt></p>\n<p>2017/05–2017.12</p>\n<p><strong>项目：汽车之家AR 组件开发</strong></p>\n<p><strong>简介：</strong><br><img src=\"http://omnk3xsvf.bkt.clouddn.com/hiscene_autohome.jpg\" alt=\"Alt text\"><br><img src=\"http://omnk3xsvf.bkt.clouddn.com/autohome2.png\" alt=\"Alt text\"><br><img src=\"http://omnk3xsvf.bkt.clouddn.com/autohome1.png\" alt=\"Alt text\"></p>\n<h2 id=\"北京萝卜科技有限公司\"><a href=\"#北京萝卜科技有限公司\" class=\"headerlink\" title=\"北京萝卜科技有限公司\"></a>北京萝卜科技有限公司</h2><p><img src=\"http://omnk3xsvf.bkt.clouddn.com/luobotec_logo.jpg\" alt=\"Alt text\"></p>\n<p>2015/06–2017/03  (现已搬到深圳办公)</p>\n<p><strong>项目：小萝卜伙伴机器人</strong></p>\n<p><strong>简介：</strong></p>\n<pre><code>一个童年 一个机器人陪伴，是送给孩子最好的礼物，小萝卜大功能：情感成长、陪玩耍、记忆成长、陪聊天、陪学习、智慧成长等。\n\n陪玩耍：小萝卜伙伴机器人的动作有8个自由度、灵活智能。可以像赛道一样奔跑，可以翩翩起舞，可以跳小苹果。\n\n陪学习：实现多维度的早教方式，提供进阶式学习内容，满足不同年龄阶段小孩的启蒙教育。\n\n陪聊天：具备准确的语音识别，强大的语义分析，可以流畅对话。内置英语词典。\n\n智慧成长：通过云平台，持续更新服务内容\n\n记忆成长：记录孩子的语言资料，图像资料、视频资料，是童年的记录者\n\n情感成长：了解孩子的行为习惯，逐渐产生感性反馈习惯\n</code></pre><p><strong>项目整体结构：</strong>外设硬件+android系统+手机App+后台云服务</p>\n<p><strong>职责：</strong>主要是android端（即机器人端）功能</p>\n<pre><code>1、用户功能：唱歌、跳舞、讲故事、对话等语音交互，涉及语音识别、语义理解、定制语音合成音播放\n\n2、外设部分：协商通信协议完成眼睛闪烁、手臂、轮子等硬件的运动控制\n\n3、手机APP部分：App通过蓝牙连接机器人，app发出指令完成跳舞、讲故事、编程等功能。协商制定通信协议\n\n4、协商制定机器人端每个阶段的开发细则任务，担任机器人端的开发组leader角色\n\n5、对接第三方技术集成（android系统定制；语音技术提供；语义理解；语音合成；行为统计）\n\n6、重构抽取业务层快速交付第三方机器人的定制开发（如：浦发银行小浦、海淀安全馆安全大使））\n\n7、技术面试应聘的Android开发工程师，组建Android开发团队\n\n8、对外提供技术支持服务，对公司的工厂提供android技术支持促进机器人量产\n</code></pre><p>小萝卜展出留影</p>\n<p><img src=\"http://omnk3xsvf.bkt.clouddn.com/8af2f0c5a8fde293cbc8f82b7a074fa9.jpg\" alt=\"Alt text\"></p>\n<h2 id=\"车讯互联\"><a href=\"#车讯互联\" class=\"headerlink\" title=\"车讯互联\"></a>车讯互联</h2><p><img src=\"http://omnk3xsvf.bkt.clouddn.com/chexun_logo.png\" alt=\"Alt text\"></p>\n<p>2012/05–2015/06 （清华科技园办公）</p>\n<p><strong>项目：买车通</strong></p>\n<p><strong>简介：</strong></p>\n<pre><code>《买车通》助你轻松买到好车；买车通是车讯专为购车用户精心打造的一款看车、比车、询价等功能齐全的移动App\n\n    全新的用户体验：界面交互全面升级，买车更迅捷\n\n    流畅的UI设计：各种车型图片车内装饰，还有性感动人的车模MM相伴，如此香车美人\n\n    价格优惠 一看便知：各大城市4s店的最新车型，车款、价格优惠详情等一目了然\n\n    购车计算：内置各大城市的购车计算方式，裸车价、购置税、车船使用税等计算方式和花费项目。\n\n    拆车坊：《拆车坊》节目视频播放。\n</code></pre><p><strong>职责：</strong></p>\n<pre><code>1、刚开始独立开发，后来随着业务扩展；进行技术面试把关组建android技术团队\n\n2、按产品需求制定app开发计划时间表；拆分需求制定app版本迭代计划\n\n3、按市场营销活动计划，制定相应的营销功能\n\n4、统计分析购车客户的使用习惯，迭代交互设计方案\n\n5、统计分析图片浏览习惯，提供更多客户浏览量高的相关香车图片\n\n6、统计分析使用app的分布情况，定期给市场以及其他部门提供数据报告，提高了4s广告的精准投放\n\n7、解析竞争app的技术、使用习惯、UI迭代趋势、内容质量、用户粘性等，提供详尽的竟品报告\n\n8、常规的性能优化、UI适配、分辨率适配、机型适配、省电策略以及android技术解决方案等\n</code></pre><blockquote>\n<h3 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h3></blockquote>\n<pre><code>java：熟悉java的编程原理，理解OpenGL 熟练使用常见设计模式、熟练使用Android studio\n\nC#    :    熟悉C# 编译原理。会使用Unity3D构建业务模型\n\nC/C++:了解c、c++编译运行过程。熟悉JNI接口编辑\n\nPython:了解Python的编程设计，能使用Python构建Tenflow的模型训练\n\n工具链：Android studio、Unity3D、Jenkins、Junit、Espresso、Gradle、pepline、MyQR、Git等\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<h3 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h3></blockquote>\n<p><strong>姓 名：李冲</strong>    </p>\n<p>工作年限：7 年                         </p>\n<p>岗位：Android高级工程师</p>\n<p>学 历：本科</p>\n<p>邮  箱：<a href=\"mailto:*lichongmac@163.com\" target=\"_blank\" rel=\"noopener\">*lichongmac@163.com</a>*        </p>\n<p>专 业：计算机科学与技术</p>\n<p>博客地址：<em><a href=\"http://blog.51cto.com/4789781\" target=\"_blank\" rel=\"noopener\">http://blog.51cto.com/4789781</a></em>  </p>\n<h1 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h1><h2 id=\"亮风台信息科技有限公司\"><a href=\"#亮风台信息科技有限公司\" class=\"headerlink\" title=\"亮风台信息科技有限公司\"></a>亮风台信息科技有限公司</h2><p><img src=\"http://omnk3xsvf.bkt.clouddn.com/hiscene_logo.jpg\" alt=\"Alt text\"></p>\n<p>2018/02–至今 </p>\n<p><strong>项目：HiARSDK定制化开发</strong></p>\n<p><strong>简介：</strong> </p>\n<pre><code>主要服务于：\n            汽车之家\n            玉泉旅游景区\n            上汽AR说明书\n            民生银行研究院\n            河北师大AR实验室等\n</code></pre><p><strong>关键技术：</strong></p>\n<pre><code>图像识别、图像跟踪、slam位姿跟踪等底层算法集成；\n\nCamera相机方案优化等；\n</code></pre><p>主要职责：</p>\n<pre><code>按客户AR业务场景需求选择合适的图像方案，设计开发交付符合客户要求（包体大小、性能等）的HiARSDK集成包；\n提供Android技术支持2D图像算法组、Slam位姿识别算法组、CNN卷积网络或神经网络算法组；\n设计开发Android工程化开发测试流程；\n</code></pre><p><strong>项目：AR教学之化学分子方程式展示</strong></p>\n<p><strong>简介：</strong></p>\n<pre><code>应某大学在科技教育的背景下，提倡使用AR/VR技术进行物理、化学教学。提高教学质量，同时也开拓同学们队新技术新概念的认知\n主要展示：\n    1、元素周期表的常见元素的物理属性\n    2、常见较为简单的化学方程式反应过程模拟\n    3、使用AR中包括的图像识别、图像跟踪、模型渲染等技术\n</code></pre><p><strong>职责：</strong></p>\n<pre><code>1、参考实际的元素、分子式、实物等物理属性设计合理的渲染模型\n2、参考实际的化学反应方程式设计合理的化学反应过程。例如：H + O 在燃烧的情况下生成水\n3、针对识别图的规范提供提高识别率的建议\n4、设计一系列化学反应方程式的反应逻辑过程并实现开发\n5、结合同事、客户以及专业老师的使用体验情况；快速迭代版本并发布，提高开发质量，交互体验质量等\n6、快速迭代发布android、IOS、PC、MAC等平台安装测试包\n</code></pre><p><strong>作品展示：</strong></p>\n<p><img src=\"http://i2.51cto.com/images/blog/201805/13/ea45c42043d80fd1bf1d93ef96c9c508.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=\" alt></p>\n<p><img src=\"http://i2.51cto.com/images/blog/201805/13/d7272069477d7aa4a9399b0e2aa8a13f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=\" alt></p>\n<p>2017/05–2017.12</p>\n<p><strong>项目：汽车之家AR 组件开发</strong></p>\n<p><strong>简介：</strong><br><img src=\"http://omnk3xsvf.bkt.clouddn.com/hiscene_autohome.jpg\" alt=\"Alt text\"><br><img src=\"http://omnk3xsvf.bkt.clouddn.com/autohome2.png\" alt=\"Alt text\"><br><img src=\"http://omnk3xsvf.bkt.clouddn.com/autohome1.png\" alt=\"Alt text\"></p>\n<h2 id=\"北京萝卜科技有限公司\"><a href=\"#北京萝卜科技有限公司\" class=\"headerlink\" title=\"北京萝卜科技有限公司\"></a>北京萝卜科技有限公司</h2><p><img src=\"http://omnk3xsvf.bkt.clouddn.com/luobotec_logo.jpg\" alt=\"Alt text\"></p>\n<p>2015/06–2017/03  (现已搬到深圳办公)</p>\n<p><strong>项目：小萝卜伙伴机器人</strong></p>\n<p><strong>简介：</strong></p>\n<pre><code>一个童年 一个机器人陪伴，是送给孩子最好的礼物，小萝卜大功能：情感成长、陪玩耍、记忆成长、陪聊天、陪学习、智慧成长等。\n\n陪玩耍：小萝卜伙伴机器人的动作有8个自由度、灵活智能。可以像赛道一样奔跑，可以翩翩起舞，可以跳小苹果。\n\n陪学习：实现多维度的早教方式，提供进阶式学习内容，满足不同年龄阶段小孩的启蒙教育。\n\n陪聊天：具备准确的语音识别，强大的语义分析，可以流畅对话。内置英语词典。\n\n智慧成长：通过云平台，持续更新服务内容\n\n记忆成长：记录孩子的语言资料，图像资料、视频资料，是童年的记录者\n\n情感成长：了解孩子的行为习惯，逐渐产生感性反馈习惯\n</code></pre><p><strong>项目整体结构：</strong>外设硬件+android系统+手机App+后台云服务</p>\n<p><strong>职责：</strong>主要是android端（即机器人端）功能</p>\n<pre><code>1、用户功能：唱歌、跳舞、讲故事、对话等语音交互，涉及语音识别、语义理解、定制语音合成音播放\n\n2、外设部分：协商通信协议完成眼睛闪烁、手臂、轮子等硬件的运动控制\n\n3、手机APP部分：App通过蓝牙连接机器人，app发出指令完成跳舞、讲故事、编程等功能。协商制定通信协议\n\n4、协商制定机器人端每个阶段的开发细则任务，担任机器人端的开发组leader角色\n\n5、对接第三方技术集成（android系统定制；语音技术提供；语义理解；语音合成；行为统计）\n\n6、重构抽取业务层快速交付第三方机器人的定制开发（如：浦发银行小浦、海淀安全馆安全大使））\n\n7、技术面试应聘的Android开发工程师，组建Android开发团队\n\n8、对外提供技术支持服务，对公司的工厂提供android技术支持促进机器人量产\n</code></pre><p>小萝卜展出留影</p>\n<p><img src=\"http://omnk3xsvf.bkt.clouddn.com/8af2f0c5a8fde293cbc8f82b7a074fa9.jpg\" alt=\"Alt text\"></p>\n<h2 id=\"车讯互联\"><a href=\"#车讯互联\" class=\"headerlink\" title=\"车讯互联\"></a>车讯互联</h2><p><img src=\"http://omnk3xsvf.bkt.clouddn.com/chexun_logo.png\" alt=\"Alt text\"></p>\n<p>2012/05–2015/06 （清华科技园办公）</p>\n<p><strong>项目：买车通</strong></p>\n<p><strong>简介：</strong></p>\n<pre><code>《买车通》助你轻松买到好车；买车通是车讯专为购车用户精心打造的一款看车、比车、询价等功能齐全的移动App\n\n    全新的用户体验：界面交互全面升级，买车更迅捷\n\n    流畅的UI设计：各种车型图片车内装饰，还有性感动人的车模MM相伴，如此香车美人\n\n    价格优惠 一看便知：各大城市4s店的最新车型，车款、价格优惠详情等一目了然\n\n    购车计算：内置各大城市的购车计算方式，裸车价、购置税、车船使用税等计算方式和花费项目。\n\n    拆车坊：《拆车坊》节目视频播放。\n</code></pre><p><strong>职责：</strong></p>\n<pre><code>1、刚开始独立开发，后来随着业务扩展；进行技术面试把关组建android技术团队\n\n2、按产品需求制定app开发计划时间表；拆分需求制定app版本迭代计划\n\n3、按市场营销活动计划，制定相应的营销功能\n\n4、统计分析购车客户的使用习惯，迭代交互设计方案\n\n5、统计分析图片浏览习惯，提供更多客户浏览量高的相关香车图片\n\n6、统计分析使用app的分布情况，定期给市场以及其他部门提供数据报告，提高了4s广告的精准投放\n\n7、解析竞争app的技术、使用习惯、UI迭代趋势、内容质量、用户粘性等，提供详尽的竟品报告\n\n8、常规的性能优化、UI适配、分辨率适配、机型适配、省电策略以及android技术解决方案等\n</code></pre><blockquote>\n<h3 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h3></blockquote>\n<pre><code>java：熟悉java的编程原理，理解OpenGL 熟练使用常见设计模式、熟练使用Android studio\n\nC#    :    熟悉C# 编译原理。会使用Unity3D构建业务模型\n\nC/C++:了解c、c++编译运行过程。熟悉JNI接口编辑\n\nPython:了解Python的编程设计，能使用Python构建Tenflow的模型训练\n\n工具链：Android studio、Unity3D、Jenkins、Junit、Espresso、Gradle、pepline、MyQR、Git等\n</code></pre>"},{"title":"《大数据与商业模式变革》","date":"2017-03-03T08:11:01.000Z","_content":"\t\n\n从信息到知识，再到利润\n（法）Bernard Liautaud\n（美）Mark Hammond\n\n  传统行业的发展壮大是沿袭历史的规律，前人的经验来控制企业这个船的航行方向。属于发现、验错、请教导师、再验错、再请教导师、再次吸取前辈们经验。这个过程解决从0到1是比较合理的。但是当企业已经是一艘航空母舰，行业的领跑者或者是行业的标杆。那么发展的行驶方向又该如何决策。\n  \n  本书讲述了大数据、智能、企业商务智能等术语名词。简单易懂的阐明企业、数据、企业电子商务智能的设计理念以及企业电子商务所服务的对象。试着解决大数据投入成本、规模控制、产出的方式以及最后获利的方式的普适性。过程犹如编程（构造解决方案、执行、进行数据验证、再调试、达到目标）。沿着数据的脉络可以发现部分经验的产生结果和预期是一致的，而有些部分则完全相反或者毫无关系。如果这些经验刚好是用来指导企业的决策方向那么就显得格外重要；经验作为方向，数据作为依据，而数据的采集、归纳、报表设计信息的权限设计等则为大数据企业商务智能的由来\n  \n  “客户更换供应商成本可以忽略不计”\n  \n  “增强客户的满意度，增强服务的竞争力，帮助客户节约成本、节约时间”\n\n“企业经营不可预测成为历史”","source":"_posts/book-1.md","raw":"---\ntitle: 《大数据与商业模式变革》\ndate: 2017-03-03 16:11:01\ntags: 大数据 企业电子商务智能 \n---\n\t\n\n从信息到知识，再到利润\n（法）Bernard Liautaud\n（美）Mark Hammond\n\n  传统行业的发展壮大是沿袭历史的规律，前人的经验来控制企业这个船的航行方向。属于发现、验错、请教导师、再验错、再请教导师、再次吸取前辈们经验。这个过程解决从0到1是比较合理的。但是当企业已经是一艘航空母舰，行业的领跑者或者是行业的标杆。那么发展的行驶方向又该如何决策。\n  \n  本书讲述了大数据、智能、企业商务智能等术语名词。简单易懂的阐明企业、数据、企业电子商务智能的设计理念以及企业电子商务所服务的对象。试着解决大数据投入成本、规模控制、产出的方式以及最后获利的方式的普适性。过程犹如编程（构造解决方案、执行、进行数据验证、再调试、达到目标）。沿着数据的脉络可以发现部分经验的产生结果和预期是一致的，而有些部分则完全相反或者毫无关系。如果这些经验刚好是用来指导企业的决策方向那么就显得格外重要；经验作为方向，数据作为依据，而数据的采集、归纳、报表设计信息的权限设计等则为大数据企业商务智能的由来\n  \n  “客户更换供应商成本可以忽略不计”\n  \n  “增强客户的满意度，增强服务的竞争力，帮助客户节约成本、节约时间”\n\n“企业经营不可预测成为历史”","slug":"book-1","published":1,"updated":"2017-11-01T13:36:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416sk7000880s6w0fdd2w5","content":"<p>从信息到知识，再到利润<br>（法）Bernard Liautaud<br>（美）Mark Hammond</p>\n<p>  传统行业的发展壮大是沿袭历史的规律，前人的经验来控制企业这个船的航行方向。属于发现、验错、请教导师、再验错、再请教导师、再次吸取前辈们经验。这个过程解决从0到1是比较合理的。但是当企业已经是一艘航空母舰，行业的领跑者或者是行业的标杆。那么发展的行驶方向又该如何决策。</p>\n<p>  本书讲述了大数据、智能、企业商务智能等术语名词。简单易懂的阐明企业、数据、企业电子商务智能的设计理念以及企业电子商务所服务的对象。试着解决大数据投入成本、规模控制、产出的方式以及最后获利的方式的普适性。过程犹如编程（构造解决方案、执行、进行数据验证、再调试、达到目标）。沿着数据的脉络可以发现部分经验的产生结果和预期是一致的，而有些部分则完全相反或者毫无关系。如果这些经验刚好是用来指导企业的决策方向那么就显得格外重要；经验作为方向，数据作为依据，而数据的采集、归纳、报表设计信息的权限设计等则为大数据企业商务智能的由来</p>\n<p>  “客户更换供应商成本可以忽略不计”</p>\n<p>  “增强客户的满意度，增强服务的竞争力，帮助客户节约成本、节约时间”</p>\n<p>“企业经营不可预测成为历史”</p>\n","site":{"data":{}},"excerpt":"","more":"<p>从信息到知识，再到利润<br>（法）Bernard Liautaud<br>（美）Mark Hammond</p>\n<p>  传统行业的发展壮大是沿袭历史的规律，前人的经验来控制企业这个船的航行方向。属于发现、验错、请教导师、再验错、再请教导师、再次吸取前辈们经验。这个过程解决从0到1是比较合理的。但是当企业已经是一艘航空母舰，行业的领跑者或者是行业的标杆。那么发展的行驶方向又该如何决策。</p>\n<p>  本书讲述了大数据、智能、企业商务智能等术语名词。简单易懂的阐明企业、数据、企业电子商务智能的设计理念以及企业电子商务所服务的对象。试着解决大数据投入成本、规模控制、产出的方式以及最后获利的方式的普适性。过程犹如编程（构造解决方案、执行、进行数据验证、再调试、达到目标）。沿着数据的脉络可以发现部分经验的产生结果和预期是一致的，而有些部分则完全相反或者毫无关系。如果这些经验刚好是用来指导企业的决策方向那么就显得格外重要；经验作为方向，数据作为依据，而数据的采集、归纳、报表设计信息的权限设计等则为大数据企业商务智能的由来</p>\n<p>  “客户更换供应商成本可以忽略不计”</p>\n<p>  “增强客户的满意度，增强服务的竞争力，帮助客户节约成本、节约时间”</p>\n<p>“企业经营不可预测成为历史”</p>\n"},{"title":"《代码整洁之道》","date":"2017-03-16T21:17:03.000Z","_content":"\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/timg.jpeg)\n\n    无规矩不成方圆；书写代码就像写作一样。要有一定的书写方式方法才能写出让人一目了然的好代码。\n    最后升华到犹如艺术的境界\n\n### 第一章\n\n举例说明什么是糟糕的、混乱的代码；什么是整洁的代码；介绍多位大牛对代码的思想；\n\n童子军军规“**让营地比你来时更干净**”\n### 第二章 有意义的命名\n给变量、函数、参数、类、和包等命名。\n\n名副其实；避免误导；做有意义的区分；使用读的出来的名称；使用可搜索的名称；避免使用编码；\n\n匈牙利语标记法；无前缀；\n\n接口和实现IShapFactory-->ShapFactoryImp\n\n避免思维映射“**明确是王道**”，循环计数不要用“l”\n\n类名和对象名应该是名词或名词短语\n\n方法名应当是动词或动词短语；别耍宝；别用双关词；使用解决方案领域名称\n\n添加有意义的语镜；\n\n### 第三章 函数\n短小；只做一件事；\n\n每个函数一个抽象层级\n\nswitch语句（**只出现一次，用于创建多态对象，且隐藏在某个继承关系中，系统其他部分看不到**）\n\n**使用异常替代返回错误码**\n\n**抽离Tty／Catch代码块**\n\n错误处理就是一件事\n\n别重复自己；结构化编程；如何写出这样的函数\n\n### 第四章 注释\n喃喃自语；废话注释；注释掉的代码；\n\n### 第五章 格式\n向报纸学习；概念间垂直方向上的区隔\n\n团队规则；\n### 第六章 对象和数据结构\nThe Law of Demeter 对象隐藏数据，曝露操作\n\n### 第七章 错误处理\n使用异常而非返回码；使用不可控异常；依调用者需要定义异常类；定义常规流程；\n\n**别返回null**；**别传递null**\n\n### 第八章 边界\n**学习性测试**；学习log4j；\n\n### 第九章 单元测试\nTDD三定律；保持测试整洁；测试和代码一样重要；\n\n每个测试一个断言；\n\nF（快速fast）I（独立independ）R（repeatable可重复）S（自足验证Self-Validating）T（Timely及时）\n\n### 第十章 类\n类的组织；类应该短小；为了修改而组织；\n\n### 第十一章 系统\n将系统构造与使用分开；纯Java AOP框架；\n\n### 第十二章 迭进\n运行所有测试；重构；不可重复；尽可能少的类和方法\n\n### 第十三章 并发编程（建立多个demo来理解）\n对象是过程的抽象，线程是调度的抽象\n\n并发防御原则；了解执行模型；\n\n### 第十五章 JUnit内幕\n\n### 第十七章 味道与启发\n注释；环境；函数；重复；晦涩的意图；\n\n用多态替代If/else或者switch／case；避免否定性条件；\n\n避免传递浏览； ","source":"_posts/book-2-clean-code.md","raw":"---\ntitle: 《代码整洁之道》\ndate: 2017-03-17 05:17:03\ntags: 代码规范 cleancode 编程风格 重构\n---\n\n![Alt text](http://omnk3xsvf.bkt.clouddn.com/timg.jpeg)\n\n    无规矩不成方圆；书写代码就像写作一样。要有一定的书写方式方法才能写出让人一目了然的好代码。\n    最后升华到犹如艺术的境界\n\n### 第一章\n\n举例说明什么是糟糕的、混乱的代码；什么是整洁的代码；介绍多位大牛对代码的思想；\n\n童子军军规“**让营地比你来时更干净**”\n### 第二章 有意义的命名\n给变量、函数、参数、类、和包等命名。\n\n名副其实；避免误导；做有意义的区分；使用读的出来的名称；使用可搜索的名称；避免使用编码；\n\n匈牙利语标记法；无前缀；\n\n接口和实现IShapFactory-->ShapFactoryImp\n\n避免思维映射“**明确是王道**”，循环计数不要用“l”\n\n类名和对象名应该是名词或名词短语\n\n方法名应当是动词或动词短语；别耍宝；别用双关词；使用解决方案领域名称\n\n添加有意义的语镜；\n\n### 第三章 函数\n短小；只做一件事；\n\n每个函数一个抽象层级\n\nswitch语句（**只出现一次，用于创建多态对象，且隐藏在某个继承关系中，系统其他部分看不到**）\n\n**使用异常替代返回错误码**\n\n**抽离Tty／Catch代码块**\n\n错误处理就是一件事\n\n别重复自己；结构化编程；如何写出这样的函数\n\n### 第四章 注释\n喃喃自语；废话注释；注释掉的代码；\n\n### 第五章 格式\n向报纸学习；概念间垂直方向上的区隔\n\n团队规则；\n### 第六章 对象和数据结构\nThe Law of Demeter 对象隐藏数据，曝露操作\n\n### 第七章 错误处理\n使用异常而非返回码；使用不可控异常；依调用者需要定义异常类；定义常规流程；\n\n**别返回null**；**别传递null**\n\n### 第八章 边界\n**学习性测试**；学习log4j；\n\n### 第九章 单元测试\nTDD三定律；保持测试整洁；测试和代码一样重要；\n\n每个测试一个断言；\n\nF（快速fast）I（独立independ）R（repeatable可重复）S（自足验证Self-Validating）T（Timely及时）\n\n### 第十章 类\n类的组织；类应该短小；为了修改而组织；\n\n### 第十一章 系统\n将系统构造与使用分开；纯Java AOP框架；\n\n### 第十二章 迭进\n运行所有测试；重构；不可重复；尽可能少的类和方法\n\n### 第十三章 并发编程（建立多个demo来理解）\n对象是过程的抽象，线程是调度的抽象\n\n并发防御原则；了解执行模型；\n\n### 第十五章 JUnit内幕\n\n### 第十七章 味道与启发\n注释；环境；函数；重复；晦涩的意图；\n\n用多态替代If/else或者switch／case；避免否定性条件；\n\n避免传递浏览； ","slug":"book-2-clean-code","published":1,"updated":"2017-11-01T13:36:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416sk8000b80s6ghn1ttfn","content":"<p><img src=\"http://omnk3xsvf.bkt.clouddn.com/timg.jpeg\" alt=\"Alt text\"></p>\n<pre><code>无规矩不成方圆；书写代码就像写作一样。要有一定的书写方式方法才能写出让人一目了然的好代码。\n最后升华到犹如艺术的境界\n</code></pre><h3 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h3><p>举例说明什么是糟糕的、混乱的代码；什么是整洁的代码；介绍多位大牛对代码的思想；</p>\n<p>童子军军规“<strong>让营地比你来时更干净</strong>”</p>\n<h3 id=\"第二章-有意义的命名\"><a href=\"#第二章-有意义的命名\" class=\"headerlink\" title=\"第二章 有意义的命名\"></a>第二章 有意义的命名</h3><p>给变量、函数、参数、类、和包等命名。</p>\n<p>名副其实；避免误导；做有意义的区分；使用读的出来的名称；使用可搜索的名称；避免使用编码；</p>\n<p>匈牙利语标记法；无前缀；</p>\n<p>接口和实现IShapFactory–&gt;ShapFactoryImp</p>\n<p>避免思维映射“<strong>明确是王道</strong>”，循环计数不要用“l”</p>\n<p>类名和对象名应该是名词或名词短语</p>\n<p>方法名应当是动词或动词短语；别耍宝；别用双关词；使用解决方案领域名称</p>\n<p>添加有意义的语镜；</p>\n<h3 id=\"第三章-函数\"><a href=\"#第三章-函数\" class=\"headerlink\" title=\"第三章 函数\"></a>第三章 函数</h3><p>短小；只做一件事；</p>\n<p>每个函数一个抽象层级</p>\n<p>switch语句（<strong>只出现一次，用于创建多态对象，且隐藏在某个继承关系中，系统其他部分看不到</strong>）</p>\n<p><strong>使用异常替代返回错误码</strong></p>\n<p><strong>抽离Tty／Catch代码块</strong></p>\n<p>错误处理就是一件事</p>\n<p>别重复自己；结构化编程；如何写出这样的函数</p>\n<h3 id=\"第四章-注释\"><a href=\"#第四章-注释\" class=\"headerlink\" title=\"第四章 注释\"></a>第四章 注释</h3><p>喃喃自语；废话注释；注释掉的代码；</p>\n<h3 id=\"第五章-格式\"><a href=\"#第五章-格式\" class=\"headerlink\" title=\"第五章 格式\"></a>第五章 格式</h3><p>向报纸学习；概念间垂直方向上的区隔</p>\n<p>团队规则；</p>\n<h3 id=\"第六章-对象和数据结构\"><a href=\"#第六章-对象和数据结构\" class=\"headerlink\" title=\"第六章 对象和数据结构\"></a>第六章 对象和数据结构</h3><p>The Law of Demeter 对象隐藏数据，曝露操作</p>\n<h3 id=\"第七章-错误处理\"><a href=\"#第七章-错误处理\" class=\"headerlink\" title=\"第七章 错误处理\"></a>第七章 错误处理</h3><p>使用异常而非返回码；使用不可控异常；依调用者需要定义异常类；定义常规流程；</p>\n<p><strong>别返回null</strong>；<strong>别传递null</strong></p>\n<h3 id=\"第八章-边界\"><a href=\"#第八章-边界\" class=\"headerlink\" title=\"第八章 边界\"></a>第八章 边界</h3><p><strong>学习性测试</strong>；学习log4j；</p>\n<h3 id=\"第九章-单元测试\"><a href=\"#第九章-单元测试\" class=\"headerlink\" title=\"第九章 单元测试\"></a>第九章 单元测试</h3><p>TDD三定律；保持测试整洁；测试和代码一样重要；</p>\n<p>每个测试一个断言；</p>\n<p>F（快速fast）I（独立independ）R（repeatable可重复）S（自足验证Self-Validating）T（Timely及时）</p>\n<h3 id=\"第十章-类\"><a href=\"#第十章-类\" class=\"headerlink\" title=\"第十章 类\"></a>第十章 类</h3><p>类的组织；类应该短小；为了修改而组织；</p>\n<h3 id=\"第十一章-系统\"><a href=\"#第十一章-系统\" class=\"headerlink\" title=\"第十一章 系统\"></a>第十一章 系统</h3><p>将系统构造与使用分开；纯Java AOP框架；</p>\n<h3 id=\"第十二章-迭进\"><a href=\"#第十二章-迭进\" class=\"headerlink\" title=\"第十二章 迭进\"></a>第十二章 迭进</h3><p>运行所有测试；重构；不可重复；尽可能少的类和方法</p>\n<h3 id=\"第十三章-并发编程（建立多个demo来理解）\"><a href=\"#第十三章-并发编程（建立多个demo来理解）\" class=\"headerlink\" title=\"第十三章 并发编程（建立多个demo来理解）\"></a>第十三章 并发编程（建立多个demo来理解）</h3><p>对象是过程的抽象，线程是调度的抽象</p>\n<p>并发防御原则；了解执行模型；</p>\n<h3 id=\"第十五章-JUnit内幕\"><a href=\"#第十五章-JUnit内幕\" class=\"headerlink\" title=\"第十五章 JUnit内幕\"></a>第十五章 JUnit内幕</h3><h3 id=\"第十七章-味道与启发\"><a href=\"#第十七章-味道与启发\" class=\"headerlink\" title=\"第十七章 味道与启发\"></a>第十七章 味道与启发</h3><p>注释；环境；函数；重复；晦涩的意图；</p>\n<p>用多态替代If/else或者switch／case；避免否定性条件；</p>\n<p>避免传递浏览； </p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://omnk3xsvf.bkt.clouddn.com/timg.jpeg\" alt=\"Alt text\"></p>\n<pre><code>无规矩不成方圆；书写代码就像写作一样。要有一定的书写方式方法才能写出让人一目了然的好代码。\n最后升华到犹如艺术的境界\n</code></pre><h3 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h3><p>举例说明什么是糟糕的、混乱的代码；什么是整洁的代码；介绍多位大牛对代码的思想；</p>\n<p>童子军军规“<strong>让营地比你来时更干净</strong>”</p>\n<h3 id=\"第二章-有意义的命名\"><a href=\"#第二章-有意义的命名\" class=\"headerlink\" title=\"第二章 有意义的命名\"></a>第二章 有意义的命名</h3><p>给变量、函数、参数、类、和包等命名。</p>\n<p>名副其实；避免误导；做有意义的区分；使用读的出来的名称；使用可搜索的名称；避免使用编码；</p>\n<p>匈牙利语标记法；无前缀；</p>\n<p>接口和实现IShapFactory–&gt;ShapFactoryImp</p>\n<p>避免思维映射“<strong>明确是王道</strong>”，循环计数不要用“l”</p>\n<p>类名和对象名应该是名词或名词短语</p>\n<p>方法名应当是动词或动词短语；别耍宝；别用双关词；使用解决方案领域名称</p>\n<p>添加有意义的语镜；</p>\n<h3 id=\"第三章-函数\"><a href=\"#第三章-函数\" class=\"headerlink\" title=\"第三章 函数\"></a>第三章 函数</h3><p>短小；只做一件事；</p>\n<p>每个函数一个抽象层级</p>\n<p>switch语句（<strong>只出现一次，用于创建多态对象，且隐藏在某个继承关系中，系统其他部分看不到</strong>）</p>\n<p><strong>使用异常替代返回错误码</strong></p>\n<p><strong>抽离Tty／Catch代码块</strong></p>\n<p>错误处理就是一件事</p>\n<p>别重复自己；结构化编程；如何写出这样的函数</p>\n<h3 id=\"第四章-注释\"><a href=\"#第四章-注释\" class=\"headerlink\" title=\"第四章 注释\"></a>第四章 注释</h3><p>喃喃自语；废话注释；注释掉的代码；</p>\n<h3 id=\"第五章-格式\"><a href=\"#第五章-格式\" class=\"headerlink\" title=\"第五章 格式\"></a>第五章 格式</h3><p>向报纸学习；概念间垂直方向上的区隔</p>\n<p>团队规则；</p>\n<h3 id=\"第六章-对象和数据结构\"><a href=\"#第六章-对象和数据结构\" class=\"headerlink\" title=\"第六章 对象和数据结构\"></a>第六章 对象和数据结构</h3><p>The Law of Demeter 对象隐藏数据，曝露操作</p>\n<h3 id=\"第七章-错误处理\"><a href=\"#第七章-错误处理\" class=\"headerlink\" title=\"第七章 错误处理\"></a>第七章 错误处理</h3><p>使用异常而非返回码；使用不可控异常；依调用者需要定义异常类；定义常规流程；</p>\n<p><strong>别返回null</strong>；<strong>别传递null</strong></p>\n<h3 id=\"第八章-边界\"><a href=\"#第八章-边界\" class=\"headerlink\" title=\"第八章 边界\"></a>第八章 边界</h3><p><strong>学习性测试</strong>；学习log4j；</p>\n<h3 id=\"第九章-单元测试\"><a href=\"#第九章-单元测试\" class=\"headerlink\" title=\"第九章 单元测试\"></a>第九章 单元测试</h3><p>TDD三定律；保持测试整洁；测试和代码一样重要；</p>\n<p>每个测试一个断言；</p>\n<p>F（快速fast）I（独立independ）R（repeatable可重复）S（自足验证Self-Validating）T（Timely及时）</p>\n<h3 id=\"第十章-类\"><a href=\"#第十章-类\" class=\"headerlink\" title=\"第十章 类\"></a>第十章 类</h3><p>类的组织；类应该短小；为了修改而组织；</p>\n<h3 id=\"第十一章-系统\"><a href=\"#第十一章-系统\" class=\"headerlink\" title=\"第十一章 系统\"></a>第十一章 系统</h3><p>将系统构造与使用分开；纯Java AOP框架；</p>\n<h3 id=\"第十二章-迭进\"><a href=\"#第十二章-迭进\" class=\"headerlink\" title=\"第十二章 迭进\"></a>第十二章 迭进</h3><p>运行所有测试；重构；不可重复；尽可能少的类和方法</p>\n<h3 id=\"第十三章-并发编程（建立多个demo来理解）\"><a href=\"#第十三章-并发编程（建立多个demo来理解）\" class=\"headerlink\" title=\"第十三章 并发编程（建立多个demo来理解）\"></a>第十三章 并发编程（建立多个demo来理解）</h3><p>对象是过程的抽象，线程是调度的抽象</p>\n<p>并发防御原则；了解执行模型；</p>\n<h3 id=\"第十五章-JUnit内幕\"><a href=\"#第十五章-JUnit内幕\" class=\"headerlink\" title=\"第十五章 JUnit内幕\"></a>第十五章 JUnit内幕</h3><h3 id=\"第十七章-味道与启发\"><a href=\"#第十七章-味道与启发\" class=\"headerlink\" title=\"第十七章 味道与启发\"></a>第十七章 味道与启发</h3><p>注释；环境；函数；重复；晦涩的意图；</p>\n<p>用多态替代If/else或者switch／case；避免否定性条件；</p>\n<p>避免传递浏览； </p>\n"},{"title":"hexo异常记录","date":"2017-03-03T08:32:48.000Z","_content":"\n## 1、generateError 生成静态页面异常\n\n\tlc git:(master) ✗ hexo generate\n\tINFO  Start processing\n\tERROR Process failed: _posts/book-1.md\n\tError\n\t    at generateError (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:162:10)\n\t    at throwError (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:168:9)\n\t    at readBlockMapping (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1045:9)\n\t    at composeNode (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1331:12)\n\t    at readDocument (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1493:3)\n\t    at loadDocuments (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1549:5)\n\t    at Object.load (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1566:19)\n\t    at parseYAML (/Users/smart/hexo/lc/node_modules/hexo-front-matter/lib/front_matter.js:80:21)\n\t    at parse (/Users/smart/hexo/lc/node_modules/hexo-front-matter/lib/front_matter.js:56:12)\n\t    at /Users/smart/hexo/lc/node_modules/hexo/lib/plugins/processor/post.js:52:18\n\t    at tryCatcher (/Users/smart/hexo/lc/node_modules/bluebird/js/release/util.js:16:23)\n\t    at Promise._settlePromiseFromHandler (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:507:35)\n\t    at Promise._settlePromise (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:567:18)\n\t    at Promise._settlePromise0 (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:612:10)\n\t    at Promise._settlePromises (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:691:18)\n\t    at Promise._fulfill (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:636:18)\n\t    at PromiseArray._resolve (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:125:19)\n\t    at PromiseArray._promiseFulfilled (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:143:14)\n\t    at PromiseArray._iterate (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:113:31)\n\t    at PromiseArray.init [as _init] (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:77:10)\n\t    at Promise._settlePromise (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:564:21)\n\t    at Promise._settlePromise0 (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:612:10)\n\tINFO  Files loaded in 252 ms\n\t\n异常原因：在文章tag：冒号后面少了一个空格\n解决：加一个空格即修复异常\n\n\n## 2、hexo cannot get tags\n参考：https://www.zhihu.com/question/29017171\n\t\n\t1.\thexo new page \"tags\"\n\t2. 如果有评论：\n\t\ttype: \"tags\"\n\t\tcomments: false\n\t\n\n\t \n\t \n\t ","source":"_posts/debug-history.md","raw":"---\ntitle: hexo异常记录\ndate: 2017-03-03 16:32:48\ntags: hexo debug 异常 解决办法\n---\n\n## 1、generateError 生成静态页面异常\n\n\tlc git:(master) ✗ hexo generate\n\tINFO  Start processing\n\tERROR Process failed: _posts/book-1.md\n\tError\n\t    at generateError (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:162:10)\n\t    at throwError (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:168:9)\n\t    at readBlockMapping (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1045:9)\n\t    at composeNode (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1331:12)\n\t    at readDocument (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1493:3)\n\t    at loadDocuments (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1549:5)\n\t    at Object.load (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1566:19)\n\t    at parseYAML (/Users/smart/hexo/lc/node_modules/hexo-front-matter/lib/front_matter.js:80:21)\n\t    at parse (/Users/smart/hexo/lc/node_modules/hexo-front-matter/lib/front_matter.js:56:12)\n\t    at /Users/smart/hexo/lc/node_modules/hexo/lib/plugins/processor/post.js:52:18\n\t    at tryCatcher (/Users/smart/hexo/lc/node_modules/bluebird/js/release/util.js:16:23)\n\t    at Promise._settlePromiseFromHandler (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:507:35)\n\t    at Promise._settlePromise (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:567:18)\n\t    at Promise._settlePromise0 (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:612:10)\n\t    at Promise._settlePromises (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:691:18)\n\t    at Promise._fulfill (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:636:18)\n\t    at PromiseArray._resolve (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:125:19)\n\t    at PromiseArray._promiseFulfilled (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:143:14)\n\t    at PromiseArray._iterate (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:113:31)\n\t    at PromiseArray.init [as _init] (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:77:10)\n\t    at Promise._settlePromise (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:564:21)\n\t    at Promise._settlePromise0 (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:612:10)\n\tINFO  Files loaded in 252 ms\n\t\n异常原因：在文章tag：冒号后面少了一个空格\n解决：加一个空格即修复异常\n\n\n## 2、hexo cannot get tags\n参考：https://www.zhihu.com/question/29017171\n\t\n\t1.\thexo new page \"tags\"\n\t2. 如果有评论：\n\t\ttype: \"tags\"\n\t\tcomments: false\n\t\n\n\t \n\t \n\t ","slug":"debug-history","published":1,"updated":"2017-11-01T13:36:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416sk9000c80s63xxqz621","content":"<h2 id=\"1、generateError-生成静态页面异常\"><a href=\"#1、generateError-生成静态页面异常\" class=\"headerlink\" title=\"1、generateError 生成静态页面异常\"></a>1、generateError 生成静态页面异常</h2><pre><code>lc git:(master) ✗ hexo generate\nINFO  Start processing\nERROR Process failed: _posts/book-1.md\nError\n    at generateError (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:162:10)\n    at throwError (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:168:9)\n    at readBlockMapping (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1045:9)\n    at composeNode (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1331:12)\n    at readDocument (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1493:3)\n    at loadDocuments (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1549:5)\n    at Object.load (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1566:19)\n    at parseYAML (/Users/smart/hexo/lc/node_modules/hexo-front-matter/lib/front_matter.js:80:21)\n    at parse (/Users/smart/hexo/lc/node_modules/hexo-front-matter/lib/front_matter.js:56:12)\n    at /Users/smart/hexo/lc/node_modules/hexo/lib/plugins/processor/post.js:52:18\n    at tryCatcher (/Users/smart/hexo/lc/node_modules/bluebird/js/release/util.js:16:23)\n    at Promise._settlePromiseFromHandler (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:507:35)\n    at Promise._settlePromise (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:567:18)\n    at Promise._settlePromise0 (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:612:10)\n    at Promise._settlePromises (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:691:18)\n    at Promise._fulfill (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:636:18)\n    at PromiseArray._resolve (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:125:19)\n    at PromiseArray._promiseFulfilled (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:143:14)\n    at PromiseArray._iterate (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:113:31)\n    at PromiseArray.init [as _init] (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:77:10)\n    at Promise._settlePromise (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:564:21)\n    at Promise._settlePromise0 (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:612:10)\nINFO  Files loaded in 252 ms\n</code></pre><p>异常原因：在文章tag：冒号后面少了一个空格<br>解决：加一个空格即修复异常</p>\n<h2 id=\"2、hexo-cannot-get-tags\"><a href=\"#2、hexo-cannot-get-tags\" class=\"headerlink\" title=\"2、hexo cannot get tags\"></a>2、hexo cannot get tags</h2><p>参考：<a href=\"https://www.zhihu.com/question/29017171\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/29017171</a></p>\n<pre><code>1.    hexo new page &quot;tags&quot;\n2. 如果有评论：\n    type: &quot;tags&quot;\n    comments: false\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、generateError-生成静态页面异常\"><a href=\"#1、generateError-生成静态页面异常\" class=\"headerlink\" title=\"1、generateError 生成静态页面异常\"></a>1、generateError 生成静态页面异常</h2><pre><code>lc git:(master) ✗ hexo generate\nINFO  Start processing\nERROR Process failed: _posts/book-1.md\nError\n    at generateError (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:162:10)\n    at throwError (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:168:9)\n    at readBlockMapping (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1045:9)\n    at composeNode (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1331:12)\n    at readDocument (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1493:3)\n    at loadDocuments (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1549:5)\n    at Object.load (/Users/smart/hexo/lc/node_modules/js-yaml/lib/js-yaml/loader.js:1566:19)\n    at parseYAML (/Users/smart/hexo/lc/node_modules/hexo-front-matter/lib/front_matter.js:80:21)\n    at parse (/Users/smart/hexo/lc/node_modules/hexo-front-matter/lib/front_matter.js:56:12)\n    at /Users/smart/hexo/lc/node_modules/hexo/lib/plugins/processor/post.js:52:18\n    at tryCatcher (/Users/smart/hexo/lc/node_modules/bluebird/js/release/util.js:16:23)\n    at Promise._settlePromiseFromHandler (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:507:35)\n    at Promise._settlePromise (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:567:18)\n    at Promise._settlePromise0 (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:612:10)\n    at Promise._settlePromises (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:691:18)\n    at Promise._fulfill (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:636:18)\n    at PromiseArray._resolve (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:125:19)\n    at PromiseArray._promiseFulfilled (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:143:14)\n    at PromiseArray._iterate (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:113:31)\n    at PromiseArray.init [as _init] (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise_array.js:77:10)\n    at Promise._settlePromise (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:564:21)\n    at Promise._settlePromise0 (/Users/smart/hexo/lc/node_modules/bluebird/js/release/promise.js:612:10)\nINFO  Files loaded in 252 ms\n</code></pre><p>异常原因：在文章tag：冒号后面少了一个空格<br>解决：加一个空格即修复异常</p>\n<h2 id=\"2、hexo-cannot-get-tags\"><a href=\"#2、hexo-cannot-get-tags\" class=\"headerlink\" title=\"2、hexo cannot get tags\"></a>2、hexo cannot get tags</h2><p>参考：<a href=\"https://www.zhihu.com/question/29017171\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/29017171</a></p>\n<pre><code>1.    hexo new page &quot;tags&quot;\n2. 如果有评论：\n    type: &quot;tags&quot;\n    comments: false\n</code></pre>"},{"title":"Android Studio使用异常记录","date":"2017-03-05T02:51:52.000Z","_content":"## 1、Android Studio Build Error : This version of Android Studio is incompatible with the Gradle Plugin used. Try disabling Instant Run\n异常原因：android studio升级后不能编译通过并报此异常\n\n解决办法：先clean project 如何rebuild project 即可解决。","source":"_posts/debug-androidstudio.md","raw":"---\ntitle: Android Studio使用异常记录\ndate: 2017-03-05 10:51:52\ntags: android studio 异常 升级 gradle\n---\n## 1、Android Studio Build Error : This version of Android Studio is incompatible with the Gradle Plugin used. Try disabling Instant Run\n异常原因：android studio升级后不能编译通过并报此异常\n\n解决办法：先clean project 如何rebuild project 即可解决。","slug":"debug-androidstudio","published":1,"updated":"2017-11-01T13:36:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416ska000e80s6x6lqbink","content":"<h2 id=\"1、Android-Studio-Build-Error-This-version-of-Android-Studio-is-incompatible-with-the-Gradle-Plugin-used-Try-disabling-Instant-Run\"><a href=\"#1、Android-Studio-Build-Error-This-version-of-Android-Studio-is-incompatible-with-the-Gradle-Plugin-used-Try-disabling-Instant-Run\" class=\"headerlink\" title=\"1、Android Studio Build Error : This version of Android Studio is incompatible with the Gradle Plugin used. Try disabling Instant Run\"></a>1、Android Studio Build Error : This version of Android Studio is incompatible with the Gradle Plugin used. Try disabling Instant Run</h2><p>异常原因：android studio升级后不能编译通过并报此异常</p>\n<p>解决办法：先clean project 如何rebuild project 即可解决。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、Android-Studio-Build-Error-This-version-of-Android-Studio-is-incompatible-with-the-Gradle-Plugin-used-Try-disabling-Instant-Run\"><a href=\"#1、Android-Studio-Build-Error-This-version-of-Android-Studio-is-incompatible-with-the-Gradle-Plugin-used-Try-disabling-Instant-Run\" class=\"headerlink\" title=\"1、Android Studio Build Error : This version of Android Studio is incompatible with the Gradle Plugin used. Try disabling Instant Run\"></a>1、Android Studio Build Error : This version of Android Studio is incompatible with the Gradle Plugin used. Try disabling Instant Run</h2><p>异常原因：android studio升级后不能编译通过并报此异常</p>\n<p>解决办法：先clean project 如何rebuild project 即可解决。</p>\n"},{"title":"【设计模式】Java状态模式（1）","date":"2017-05-20T13:41:22.000Z","_content":"State的定义：不同的状态，不同的行为；或者说，每个状态有着相应的行为\n## 何时使用状态模式\nState模式在实际使用中比较多，适合\"状态的切换\"。因为我们经常会使用If elseif else 进行状态切换， 如果针对状态的这样判断切换反复出现，我们就要联想到是否可以采取State模式了。\n\n不只是根据状态，也有根据属性。如果某个对象的属性不同，对象的行为就不一样，这点在数据库系统中出现频率比较高，我们经常会在一个数据表的尾部，加上property属性含义的字段，用以标识记录中一些特殊性质的记录，这种属性的改变(切换)又是随时可能发生的，就有可能要使用State。\n\n在实际使用，类似开关一样的状态切换是很多的，但有时并不是那么明显，取决于你的经验和对系统的理解深度。\n\n这里要阐述的是\"开关切换状态\" 和\" 一般的状态判断\"是有一些区别的，\" 一般的状态判断\"也是有 if..elseif结构，例如：\n\n\tif (which==1) state=\"hello\";\n\telse if (which==2) state=\"hi\";\n\telse if (which==3) state=\"bye\";\n这是一个 \" 一般的状态判断\"，state值的不同是根据which变量来决定的，which和state没有关系。如果改成：\n\n\t\tif (state.euqals(\"bye\")) state=\"hello\";\n\t　else if (state.euqals(\"hello\")) state=\"hi\";\n\t　else if (state.euqals(\"hi\")) state=\"bye\";\n这就是 \"开关切换状态\"，是将state的状态从\"hello\"切换到\"hi\"，再切换到\"\"bye\"；在切换到\"hello\"，好象一个旋转开关，这种状态改变就可以使用State模式了。\n\n\n如果单纯有上面一种将\"hello\"-->\"hi\"-->\"bye\"-->\"hello\"这一个方向切换，也不一定需要使用State模式，因为State模式会建立很多子类，复杂化，但是如果又发生另外一个行为：将上面的切换方向反过来切换，或者需要任意切换，就需要State了。\n\n请看下例：\n\t\n\tpublic class Context{\n\t　　private Color state=null;\n\t　　public void push(){\n\t　　　　//如果当前red状态 就切换到blue\n\t　　　　if (state==Color.red) state=Color.blue;\n\t　　　　//如果当前blue状态 就切换到green\n\t　　　　else if (state==Color.blue) state=Color.green;\n\t　　　　//如果当前black状态 就切换到red\n\t　　　　else if (state==Color.black) state=Color.red;\n\t　　　　//如果当前green状态 就切换到black\n\t　　　　else if (state==Color.green) state=Color.black;\n\t　　　　Sample sample=new Sample(state);\n\t　　　　sample.operate();\n\t　　}\n\t　　public void pull(){\n\t　　　　//与push状态切换正好相反\n\t　　　　if (state==Color.green) state=Color.blue;\n\t　　　　else if (state==Color.black) state=Color.green;\n\t　　　　else if (state==Color.blue) state=Color.red;\n\t　　　　else if (state==Color.red) state=Color.black;\n\t　　　　Sample2 sample2=new Sample2(state);\n\t　　　　sample2.operate();\n\t　　}\n\t}\n在上例中，我们有两个动作push推和pull拉，这两个开关动作，改变了Context颜色，至此，我们就需要使用State模式优化它。\n\n\n另外注意：但就上例,state的变化，只是简单的颜色赋值，这个具体行为是很简单的，State适合巨大的具体行为，因此在,就本例，实际使用中也不一定非要使用State模式，这会增加子类的数目，简单的变复杂。\n\n例如：银行帐户，经常会在Open 状态和Close状态间转换。\n\n例如：经典的TcpConnection，Tcp的状态有创建 侦听 关闭三个，并且反复转换，其创建 侦听 关闭的具体行为不是简单一两句就能完成的，适合使用State。\n\n例如：信箱POP帐号，会有四种状态，start HaveUsername Authorized quit，每个状态对应的行为应该是比较大的，适合使用State。\n\n例如：在工具箱挑选不同工具，可以看成在不同工具中切换，适合使用State。如 具体绘图程序，用户可以选择不同工具绘制方框 直线 曲线，这种状态切换可以使用State。\n## 如何使用状态模式\nState需要两种类型实体参与：\nstate manager 状态管理器，就是开关，如上面例子的Context实际就是一个state manager，在state manager中有对状态的切换动作。\n用抽象类或接口实现的父类，不同状态就是继承这个父类的不同子类。\n以上面的Context为例，我们要修改它，建立两个类型的实体。\n\n第一步，首先建立一个父类：\n\t\t\n\tpackage top.lc951.state1;\n\t\n\tpublic abstract class  State {\n\t\tpublic abstract void handlepush(Context c);\n\t\tpublic abstract  void handlepull(Context c);\n\t\tpublic abstract String getColor();\n\t\n\t}\n\n\t\n父类中的方法要对应state manager中的开关行为，在state manager中 本例就是Context中，有两个开关动作push推和pull拉.那么在状态父类中就要有具体处理这两个动作：handlepush() handlepull()；同时还需要一个获取push或pull结果的方法getcolor()。\n\n\n下面是具体子类的实现：\n\t\n\tpackage top.lc951.state1;\n\n\tpublic class BlueState extends State {\n\n\t\n\t@Override\n\tpublic void handlepush(Context c) {\n\t\t// TODO Auto-generated method stub\n\t\tc.setState(new GreenState());\n\n\t}\n\n\t@Override\n\tpublic void handlepull(Context c) {\n\t\t// TODO Auto-generated method stub\n\t\tc.setState(new RedState());\n\n\t}\n\n\t@Override\n\tpublic String getColor() {\n\t\t// TODO Auto-generated method stub\n\t\treturn \"blue\";\n\n\t}\n\n}\n\n\t\n\n同样，其他状态的子类实现如blue一样。\n\n\n第二步，要重新改写State manager 也就是本例的Context\n\t\n\tpublic class Context{\n\t　private Sate state=null; //我们将原来的 Color state 改成了新建的State state;\n\t　//setState是用来改变state的状态 使用setState实现状态的切换\n\t　pulic void setState(State state){\n\t　　　　this.state=state;\n\t　}\n\t　public void push(){\n\t　　//状态的切换的细节部分,在本例中是颜色的变化,已经封装在子类的handlepush中实现,这里无需关心\n\t　　state.handlepush(this);\n\t　　//因为sample要使用state中的一个切换结果,使用getColor()\n\t　　Sample sample=new Sample(state.getColor());\n\t　　sample.operate();\n\t　}\n\t　public void pull(){\n\t　　state.handlepull(this);\n\t　　Sample2 sample2=new Sample2(state.getColor());\n\t　　sample2.operate();\n\t　}\n\t}\n\t\n至此，我们也就实现了State的refactorying过程。\n### 源码地址<https://github.com/lichong951/designpattern-lichong951.git>\n\n参考：<http://www.cnblogs.com/Coda/p/4312281.html>","source":"_posts/designpattern-state1.md","raw":"---\ntitle: 【设计模式】Java状态模式（1）\ndate: 2017-05-20 21:41:22\ntags: java 设计模式 状态模式\n---\nState的定义：不同的状态，不同的行为；或者说，每个状态有着相应的行为\n## 何时使用状态模式\nState模式在实际使用中比较多，适合\"状态的切换\"。因为我们经常会使用If elseif else 进行状态切换， 如果针对状态的这样判断切换反复出现，我们就要联想到是否可以采取State模式了。\n\n不只是根据状态，也有根据属性。如果某个对象的属性不同，对象的行为就不一样，这点在数据库系统中出现频率比较高，我们经常会在一个数据表的尾部，加上property属性含义的字段，用以标识记录中一些特殊性质的记录，这种属性的改变(切换)又是随时可能发生的，就有可能要使用State。\n\n在实际使用，类似开关一样的状态切换是很多的，但有时并不是那么明显，取决于你的经验和对系统的理解深度。\n\n这里要阐述的是\"开关切换状态\" 和\" 一般的状态判断\"是有一些区别的，\" 一般的状态判断\"也是有 if..elseif结构，例如：\n\n\tif (which==1) state=\"hello\";\n\telse if (which==2) state=\"hi\";\n\telse if (which==3) state=\"bye\";\n这是一个 \" 一般的状态判断\"，state值的不同是根据which变量来决定的，which和state没有关系。如果改成：\n\n\t\tif (state.euqals(\"bye\")) state=\"hello\";\n\t　else if (state.euqals(\"hello\")) state=\"hi\";\n\t　else if (state.euqals(\"hi\")) state=\"bye\";\n这就是 \"开关切换状态\"，是将state的状态从\"hello\"切换到\"hi\"，再切换到\"\"bye\"；在切换到\"hello\"，好象一个旋转开关，这种状态改变就可以使用State模式了。\n\n\n如果单纯有上面一种将\"hello\"-->\"hi\"-->\"bye\"-->\"hello\"这一个方向切换，也不一定需要使用State模式，因为State模式会建立很多子类，复杂化，但是如果又发生另外一个行为：将上面的切换方向反过来切换，或者需要任意切换，就需要State了。\n\n请看下例：\n\t\n\tpublic class Context{\n\t　　private Color state=null;\n\t　　public void push(){\n\t　　　　//如果当前red状态 就切换到blue\n\t　　　　if (state==Color.red) state=Color.blue;\n\t　　　　//如果当前blue状态 就切换到green\n\t　　　　else if (state==Color.blue) state=Color.green;\n\t　　　　//如果当前black状态 就切换到red\n\t　　　　else if (state==Color.black) state=Color.red;\n\t　　　　//如果当前green状态 就切换到black\n\t　　　　else if (state==Color.green) state=Color.black;\n\t　　　　Sample sample=new Sample(state);\n\t　　　　sample.operate();\n\t　　}\n\t　　public void pull(){\n\t　　　　//与push状态切换正好相反\n\t　　　　if (state==Color.green) state=Color.blue;\n\t　　　　else if (state==Color.black) state=Color.green;\n\t　　　　else if (state==Color.blue) state=Color.red;\n\t　　　　else if (state==Color.red) state=Color.black;\n\t　　　　Sample2 sample2=new Sample2(state);\n\t　　　　sample2.operate();\n\t　　}\n\t}\n在上例中，我们有两个动作push推和pull拉，这两个开关动作，改变了Context颜色，至此，我们就需要使用State模式优化它。\n\n\n另外注意：但就上例,state的变化，只是简单的颜色赋值，这个具体行为是很简单的，State适合巨大的具体行为，因此在,就本例，实际使用中也不一定非要使用State模式，这会增加子类的数目，简单的变复杂。\n\n例如：银行帐户，经常会在Open 状态和Close状态间转换。\n\n例如：经典的TcpConnection，Tcp的状态有创建 侦听 关闭三个，并且反复转换，其创建 侦听 关闭的具体行为不是简单一两句就能完成的，适合使用State。\n\n例如：信箱POP帐号，会有四种状态，start HaveUsername Authorized quit，每个状态对应的行为应该是比较大的，适合使用State。\n\n例如：在工具箱挑选不同工具，可以看成在不同工具中切换，适合使用State。如 具体绘图程序，用户可以选择不同工具绘制方框 直线 曲线，这种状态切换可以使用State。\n## 如何使用状态模式\nState需要两种类型实体参与：\nstate manager 状态管理器，就是开关，如上面例子的Context实际就是一个state manager，在state manager中有对状态的切换动作。\n用抽象类或接口实现的父类，不同状态就是继承这个父类的不同子类。\n以上面的Context为例，我们要修改它，建立两个类型的实体。\n\n第一步，首先建立一个父类：\n\t\t\n\tpackage top.lc951.state1;\n\t\n\tpublic abstract class  State {\n\t\tpublic abstract void handlepush(Context c);\n\t\tpublic abstract  void handlepull(Context c);\n\t\tpublic abstract String getColor();\n\t\n\t}\n\n\t\n父类中的方法要对应state manager中的开关行为，在state manager中 本例就是Context中，有两个开关动作push推和pull拉.那么在状态父类中就要有具体处理这两个动作：handlepush() handlepull()；同时还需要一个获取push或pull结果的方法getcolor()。\n\n\n下面是具体子类的实现：\n\t\n\tpackage top.lc951.state1;\n\n\tpublic class BlueState extends State {\n\n\t\n\t@Override\n\tpublic void handlepush(Context c) {\n\t\t// TODO Auto-generated method stub\n\t\tc.setState(new GreenState());\n\n\t}\n\n\t@Override\n\tpublic void handlepull(Context c) {\n\t\t// TODO Auto-generated method stub\n\t\tc.setState(new RedState());\n\n\t}\n\n\t@Override\n\tpublic String getColor() {\n\t\t// TODO Auto-generated method stub\n\t\treturn \"blue\";\n\n\t}\n\n}\n\n\t\n\n同样，其他状态的子类实现如blue一样。\n\n\n第二步，要重新改写State manager 也就是本例的Context\n\t\n\tpublic class Context{\n\t　private Sate state=null; //我们将原来的 Color state 改成了新建的State state;\n\t　//setState是用来改变state的状态 使用setState实现状态的切换\n\t　pulic void setState(State state){\n\t　　　　this.state=state;\n\t　}\n\t　public void push(){\n\t　　//状态的切换的细节部分,在本例中是颜色的变化,已经封装在子类的handlepush中实现,这里无需关心\n\t　　state.handlepush(this);\n\t　　//因为sample要使用state中的一个切换结果,使用getColor()\n\t　　Sample sample=new Sample(state.getColor());\n\t　　sample.operate();\n\t　}\n\t　public void pull(){\n\t　　state.handlepull(this);\n\t　　Sample2 sample2=new Sample2(state.getColor());\n\t　　sample2.operate();\n\t　}\n\t}\n\t\n至此，我们也就实现了State的refactorying过程。\n### 源码地址<https://github.com/lichong951/designpattern-lichong951.git>\n\n参考：<http://www.cnblogs.com/Coda/p/4312281.html>","slug":"designpattern-state1","published":1,"updated":"2019-07-15T06:41:57.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416skb000g80s6iuv7whj2","content":"<p>State的定义：不同的状态，不同的行为；或者说，每个状态有着相应的行为</p>\n<h2 id=\"何时使用状态模式\"><a href=\"#何时使用状态模式\" class=\"headerlink\" title=\"何时使用状态模式\"></a>何时使用状态模式</h2><p>State模式在实际使用中比较多，适合”状态的切换”。因为我们经常会使用If elseif else 进行状态切换， 如果针对状态的这样判断切换反复出现，我们就要联想到是否可以采取State模式了。</p>\n<p>不只是根据状态，也有根据属性。如果某个对象的属性不同，对象的行为就不一样，这点在数据库系统中出现频率比较高，我们经常会在一个数据表的尾部，加上property属性含义的字段，用以标识记录中一些特殊性质的记录，这种属性的改变(切换)又是随时可能发生的，就有可能要使用State。</p>\n<p>在实际使用，类似开关一样的状态切换是很多的，但有时并不是那么明显，取决于你的经验和对系统的理解深度。</p>\n<p>这里要阐述的是”开关切换状态” 和” 一般的状态判断”是有一些区别的，” 一般的状态判断”也是有 if..elseif结构，例如：</p>\n<pre><code>if (which==1) state=&quot;hello&quot;;\nelse if (which==2) state=&quot;hi&quot;;\nelse if (which==3) state=&quot;bye&quot;;\n</code></pre><p>这是一个 “ 一般的状态判断”，state值的不同是根据which变量来决定的，which和state没有关系。如果改成：</p>\n<pre><code>if (state.euqals(&quot;bye&quot;)) state=&quot;hello&quot;;\n　else if (state.euqals(&quot;hello&quot;)) state=&quot;hi&quot;;\n　else if (state.euqals(&quot;hi&quot;)) state=&quot;bye&quot;;\n</code></pre><p>这就是 “开关切换状态”，是将state的状态从”hello”切换到”hi”，再切换到””bye”；在切换到”hello”，好象一个旋转开关，这种状态改变就可以使用State模式了。</p>\n<p>如果单纯有上面一种将”hello”–&gt;”hi”–&gt;”bye”–&gt;”hello”这一个方向切换，也不一定需要使用State模式，因为State模式会建立很多子类，复杂化，但是如果又发生另外一个行为：将上面的切换方向反过来切换，或者需要任意切换，就需要State了。</p>\n<p>请看下例：</p>\n<pre><code>public class Context{\n　　private Color state=null;\n　　public void push(){\n　　　　//如果当前red状态 就切换到blue\n　　　　if (state==Color.red) state=Color.blue;\n　　　　//如果当前blue状态 就切换到green\n　　　　else if (state==Color.blue) state=Color.green;\n　　　　//如果当前black状态 就切换到red\n　　　　else if (state==Color.black) state=Color.red;\n　　　　//如果当前green状态 就切换到black\n　　　　else if (state==Color.green) state=Color.black;\n　　　　Sample sample=new Sample(state);\n　　　　sample.operate();\n　　}\n　　public void pull(){\n　　　　//与push状态切换正好相反\n　　　　if (state==Color.green) state=Color.blue;\n　　　　else if (state==Color.black) state=Color.green;\n　　　　else if (state==Color.blue) state=Color.red;\n　　　　else if (state==Color.red) state=Color.black;\n　　　　Sample2 sample2=new Sample2(state);\n　　　　sample2.operate();\n　　}\n}\n</code></pre><p>在上例中，我们有两个动作push推和pull拉，这两个开关动作，改变了Context颜色，至此，我们就需要使用State模式优化它。</p>\n<p>另外注意：但就上例,state的变化，只是简单的颜色赋值，这个具体行为是很简单的，State适合巨大的具体行为，因此在,就本例，实际使用中也不一定非要使用State模式，这会增加子类的数目，简单的变复杂。</p>\n<p>例如：银行帐户，经常会在Open 状态和Close状态间转换。</p>\n<p>例如：经典的TcpConnection，Tcp的状态有创建 侦听 关闭三个，并且反复转换，其创建 侦听 关闭的具体行为不是简单一两句就能完成的，适合使用State。</p>\n<p>例如：信箱POP帐号，会有四种状态，start HaveUsername Authorized quit，每个状态对应的行为应该是比较大的，适合使用State。</p>\n<p>例如：在工具箱挑选不同工具，可以看成在不同工具中切换，适合使用State。如 具体绘图程序，用户可以选择不同工具绘制方框 直线 曲线，这种状态切换可以使用State。</p>\n<h2 id=\"如何使用状态模式\"><a href=\"#如何使用状态模式\" class=\"headerlink\" title=\"如何使用状态模式\"></a>如何使用状态模式</h2><p>State需要两种类型实体参与：<br>state manager 状态管理器，就是开关，如上面例子的Context实际就是一个state manager，在state manager中有对状态的切换动作。<br>用抽象类或接口实现的父类，不同状态就是继承这个父类的不同子类。<br>以上面的Context为例，我们要修改它，建立两个类型的实体。</p>\n<p>第一步，首先建立一个父类：</p>\n<pre><code>package top.lc951.state1;\n\npublic abstract class  State {\n    public abstract void handlepush(Context c);\n    public abstract  void handlepull(Context c);\n    public abstract String getColor();\n\n}\n</code></pre><p>父类中的方法要对应state manager中的开关行为，在state manager中 本例就是Context中，有两个开关动作push推和pull拉.那么在状态父类中就要有具体处理这两个动作：handlepush() handlepull()；同时还需要一个获取push或pull结果的方法getcolor()。</p>\n<p>下面是具体子类的实现：</p>\n<pre><code>package top.lc951.state1;\n\npublic class BlueState extends State {\n\n\n@Override\npublic void handlepush(Context c) {\n    // TODO Auto-generated method stub\n    c.setState(new GreenState());\n\n}\n\n@Override\npublic void handlepull(Context c) {\n    // TODO Auto-generated method stub\n    c.setState(new RedState());\n\n}\n\n@Override\npublic String getColor() {\n    // TODO Auto-generated method stub\n    return &quot;blue&quot;;\n\n}\n</code></pre><p>}</p>\n<p>同样，其他状态的子类实现如blue一样。</p>\n<p>第二步，要重新改写State manager 也就是本例的Context</p>\n<pre><code>public class Context{\n　private Sate state=null; //我们将原来的 Color state 改成了新建的State state;\n　//setState是用来改变state的状态 使用setState实现状态的切换\n　pulic void setState(State state){\n　　　　this.state=state;\n　}\n　public void push(){\n　　//状态的切换的细节部分,在本例中是颜色的变化,已经封装在子类的handlepush中实现,这里无需关心\n　　state.handlepush(this);\n　　//因为sample要使用state中的一个切换结果,使用getColor()\n　　Sample sample=new Sample(state.getColor());\n　　sample.operate();\n　}\n　public void pull(){\n　　state.handlepull(this);\n　　Sample2 sample2=new Sample2(state.getColor());\n　　sample2.operate();\n　}\n}\n</code></pre><p>至此，我们也就实现了State的refactorying过程。</p>\n<h3 id=\"源码地址https-github-com-lichong951-designpattern-lichong951-git\"><a href=\"#源码地址https-github-com-lichong951-designpattern-lichong951-git\" class=\"headerlink\" title=\"源码地址https://github.com/lichong951/designpattern-lichong951.git\"></a>源码地址<a href=\"https://github.com/lichong951/designpattern-lichong951.git\" target=\"_blank\" rel=\"noopener\">https://github.com/lichong951/designpattern-lichong951.git</a></h3><p>参考：<a href=\"http://www.cnblogs.com/Coda/p/4312281.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/Coda/p/4312281.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>State的定义：不同的状态，不同的行为；或者说，每个状态有着相应的行为</p>\n<h2 id=\"何时使用状态模式\"><a href=\"#何时使用状态模式\" class=\"headerlink\" title=\"何时使用状态模式\"></a>何时使用状态模式</h2><p>State模式在实际使用中比较多，适合”状态的切换”。因为我们经常会使用If elseif else 进行状态切换， 如果针对状态的这样判断切换反复出现，我们就要联想到是否可以采取State模式了。</p>\n<p>不只是根据状态，也有根据属性。如果某个对象的属性不同，对象的行为就不一样，这点在数据库系统中出现频率比较高，我们经常会在一个数据表的尾部，加上property属性含义的字段，用以标识记录中一些特殊性质的记录，这种属性的改变(切换)又是随时可能发生的，就有可能要使用State。</p>\n<p>在实际使用，类似开关一样的状态切换是很多的，但有时并不是那么明显，取决于你的经验和对系统的理解深度。</p>\n<p>这里要阐述的是”开关切换状态” 和” 一般的状态判断”是有一些区别的，” 一般的状态判断”也是有 if..elseif结构，例如：</p>\n<pre><code>if (which==1) state=&quot;hello&quot;;\nelse if (which==2) state=&quot;hi&quot;;\nelse if (which==3) state=&quot;bye&quot;;\n</code></pre><p>这是一个 “ 一般的状态判断”，state值的不同是根据which变量来决定的，which和state没有关系。如果改成：</p>\n<pre><code>if (state.euqals(&quot;bye&quot;)) state=&quot;hello&quot;;\n　else if (state.euqals(&quot;hello&quot;)) state=&quot;hi&quot;;\n　else if (state.euqals(&quot;hi&quot;)) state=&quot;bye&quot;;\n</code></pre><p>这就是 “开关切换状态”，是将state的状态从”hello”切换到”hi”，再切换到””bye”；在切换到”hello”，好象一个旋转开关，这种状态改变就可以使用State模式了。</p>\n<p>如果单纯有上面一种将”hello”–&gt;”hi”–&gt;”bye”–&gt;”hello”这一个方向切换，也不一定需要使用State模式，因为State模式会建立很多子类，复杂化，但是如果又发生另外一个行为：将上面的切换方向反过来切换，或者需要任意切换，就需要State了。</p>\n<p>请看下例：</p>\n<pre><code>public class Context{\n　　private Color state=null;\n　　public void push(){\n　　　　//如果当前red状态 就切换到blue\n　　　　if (state==Color.red) state=Color.blue;\n　　　　//如果当前blue状态 就切换到green\n　　　　else if (state==Color.blue) state=Color.green;\n　　　　//如果当前black状态 就切换到red\n　　　　else if (state==Color.black) state=Color.red;\n　　　　//如果当前green状态 就切换到black\n　　　　else if (state==Color.green) state=Color.black;\n　　　　Sample sample=new Sample(state);\n　　　　sample.operate();\n　　}\n　　public void pull(){\n　　　　//与push状态切换正好相反\n　　　　if (state==Color.green) state=Color.blue;\n　　　　else if (state==Color.black) state=Color.green;\n　　　　else if (state==Color.blue) state=Color.red;\n　　　　else if (state==Color.red) state=Color.black;\n　　　　Sample2 sample2=new Sample2(state);\n　　　　sample2.operate();\n　　}\n}\n</code></pre><p>在上例中，我们有两个动作push推和pull拉，这两个开关动作，改变了Context颜色，至此，我们就需要使用State模式优化它。</p>\n<p>另外注意：但就上例,state的变化，只是简单的颜色赋值，这个具体行为是很简单的，State适合巨大的具体行为，因此在,就本例，实际使用中也不一定非要使用State模式，这会增加子类的数目，简单的变复杂。</p>\n<p>例如：银行帐户，经常会在Open 状态和Close状态间转换。</p>\n<p>例如：经典的TcpConnection，Tcp的状态有创建 侦听 关闭三个，并且反复转换，其创建 侦听 关闭的具体行为不是简单一两句就能完成的，适合使用State。</p>\n<p>例如：信箱POP帐号，会有四种状态，start HaveUsername Authorized quit，每个状态对应的行为应该是比较大的，适合使用State。</p>\n<p>例如：在工具箱挑选不同工具，可以看成在不同工具中切换，适合使用State。如 具体绘图程序，用户可以选择不同工具绘制方框 直线 曲线，这种状态切换可以使用State。</p>\n<h2 id=\"如何使用状态模式\"><a href=\"#如何使用状态模式\" class=\"headerlink\" title=\"如何使用状态模式\"></a>如何使用状态模式</h2><p>State需要两种类型实体参与：<br>state manager 状态管理器，就是开关，如上面例子的Context实际就是一个state manager，在state manager中有对状态的切换动作。<br>用抽象类或接口实现的父类，不同状态就是继承这个父类的不同子类。<br>以上面的Context为例，我们要修改它，建立两个类型的实体。</p>\n<p>第一步，首先建立一个父类：</p>\n<pre><code>package top.lc951.state1;\n\npublic abstract class  State {\n    public abstract void handlepush(Context c);\n    public abstract  void handlepull(Context c);\n    public abstract String getColor();\n\n}\n</code></pre><p>父类中的方法要对应state manager中的开关行为，在state manager中 本例就是Context中，有两个开关动作push推和pull拉.那么在状态父类中就要有具体处理这两个动作：handlepush() handlepull()；同时还需要一个获取push或pull结果的方法getcolor()。</p>\n<p>下面是具体子类的实现：</p>\n<pre><code>package top.lc951.state1;\n\npublic class BlueState extends State {\n\n\n@Override\npublic void handlepush(Context c) {\n    // TODO Auto-generated method stub\n    c.setState(new GreenState());\n\n}\n\n@Override\npublic void handlepull(Context c) {\n    // TODO Auto-generated method stub\n    c.setState(new RedState());\n\n}\n\n@Override\npublic String getColor() {\n    // TODO Auto-generated method stub\n    return &quot;blue&quot;;\n\n}\n</code></pre><p>}</p>\n<p>同样，其他状态的子类实现如blue一样。</p>\n<p>第二步，要重新改写State manager 也就是本例的Context</p>\n<pre><code>public class Context{\n　private Sate state=null; //我们将原来的 Color state 改成了新建的State state;\n　//setState是用来改变state的状态 使用setState实现状态的切换\n　pulic void setState(State state){\n　　　　this.state=state;\n　}\n　public void push(){\n　　//状态的切换的细节部分,在本例中是颜色的变化,已经封装在子类的handlepush中实现,这里无需关心\n　　state.handlepush(this);\n　　//因为sample要使用state中的一个切换结果,使用getColor()\n　　Sample sample=new Sample(state.getColor());\n　　sample.operate();\n　}\n　public void pull(){\n　　state.handlepull(this);\n　　Sample2 sample2=new Sample2(state.getColor());\n　　sample2.operate();\n　}\n}\n</code></pre><p>至此，我们也就实现了State的refactorying过程。</p>\n<h3 id=\"源码地址https-github-com-lichong951-designpattern-lichong951-git\"><a href=\"#源码地址https-github-com-lichong951-designpattern-lichong951-git\" class=\"headerlink\" title=\"源码地址https://github.com/lichong951/designpattern-lichong951.git\"></a>源码地址<a href=\"https://github.com/lichong951/designpattern-lichong951.git\" target=\"_blank\" rel=\"noopener\">https://github.com/lichong951/designpattern-lichong951.git</a></h3><p>参考：<a href=\"http://www.cnblogs.com/Coda/p/4312281.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/Coda/p/4312281.html</a></p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-02-03T09:05:24.000Z","updated":"2017-02-03T09:05:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416skc000i80s64wtnh4n5","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"Handler机制","date":"2017-04-22T00:37:31.000Z","_content":"#Handler机制\n##Message结构分析\nHandler部分源码：\n\t\t\n\t\tprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n        msg.target = this;\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }","source":"_posts/handler-framework.md","raw":"---\ntitle: Handler机制\ndate: 2017-04-22 08:37:31\ntags: Handler 框架 Android\n---\n#Handler机制\n##Message结构分析\nHandler部分源码：\n\t\t\n\t\tprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n        msg.target = this;\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }","slug":"handler-framework","published":1,"updated":"2019-07-15T06:41:57.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416ske000k80s69e3sd5g1","content":"<p>#Handler机制</p>\n<p>##Message结构分析<br>Handler部分源码：</p>\n<pre><code>    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n    msg.target = this;\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>#Handler机制</p>\n<p>##Message结构分析<br>Handler部分源码：</p>\n<pre><code>    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n    msg.target = this;\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n</code></pre>"},{"title":"【Unity3D】Android真机断点调试","date":"2017-11-18T07:59:16.000Z","_content":"# 【Unity3D】Android真机断点调试\n\n1. 首先在手机上开启USB调试功能，并安装驱动（这一步很多手机助手都可以完成）\n2. 用USB电缆连接手机和电脑\n3. 确保手机和电脑在一个局域网内，简单的说就是电脑和手机共用一个路由器，网段一样。\n4. 打开电脑上CMD窗口，输入以下命令：\n\n\t Adb tcpip 5555（该命令打开手机adb网络调试功能）\n\t正常情况下输入命令后控制台会出现回显\n\t  restarting in TCP mode port: 5555\n\t 打开手机查看手机的IP地址（不会请百度）假设手机的地址是192.168.1.x输入命令\n\tadb connect 192.168.1.x\n\t如果一切正常控制台会回显以下内容\n\tconnected to 192.168.1.x:5555\n\t如果你想查看是否连接成功请输入以下内容\n\t  adb devices\n\t  控制台会回显连接的设备\n\t  \n5. 如果一切连接成功，请拔掉USB电缆，选择File->Build&Run，在编译之前要勾选上\nDevelopment Build 和Script Debugging这两项在build setting里面勾选不要忘记否则是不能调试的）电脑会自动编译文件并将APK推送至手机，在手机上同意并安装\n\n6. 当程序运行后再Monodevelop里面打开Run->Attach to process 会发现你手机的选项，选择手机，在脚本里面添加断点，你发现可以调试了，那叫一个爽！出现问题再也不用去瞎猜，或者添加Debuglog了\n","source":"_posts/unity3d-android-debug.md","raw":"---\ntitle: 【Unity3D】Android真机断点调试\ndate: 2017-11-18 15:59:16\ntags: unity3d android \n---\n# 【Unity3D】Android真机断点调试\n\n1. 首先在手机上开启USB调试功能，并安装驱动（这一步很多手机助手都可以完成）\n2. 用USB电缆连接手机和电脑\n3. 确保手机和电脑在一个局域网内，简单的说就是电脑和手机共用一个路由器，网段一样。\n4. 打开电脑上CMD窗口，输入以下命令：\n\n\t Adb tcpip 5555（该命令打开手机adb网络调试功能）\n\t正常情况下输入命令后控制台会出现回显\n\t  restarting in TCP mode port: 5555\n\t 打开手机查看手机的IP地址（不会请百度）假设手机的地址是192.168.1.x输入命令\n\tadb connect 192.168.1.x\n\t如果一切正常控制台会回显以下内容\n\tconnected to 192.168.1.x:5555\n\t如果你想查看是否连接成功请输入以下内容\n\t  adb devices\n\t  控制台会回显连接的设备\n\t  \n5. 如果一切连接成功，请拔掉USB电缆，选择File->Build&Run，在编译之前要勾选上\nDevelopment Build 和Script Debugging这两项在build setting里面勾选不要忘记否则是不能调试的）电脑会自动编译文件并将APK推送至手机，在手机上同意并安装\n\n6. 当程序运行后再Monodevelop里面打开Run->Attach to process 会发现你手机的选项，选择手机，在脚本里面添加断点，你发现可以调试了，那叫一个爽！出现问题再也不用去瞎猜，或者添加Debuglog了\n","slug":"unity3d-android-debug","published":1,"updated":"2019-07-15T06:42:03.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416skf000m80s6wi1iwp6b","content":"<h1 id=\"【Unity3D】Android真机断点调试\"><a href=\"#【Unity3D】Android真机断点调试\" class=\"headerlink\" title=\"【Unity3D】Android真机断点调试\"></a>【Unity3D】Android真机断点调试</h1><ol>\n<li>首先在手机上开启USB调试功能，并安装驱动（这一步很多手机助手都可以完成）</li>\n<li>用USB电缆连接手机和电脑</li>\n<li>确保手机和电脑在一个局域网内，简单的说就是电脑和手机共用一个路由器，网段一样。</li>\n<li><p>打开电脑上CMD窗口，输入以下命令：</p>\n<p>  Adb tcpip 5555（该命令打开手机adb网络调试功能）<br> 正常情况下输入命令后控制台会出现回显<br>   restarting in TCP mode port: 5555<br>  打开手机查看手机的IP地址（不会请百度）假设手机的地址是192.168.1.x输入命令<br> adb connect 192.168.1.x<br> 如果一切正常控制台会回显以下内容<br> connected to 192.168.1.x:5555<br> 如果你想查看是否连接成功请输入以下内容<br>   adb devices<br>   控制台会回显连接的设备</p>\n</li>\n<li><p>如果一切连接成功，请拔掉USB电缆，选择File-&gt;Build&amp;Run，在编译之前要勾选上<br>Development Build 和Script Debugging这两项在build setting里面勾选不要忘记否则是不能调试的）电脑会自动编译文件并将APK推送至手机，在手机上同意并安装</p>\n</li>\n<li><p>当程序运行后再Monodevelop里面打开Run-&gt;Attach to process 会发现你手机的选项，选择手机，在脚本里面添加断点，你发现可以调试了，那叫一个爽！出现问题再也不用去瞎猜，或者添加Debuglog了</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"【Unity3D】Android真机断点调试\"><a href=\"#【Unity3D】Android真机断点调试\" class=\"headerlink\" title=\"【Unity3D】Android真机断点调试\"></a>【Unity3D】Android真机断点调试</h1><ol>\n<li>首先在手机上开启USB调试功能，并安装驱动（这一步很多手机助手都可以完成）</li>\n<li>用USB电缆连接手机和电脑</li>\n<li>确保手机和电脑在一个局域网内，简单的说就是电脑和手机共用一个路由器，网段一样。</li>\n<li><p>打开电脑上CMD窗口，输入以下命令：</p>\n<p>  Adb tcpip 5555（该命令打开手机adb网络调试功能）<br> 正常情况下输入命令后控制台会出现回显<br>   restarting in TCP mode port: 5555<br>  打开手机查看手机的IP地址（不会请百度）假设手机的地址是192.168.1.x输入命令<br> adb connect 192.168.1.x<br> 如果一切正常控制台会回显以下内容<br> connected to 192.168.1.x:5555<br> 如果你想查看是否连接成功请输入以下内容<br>   adb devices<br>   控制台会回显连接的设备</p>\n</li>\n<li><p>如果一切连接成功，请拔掉USB电缆，选择File-&gt;Build&amp;Run，在编译之前要勾选上<br>Development Build 和Script Debugging这两项在build setting里面勾选不要忘记否则是不能调试的）电脑会自动编译文件并将APK推送至手机，在手机上同意并安装</p>\n</li>\n<li><p>当程序运行后再Monodevelop里面打开Run-&gt;Attach to process 会发现你手机的选项，选择手机，在脚本里面添加断点，你发现可以调试了，那叫一个爽！出现问题再也不用去瞎猜，或者添加Debuglog了</p>\n</li>\n</ol>\n"},{"title":"【Jenkins】构建后生成下载二维码并邮件通知","date":"2018-05-13T07:18:25.000Z","_content":"### 二维码生成配置\n#### http-server(MAC)\n检测 node -v、npm -v 然后安装http-server\n\n\tnpm install http-server -g\n\t\n启动服务“http-server -p 8000” 设置端口为8000.避免jenkins端口冲突\n在/Users/XXX/Public 目录下面建立jenkins目录，把构建后的apk复制到/Users/XXX/Public/jenkins/apk/目录下面\n然后把二维码图片也复制到/Users/XXX/Public/jenkins\n\n> 为什么要http-server服务\n\n因为在jenkins里的图片在邮件里是没有办法直接显示的。必须要有一个没有拦截的访问路径。以避开jenkins的用户验证。同理apk的下载也是如此\n不过一般都是部署在局域网内。安全性还是有保障的。如果要发布到外网的可以使用第三方服务上传apk包生成公网下载二维码。\n\n#### 安装pip（MAC）（python>3.1）[如果版本不够看”其他“]\n\t\n\tsudo easy_install pip\n[mac下安装pip](https://jingyan.baidu.com/article/ca2d939d6299eaeb6c31cee2.html)\n\n[windows下面安装Python和pip终极教程](http://www.cnblogs.com/yuanzm/p/4089856.html)\n#### 安装myqr\n\n\t命令1：pip install Pillow （失败）\n\t命令2：pip install -I --no-cache-dir -v Pillow （成功）\n\t至于为什么失败，解释颇多也不想深究。暂且都记上多试试。\n\t安装qrcode 命令：pip install myqr\n生成二维码命令\n\tmyqr http://localhost:8000/jenkins/apk/XXXX.apk -n jenkins-qrcode-${JOB_NAME}.png -v 1 -l L -d /Users/XXX/Public/jenkins\n\t\n\n### Jenkins邮件通知配置\n在邮件配置content字段里添加\n\t\n\t<img src=\"http://localhost:8000/jenkins/jenkins-qrcode-${JOB_NAME}.png \" width=\"200px\" height=\"200px\" /></br></hr>\n\t<a href='http://localhost:8000/jenkins/apk/XXXX.apk'>点击下载apk</a>\n\n\n\n邮件通知配置样例\n\t<hr/>\n\n\t(本邮件是程序自动下发的，请勿回复！)<br/><hr/>\n\n\t项目名称：$PROJECT_NAME<br/><hr/>\n\n\t构建编号：$BUILD_NUMBER<br/><hr/>\n\n\t构建状态：$BUILD_STATUS<br/><hr/>\n\n\t触发原因：${CAUSE}<br/><hr/>\n\n\t扫描二维码下载<img src=\"http://192.168.10.214:8000/JenkinsApk/jenkins-qrcode-${JOB_NAME}.png\" width=\"200px\" height=\"200px\"/> <br/><hr/>\n\t<a href=\"http://192.168.10.214:8000/JenkinsApk/apk/${JOB_NAME}-Debug-${BUILD_NUMBER}.apk\">点击下载${JOB_NAME}-Debug-${BUILD_NUMBER}.apk</a><br/><hr/>\n\t构建日志地址：<a href=\"${BUILD_URL}console\">${BUILD_URL}console</a><br/><hr/>\n\n\t构建地址：<a href=\"$BUILD_URL\">$BUILD_URL</a><br/><hr/>\n\n\t变更集:${JELLY_SCRIPT,template=\"html\"}<br/><hr/>\n\n\n参考：\nhttps://www.jianshu.com/p/915c1ae69144\n\n### 其他\n【MAC】\n> “OSError: [Errno 13] Permission denied: '/Library/Python/2.7/site-packages/PIL'”\n\n**使用 sudo pip install -I --no-cache-dir -v Pillow 命令安装**\n\n> mac OSError: [Errno 1] Operation not permitted: '/tmp/pip-ZaNR4Q-uninstall/System/Library/Frameworks\n\n升级python 版本\n\n\t$ pip install --upgrade pip\n\t$ sudo pip install numpy --upgrade --ignore-installed\n\t$ sudo pip install scipy --upgrade --ignore-installed\n\t$ sudo pip install scikit-learn --upgrade --ignore-installed\n\t\n参考https://www.jianshu.com/p/7a18c78b5982\n\n> OSError: [Errno 13] Permission denied: '/Library/Python/2.7/site-packages/imageio-2.3.0.dist-info'\n解决方法：\n**sudo pip install myqr**\n\n> matplotlib 1.3.1 requires nose, which is not installed.\n> matplotlib 1.3.1 requires tornado, which is not installed.\n\n解决方法：运行sudo pip install matplotlib\n\n## 联系我\n> Email:lichongmac@163.com\n\n支付宝打赏：[https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A](https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A)\n\n微信打赏：[https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ](https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ)\n\n公众号推荐：\n\n![](http://i2.51cto.com/images/blog/201805/11/0e2ece55187caabd7b246e9550a8d5a0.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)","source":"_posts/【Jenkins】构建后生成下载二维码并邮件通知.md","raw":"---\ntitle: 【Jenkins】构建后生成下载二维码并邮件通知\ndate: 2018-05-13 15:18:25\ntags: Jenkins Email通知\t二维码\n---\n### 二维码生成配置\n#### http-server(MAC)\n检测 node -v、npm -v 然后安装http-server\n\n\tnpm install http-server -g\n\t\n启动服务“http-server -p 8000” 设置端口为8000.避免jenkins端口冲突\n在/Users/XXX/Public 目录下面建立jenkins目录，把构建后的apk复制到/Users/XXX/Public/jenkins/apk/目录下面\n然后把二维码图片也复制到/Users/XXX/Public/jenkins\n\n> 为什么要http-server服务\n\n因为在jenkins里的图片在邮件里是没有办法直接显示的。必须要有一个没有拦截的访问路径。以避开jenkins的用户验证。同理apk的下载也是如此\n不过一般都是部署在局域网内。安全性还是有保障的。如果要发布到外网的可以使用第三方服务上传apk包生成公网下载二维码。\n\n#### 安装pip（MAC）（python>3.1）[如果版本不够看”其他“]\n\t\n\tsudo easy_install pip\n[mac下安装pip](https://jingyan.baidu.com/article/ca2d939d6299eaeb6c31cee2.html)\n\n[windows下面安装Python和pip终极教程](http://www.cnblogs.com/yuanzm/p/4089856.html)\n#### 安装myqr\n\n\t命令1：pip install Pillow （失败）\n\t命令2：pip install -I --no-cache-dir -v Pillow （成功）\n\t至于为什么失败，解释颇多也不想深究。暂且都记上多试试。\n\t安装qrcode 命令：pip install myqr\n生成二维码命令\n\tmyqr http://localhost:8000/jenkins/apk/XXXX.apk -n jenkins-qrcode-${JOB_NAME}.png -v 1 -l L -d /Users/XXX/Public/jenkins\n\t\n\n### Jenkins邮件通知配置\n在邮件配置content字段里添加\n\t\n\t<img src=\"http://localhost:8000/jenkins/jenkins-qrcode-${JOB_NAME}.png \" width=\"200px\" height=\"200px\" /></br></hr>\n\t<a href='http://localhost:8000/jenkins/apk/XXXX.apk'>点击下载apk</a>\n\n\n\n邮件通知配置样例\n\t<hr/>\n\n\t(本邮件是程序自动下发的，请勿回复！)<br/><hr/>\n\n\t项目名称：$PROJECT_NAME<br/><hr/>\n\n\t构建编号：$BUILD_NUMBER<br/><hr/>\n\n\t构建状态：$BUILD_STATUS<br/><hr/>\n\n\t触发原因：${CAUSE}<br/><hr/>\n\n\t扫描二维码下载<img src=\"http://192.168.10.214:8000/JenkinsApk/jenkins-qrcode-${JOB_NAME}.png\" width=\"200px\" height=\"200px\"/> <br/><hr/>\n\t<a href=\"http://192.168.10.214:8000/JenkinsApk/apk/${JOB_NAME}-Debug-${BUILD_NUMBER}.apk\">点击下载${JOB_NAME}-Debug-${BUILD_NUMBER}.apk</a><br/><hr/>\n\t构建日志地址：<a href=\"${BUILD_URL}console\">${BUILD_URL}console</a><br/><hr/>\n\n\t构建地址：<a href=\"$BUILD_URL\">$BUILD_URL</a><br/><hr/>\n\n\t变更集:${JELLY_SCRIPT,template=\"html\"}<br/><hr/>\n\n\n参考：\nhttps://www.jianshu.com/p/915c1ae69144\n\n### 其他\n【MAC】\n> “OSError: [Errno 13] Permission denied: '/Library/Python/2.7/site-packages/PIL'”\n\n**使用 sudo pip install -I --no-cache-dir -v Pillow 命令安装**\n\n> mac OSError: [Errno 1] Operation not permitted: '/tmp/pip-ZaNR4Q-uninstall/System/Library/Frameworks\n\n升级python 版本\n\n\t$ pip install --upgrade pip\n\t$ sudo pip install numpy --upgrade --ignore-installed\n\t$ sudo pip install scipy --upgrade --ignore-installed\n\t$ sudo pip install scikit-learn --upgrade --ignore-installed\n\t\n参考https://www.jianshu.com/p/7a18c78b5982\n\n> OSError: [Errno 13] Permission denied: '/Library/Python/2.7/site-packages/imageio-2.3.0.dist-info'\n解决方法：\n**sudo pip install myqr**\n\n> matplotlib 1.3.1 requires nose, which is not installed.\n> matplotlib 1.3.1 requires tornado, which is not installed.\n\n解决方法：运行sudo pip install matplotlib\n\n## 联系我\n> Email:lichongmac@163.com\n\n支付宝打赏：[https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A](https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A)\n\n微信打赏：[https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ](https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ)\n\n公众号推荐：\n\n![](http://i2.51cto.com/images/blog/201805/11/0e2ece55187caabd7b246e9550a8d5a0.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)","slug":"【Jenkins】构建后生成下载二维码并邮件通知","published":1,"updated":"2019-07-15T06:42:03.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416skf000o80s6f3npr0m0","content":"<h3 id=\"二维码生成配置\"><a href=\"#二维码生成配置\" class=\"headerlink\" title=\"二维码生成配置\"></a>二维码生成配置</h3><h4 id=\"http-server-MAC\"><a href=\"#http-server-MAC\" class=\"headerlink\" title=\"http-server(MAC)\"></a>http-server(MAC)</h4><p>检测 node -v、npm -v 然后安装http-server</p>\n<pre><code>npm install http-server -g\n</code></pre><p>启动服务“http-server -p 8000” 设置端口为8000.避免jenkins端口冲突<br>在/Users/XXX/Public 目录下面建立jenkins目录，把构建后的apk复制到/Users/XXX/Public/jenkins/apk/目录下面<br>然后把二维码图片也复制到/Users/XXX/Public/jenkins</p>\n<blockquote>\n<p>为什么要http-server服务</p>\n</blockquote>\n<p>因为在jenkins里的图片在邮件里是没有办法直接显示的。必须要有一个没有拦截的访问路径。以避开jenkins的用户验证。同理apk的下载也是如此<br>不过一般都是部署在局域网内。安全性还是有保障的。如果要发布到外网的可以使用第三方服务上传apk包生成公网下载二维码。</p>\n<h4 id=\"安装pip（MAC）（python-gt-3-1）-如果版本不够看”其他“\"><a href=\"#安装pip（MAC）（python-gt-3-1）-如果版本不够看”其他“\" class=\"headerlink\" title=\"安装pip（MAC）（python&gt;3.1）[如果版本不够看”其他“]\"></a>安装pip（MAC）（python&gt;3.1）[如果版本不够看”其他“]</h4><pre><code>sudo easy_install pip\n</code></pre><p><a href=\"https://jingyan.baidu.com/article/ca2d939d6299eaeb6c31cee2.html\" target=\"_blank\" rel=\"noopener\">mac下安装pip</a></p>\n<p><a href=\"http://www.cnblogs.com/yuanzm/p/4089856.html\" target=\"_blank\" rel=\"noopener\">windows下面安装Python和pip终极教程</a></p>\n<h4 id=\"安装myqr\"><a href=\"#安装myqr\" class=\"headerlink\" title=\"安装myqr\"></a>安装myqr</h4><pre><code>命令1：pip install Pillow （失败）\n命令2：pip install -I --no-cache-dir -v Pillow （成功）\n至于为什么失败，解释颇多也不想深究。暂且都记上多试试。\n安装qrcode 命令：pip install myqr\n</code></pre><p>生成二维码命令<br>    myqr <a href=\"http://localhost:8000/jenkins/apk/XXXX.apk\" target=\"_blank\" rel=\"noopener\">http://localhost:8000/jenkins/apk/XXXX.apk</a> -n jenkins-qrcode-${JOB_NAME}.png -v 1 -l L -d /Users/XXX/Public/jenkins</p>\n<h3 id=\"Jenkins邮件通知配置\"><a href=\"#Jenkins邮件通知配置\" class=\"headerlink\" title=\"Jenkins邮件通知配置\"></a>Jenkins邮件通知配置</h3><p>在邮件配置content字段里添加</p>\n<pre><code>&lt;img src=&quot;http://localhost:8000/jenkins/jenkins-qrcode-${JOB_NAME}.png &quot; width=&quot;200px&quot; height=&quot;200px&quot; /&gt;&lt;/br&gt;&lt;/hr&gt;\n&lt;a href=&apos;http://localhost:8000/jenkins/apk/XXXX.apk&apos;&gt;点击下载apk&lt;/a&gt;\n</code></pre><p>邮件通知配置样例<br>    <hr></p>\n<pre><code>(本邮件是程序自动下发的，请勿回复！)&lt;br/&gt;&lt;hr/&gt;\n\n项目名称：$PROJECT_NAME&lt;br/&gt;&lt;hr/&gt;\n\n构建编号：$BUILD_NUMBER&lt;br/&gt;&lt;hr/&gt;\n\n构建状态：$BUILD_STATUS&lt;br/&gt;&lt;hr/&gt;\n\n触发原因：${CAUSE}&lt;br/&gt;&lt;hr/&gt;\n\n扫描二维码下载&lt;img src=&quot;http://192.168.10.214:8000/JenkinsApk/jenkins-qrcode-${JOB_NAME}.png&quot; width=&quot;200px&quot; height=&quot;200px&quot;/&gt; &lt;br/&gt;&lt;hr/&gt;\n&lt;a href=&quot;http://192.168.10.214:8000/JenkinsApk/apk/${JOB_NAME}-Debug-${BUILD_NUMBER}.apk&quot;&gt;点击下载${JOB_NAME}-Debug-${BUILD_NUMBER}.apk&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n构建日志地址：&lt;a href=&quot;${BUILD_URL}console&quot;&gt;${BUILD_URL}console&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n\n构建地址：&lt;a href=&quot;$BUILD_URL&quot;&gt;$BUILD_URL&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n\n变更集:${JELLY_SCRIPT,template=&quot;html&quot;}&lt;br/&gt;&lt;hr/&gt;\n</code></pre><p>参考：<br><a href=\"https://www.jianshu.com/p/915c1ae69144\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/915c1ae69144</a></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>【MAC】</p>\n<blockquote>\n<p>“OSError: [Errno 13] Permission denied: ‘/Library/Python/2.7/site-packages/PIL’”</p>\n</blockquote>\n<p><strong>使用 sudo pip install -I –no-cache-dir -v Pillow 命令安装</strong></p>\n<blockquote>\n<p>mac OSError: [Errno 1] Operation not permitted: ‘/tmp/pip-ZaNR4Q-uninstall/System/Library/Frameworks</p>\n</blockquote>\n<p>升级python 版本</p>\n<pre><code>$ pip install --upgrade pip\n$ sudo pip install numpy --upgrade --ignore-installed\n$ sudo pip install scipy --upgrade --ignore-installed\n$ sudo pip install scikit-learn --upgrade --ignore-installed\n</code></pre><p>参考<a href=\"https://www.jianshu.com/p/7a18c78b5982\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/7a18c78b5982</a></p>\n<blockquote>\n<p>OSError: [Errno 13] Permission denied: ‘/Library/Python/2.7/site-packages/imageio-2.3.0.dist-info’<br>解决方法：<br><strong>sudo pip install myqr</strong></p>\n</blockquote>\n<blockquote>\n<p>matplotlib 1.3.1 requires nose, which is not installed.<br>matplotlib 1.3.1 requires tornado, which is not installed.</p>\n</blockquote>\n<p>解决方法：运行sudo pip install matplotlib</p>\n<h2 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h2><blockquote>\n<p>Email:<a href=\"mailto:lichongmac@163.com\" target=\"_blank\" rel=\"noopener\">lichongmac@163.com</a></p>\n</blockquote>\n<p>支付宝打赏：<a href=\"https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A</a></p>\n<p>微信打赏：<a href=\"https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ</a></p>\n<p>公众号推荐：</p>\n<p><img src=\"http://i2.51cto.com/images/blog/201805/11/0e2ece55187caabd7b246e9550a8d5a0.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"二维码生成配置\"><a href=\"#二维码生成配置\" class=\"headerlink\" title=\"二维码生成配置\"></a>二维码生成配置</h3><h4 id=\"http-server-MAC\"><a href=\"#http-server-MAC\" class=\"headerlink\" title=\"http-server(MAC)\"></a>http-server(MAC)</h4><p>检测 node -v、npm -v 然后安装http-server</p>\n<pre><code>npm install http-server -g\n</code></pre><p>启动服务“http-server -p 8000” 设置端口为8000.避免jenkins端口冲突<br>在/Users/XXX/Public 目录下面建立jenkins目录，把构建后的apk复制到/Users/XXX/Public/jenkins/apk/目录下面<br>然后把二维码图片也复制到/Users/XXX/Public/jenkins</p>\n<blockquote>\n<p>为什么要http-server服务</p>\n</blockquote>\n<p>因为在jenkins里的图片在邮件里是没有办法直接显示的。必须要有一个没有拦截的访问路径。以避开jenkins的用户验证。同理apk的下载也是如此<br>不过一般都是部署在局域网内。安全性还是有保障的。如果要发布到外网的可以使用第三方服务上传apk包生成公网下载二维码。</p>\n<h4 id=\"安装pip（MAC）（python-gt-3-1）-如果版本不够看”其他“\"><a href=\"#安装pip（MAC）（python-gt-3-1）-如果版本不够看”其他“\" class=\"headerlink\" title=\"安装pip（MAC）（python&gt;3.1）[如果版本不够看”其他“]\"></a>安装pip（MAC）（python&gt;3.1）[如果版本不够看”其他“]</h4><pre><code>sudo easy_install pip\n</code></pre><p><a href=\"https://jingyan.baidu.com/article/ca2d939d6299eaeb6c31cee2.html\" target=\"_blank\" rel=\"noopener\">mac下安装pip</a></p>\n<p><a href=\"http://www.cnblogs.com/yuanzm/p/4089856.html\" target=\"_blank\" rel=\"noopener\">windows下面安装Python和pip终极教程</a></p>\n<h4 id=\"安装myqr\"><a href=\"#安装myqr\" class=\"headerlink\" title=\"安装myqr\"></a>安装myqr</h4><pre><code>命令1：pip install Pillow （失败）\n命令2：pip install -I --no-cache-dir -v Pillow （成功）\n至于为什么失败，解释颇多也不想深究。暂且都记上多试试。\n安装qrcode 命令：pip install myqr\n</code></pre><p>生成二维码命令<br>    myqr <a href=\"http://localhost:8000/jenkins/apk/XXXX.apk\" target=\"_blank\" rel=\"noopener\">http://localhost:8000/jenkins/apk/XXXX.apk</a> -n jenkins-qrcode-${JOB_NAME}.png -v 1 -l L -d /Users/XXX/Public/jenkins</p>\n<h3 id=\"Jenkins邮件通知配置\"><a href=\"#Jenkins邮件通知配置\" class=\"headerlink\" title=\"Jenkins邮件通知配置\"></a>Jenkins邮件通知配置</h3><p>在邮件配置content字段里添加</p>\n<pre><code>&lt;img src=&quot;http://localhost:8000/jenkins/jenkins-qrcode-${JOB_NAME}.png &quot; width=&quot;200px&quot; height=&quot;200px&quot; /&gt;&lt;/br&gt;&lt;/hr&gt;\n&lt;a href=&apos;http://localhost:8000/jenkins/apk/XXXX.apk&apos;&gt;点击下载apk&lt;/a&gt;\n</code></pre><p>邮件通知配置样例<br>    <hr></p>\n<pre><code>(本邮件是程序自动下发的，请勿回复！)&lt;br/&gt;&lt;hr/&gt;\n\n项目名称：$PROJECT_NAME&lt;br/&gt;&lt;hr/&gt;\n\n构建编号：$BUILD_NUMBER&lt;br/&gt;&lt;hr/&gt;\n\n构建状态：$BUILD_STATUS&lt;br/&gt;&lt;hr/&gt;\n\n触发原因：${CAUSE}&lt;br/&gt;&lt;hr/&gt;\n\n扫描二维码下载&lt;img src=&quot;http://192.168.10.214:8000/JenkinsApk/jenkins-qrcode-${JOB_NAME}.png&quot; width=&quot;200px&quot; height=&quot;200px&quot;/&gt; &lt;br/&gt;&lt;hr/&gt;\n&lt;a href=&quot;http://192.168.10.214:8000/JenkinsApk/apk/${JOB_NAME}-Debug-${BUILD_NUMBER}.apk&quot;&gt;点击下载${JOB_NAME}-Debug-${BUILD_NUMBER}.apk&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n构建日志地址：&lt;a href=&quot;${BUILD_URL}console&quot;&gt;${BUILD_URL}console&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n\n构建地址：&lt;a href=&quot;$BUILD_URL&quot;&gt;$BUILD_URL&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n\n变更集:${JELLY_SCRIPT,template=&quot;html&quot;}&lt;br/&gt;&lt;hr/&gt;\n</code></pre><p>参考：<br><a href=\"https://www.jianshu.com/p/915c1ae69144\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/915c1ae69144</a></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>【MAC】</p>\n<blockquote>\n<p>“OSError: [Errno 13] Permission denied: ‘/Library/Python/2.7/site-packages/PIL’”</p>\n</blockquote>\n<p><strong>使用 sudo pip install -I –no-cache-dir -v Pillow 命令安装</strong></p>\n<blockquote>\n<p>mac OSError: [Errno 1] Operation not permitted: ‘/tmp/pip-ZaNR4Q-uninstall/System/Library/Frameworks</p>\n</blockquote>\n<p>升级python 版本</p>\n<pre><code>$ pip install --upgrade pip\n$ sudo pip install numpy --upgrade --ignore-installed\n$ sudo pip install scipy --upgrade --ignore-installed\n$ sudo pip install scikit-learn --upgrade --ignore-installed\n</code></pre><p>参考<a href=\"https://www.jianshu.com/p/7a18c78b5982\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/7a18c78b5982</a></p>\n<blockquote>\n<p>OSError: [Errno 13] Permission denied: ‘/Library/Python/2.7/site-packages/imageio-2.3.0.dist-info’<br>解决方法：<br><strong>sudo pip install myqr</strong></p>\n</blockquote>\n<blockquote>\n<p>matplotlib 1.3.1 requires nose, which is not installed.<br>matplotlib 1.3.1 requires tornado, which is not installed.</p>\n</blockquote>\n<p>解决方法：运行sudo pip install matplotlib</p>\n<h2 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h2><blockquote>\n<p>Email:<a href=\"mailto:lichongmac@163.com\" target=\"_blank\" rel=\"noopener\">lichongmac@163.com</a></p>\n</blockquote>\n<p>支付宝打赏：<a href=\"https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1UMWjU1FHv7hYpdlcCQrJ3A</a></p>\n<p>微信打赏：<a href=\"https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1dSBXk3eFZu3mAMkw3xu9KQ</a></p>\n<p>公众号推荐：</p>\n<p><img src=\"http://i2.51cto.com/images/blog/201805/11/0e2ece55187caabd7b246e9550a8d5a0.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=\" alt></p>\n"},{"title":"网络图片加载工具","date":"2017-04-12T11:58:32.000Z","_content":"## 《Android-Universal-Image-Loader》\n##### 1、 数据结构分析\n\n\n\t/** Stores not strong references to objects */\n\tprivate final Map<String, Reference<Bitmap>> softMap = Collections.synchronizedMap(new HashMap<String, Reference<Bitmap>>());\n\t\n\tprivate final List<Bitmap> hardCache = Collections.synchronizedList(new LinkedList<Bitmap>());\n\t\nLinkedHashMap中的get()方法不仅返回所匹配的值，并且在返回前还会将所匹配的key对应的entry调整在列表中的顺序（LinkedHashMap使用双链表来保存数据），让它处于列表的最后。当然，这种情况必须是在LinkedHashMap中accessOrder==true的情况下才生效的，反之就是get()方法不会改变被匹配的key对应的entry在列表中的位置\n\nLinkedHashMap:\n\t\n\t根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。  \n\t\n\t默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。  可以重写removeEldestEntry方法返回true值指定插入元素时移除最老的元素。 \n\n\n\n##### 2、 缓存策略分析\nUIL中的内存缓存策略\n\n\t1. 只使用的是强引用缓存 \n\t\n\tLruMemoryCache（这个类就是这个开源框架默认的内存缓存类，缓存的是bitmap的强引用，下面我会从源码上面分析这个类）\n\t 2.使用强引用和弱引用相结合的缓存有\n\t\n\t UsingFreqLimitedMemoryCache（如果缓存的图片总量超过限定值，先删除使用频率最小的bitmap）\n\t\n\tLRULimitedMemoryCache（这个也是使用的lru算法，和LruMemoryCache不同的是，他缓存的是bitmap的弱引用）\n\tFIFOLimitedMemoryCache（先进先出的缓存策略，当超过设定值，先删除最先加入缓存的bitmap）\n\tLargestLimitedMemoryCache(当超过缓存限定值，先删除最大的bitmap对象)\n\tLimitedAgeMemoryCache（当 bitmap加入缓存中的时间超过我们设定的值，将其删除）\n\t 3.只使用弱引用缓存\n\t\n\t WeakMemoryCache（这个类缓存bitmap的总大小没有限制，唯一不足的地方就是不稳定，缓存的图片容易被回收掉）\n\n \n\n我们直接选择UIL中的默认配置缓存策略进行分析。\n\nImageLoaderConfiguration config = ImageLoaderConfiguration.createDefault(context);\nImageLoaderConfiguration.createDefault(…)这个方法最后是调用Builder.build()方法创建默认的配置参数的。默认的内存缓存实现是LruMemoryCache，磁盘缓存是UnlimitedDiscCache。\n\n业务如下\n\n\t① UI：请求数据，使用唯一的Key值索引Memory Cache中的Bitmap。\n\t\n\t② 内存缓存：缓存搜索，如果能找到Key值对应的Bitmap，则返回数据。否则执行第三步。\n\t\n\t③ 硬盘存储：使用唯一Key值对应的文件名，检索SDCard上的文件。\n\t\n\t④ 如果有对应文件，使用BitmapFactory.decode*方法，解码Bitmap并返回数据，同时将数据写入缓存。如果没有对应文件，执行第五步。\n\t\n\t⑤ 下载图片：启动异步线程，从数据源下载数据(Web)。\n\t\n\t⑥ 若下载成功，将数据同时写入硬盘和缓存，并将Bitmap显示在UI中。\n\n\n##### 3、 设计模式应用分析\n1. 单例模式的应用在\n2. builder模式\n\n\n##### 4、 线程池\n线程池能够带来三个好处：\n\t\n\t第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗\n\t第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行\n\t第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控\n\t\n\n**创建一个ThreadPoolExecutor需要的参数：**\n\n\tcorePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。\n\t\n\trunnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。\n\t\n\tArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。\n\t\n\tLinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。\n\t\n\tSynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。\n\t\n\tPriorityBlockingQueue：一个具有优先级的无限阻塞队列。\n\t\n\tmaximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。\n\t\n\tThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。\n\t\n\tRejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。\n\t\t# AbortPolicy：直接抛出异常。\n\t\t# CallerRunsPolicy：只用调用者所在线程来运行任务。\n\t\t# DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。\n\t\t# DiscardPolicy：不处理，丢弃掉。\n\t当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。\n\t\n\tkeepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。\n\t\n\tTimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。\n\t\n**用Executors静态工厂方法创建的线程池类型：**\n\t    \n    a) newFixedThreadPool：创建一个定长的线程池。达到最大线程数后，线程数不再增长。如果一个线程由于非预期Exception而结束，线程池会补充一个新的线程。\n    \n    b) newCachedThreadPool：创建一个可缓存的线程池。当池长度超过处理需求时，可以回收空闲的线程。\n    \n    c) newSingleThreadPool：创建一个单线程executor。\n    \n    d) newScheduledThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行。类似于Timer。但是，Timer是基于绝对时间，对系统时钟的改变是敏感的，而ScheduledThreadPoolExecutor只支持相对时间。\n\t     1) Timer是创建唯一的线程来执行所有的timer任务。如果一个任务超时了，会导致其他的TimerTask时间准确性出问题。\n\t     2）如果TimerTask抛出uncheck 异常，Timer将会产生无法预料的行为。因此，ScheduledThreadPoolExecutor可以完全代替Timer。\n\t     \n**合理的配置线程池**\n\t\n\t要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：\n\t\n\t任务的性质：CPU密集型任务，IO密集型任务和混合型任务。\n\t任务的优先级：高，中和低。\n\t任务的执行时间：长，中和短。\n\t任务的依赖性：是否依赖其他系统资源，如数据库连接。\n\t\n\t任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。\n\t\n\t优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。\n\t\n\t执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。\n\t\n\t依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。\n\t\n\t建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。","source":"_posts/framework-imageloader.md","raw":"---\ntitle: 网络图片加载工具\ndate: 2017-04-12 19:58:32\ntags: 开源框架 内存策略 缓存策略 android\n---\n## 《Android-Universal-Image-Loader》\n##### 1、 数据结构分析\n\n\n\t/** Stores not strong references to objects */\n\tprivate final Map<String, Reference<Bitmap>> softMap = Collections.synchronizedMap(new HashMap<String, Reference<Bitmap>>());\n\t\n\tprivate final List<Bitmap> hardCache = Collections.synchronizedList(new LinkedList<Bitmap>());\n\t\nLinkedHashMap中的get()方法不仅返回所匹配的值，并且在返回前还会将所匹配的key对应的entry调整在列表中的顺序（LinkedHashMap使用双链表来保存数据），让它处于列表的最后。当然，这种情况必须是在LinkedHashMap中accessOrder==true的情况下才生效的，反之就是get()方法不会改变被匹配的key对应的entry在列表中的位置\n\nLinkedHashMap:\n\t\n\t根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。  \n\t\n\t默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。  可以重写removeEldestEntry方法返回true值指定插入元素时移除最老的元素。 \n\n\n\n##### 2、 缓存策略分析\nUIL中的内存缓存策略\n\n\t1. 只使用的是强引用缓存 \n\t\n\tLruMemoryCache（这个类就是这个开源框架默认的内存缓存类，缓存的是bitmap的强引用，下面我会从源码上面分析这个类）\n\t 2.使用强引用和弱引用相结合的缓存有\n\t\n\t UsingFreqLimitedMemoryCache（如果缓存的图片总量超过限定值，先删除使用频率最小的bitmap）\n\t\n\tLRULimitedMemoryCache（这个也是使用的lru算法，和LruMemoryCache不同的是，他缓存的是bitmap的弱引用）\n\tFIFOLimitedMemoryCache（先进先出的缓存策略，当超过设定值，先删除最先加入缓存的bitmap）\n\tLargestLimitedMemoryCache(当超过缓存限定值，先删除最大的bitmap对象)\n\tLimitedAgeMemoryCache（当 bitmap加入缓存中的时间超过我们设定的值，将其删除）\n\t 3.只使用弱引用缓存\n\t\n\t WeakMemoryCache（这个类缓存bitmap的总大小没有限制，唯一不足的地方就是不稳定，缓存的图片容易被回收掉）\n\n \n\n我们直接选择UIL中的默认配置缓存策略进行分析。\n\nImageLoaderConfiguration config = ImageLoaderConfiguration.createDefault(context);\nImageLoaderConfiguration.createDefault(…)这个方法最后是调用Builder.build()方法创建默认的配置参数的。默认的内存缓存实现是LruMemoryCache，磁盘缓存是UnlimitedDiscCache。\n\n业务如下\n\n\t① UI：请求数据，使用唯一的Key值索引Memory Cache中的Bitmap。\n\t\n\t② 内存缓存：缓存搜索，如果能找到Key值对应的Bitmap，则返回数据。否则执行第三步。\n\t\n\t③ 硬盘存储：使用唯一Key值对应的文件名，检索SDCard上的文件。\n\t\n\t④ 如果有对应文件，使用BitmapFactory.decode*方法，解码Bitmap并返回数据，同时将数据写入缓存。如果没有对应文件，执行第五步。\n\t\n\t⑤ 下载图片：启动异步线程，从数据源下载数据(Web)。\n\t\n\t⑥ 若下载成功，将数据同时写入硬盘和缓存，并将Bitmap显示在UI中。\n\n\n##### 3、 设计模式应用分析\n1. 单例模式的应用在\n2. builder模式\n\n\n##### 4、 线程池\n线程池能够带来三个好处：\n\t\n\t第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗\n\t第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行\n\t第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控\n\t\n\n**创建一个ThreadPoolExecutor需要的参数：**\n\n\tcorePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。\n\t\n\trunnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。\n\t\n\tArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。\n\t\n\tLinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。\n\t\n\tSynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。\n\t\n\tPriorityBlockingQueue：一个具有优先级的无限阻塞队列。\n\t\n\tmaximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。\n\t\n\tThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。\n\t\n\tRejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。\n\t\t# AbortPolicy：直接抛出异常。\n\t\t# CallerRunsPolicy：只用调用者所在线程来运行任务。\n\t\t# DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。\n\t\t# DiscardPolicy：不处理，丢弃掉。\n\t当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。\n\t\n\tkeepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。\n\t\n\tTimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。\n\t\n**用Executors静态工厂方法创建的线程池类型：**\n\t    \n    a) newFixedThreadPool：创建一个定长的线程池。达到最大线程数后，线程数不再增长。如果一个线程由于非预期Exception而结束，线程池会补充一个新的线程。\n    \n    b) newCachedThreadPool：创建一个可缓存的线程池。当池长度超过处理需求时，可以回收空闲的线程。\n    \n    c) newSingleThreadPool：创建一个单线程executor。\n    \n    d) newScheduledThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行。类似于Timer。但是，Timer是基于绝对时间，对系统时钟的改变是敏感的，而ScheduledThreadPoolExecutor只支持相对时间。\n\t     1) Timer是创建唯一的线程来执行所有的timer任务。如果一个任务超时了，会导致其他的TimerTask时间准确性出问题。\n\t     2）如果TimerTask抛出uncheck 异常，Timer将会产生无法预料的行为。因此，ScheduledThreadPoolExecutor可以完全代替Timer。\n\t     \n**合理的配置线程池**\n\t\n\t要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：\n\t\n\t任务的性质：CPU密集型任务，IO密集型任务和混合型任务。\n\t任务的优先级：高，中和低。\n\t任务的执行时间：长，中和短。\n\t任务的依赖性：是否依赖其他系统资源，如数据库连接。\n\t\n\t任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。\n\t\n\t优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。\n\t\n\t执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。\n\t\n\t依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。\n\t\n\t建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。","slug":"framework-imageloader","published":1,"updated":"2017-11-01T13:36:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416ssg001480s6nbugxq3h","content":"<h2 id=\"《Android-Universal-Image-Loader》\"><a href=\"#《Android-Universal-Image-Loader》\" class=\"headerlink\" title=\"《Android-Universal-Image-Loader》\"></a>《Android-Universal-Image-Loader》</h2><h5 id=\"1、-数据结构分析\"><a href=\"#1、-数据结构分析\" class=\"headerlink\" title=\"1、 数据结构分析\"></a>1、 数据结构分析</h5><pre><code>/** Stores not strong references to objects */\nprivate final Map&lt;String, Reference&lt;Bitmap&gt;&gt; softMap = Collections.synchronizedMap(new HashMap&lt;String, Reference&lt;Bitmap&gt;&gt;());\n\nprivate final List&lt;Bitmap&gt; hardCache = Collections.synchronizedList(new LinkedList&lt;Bitmap&gt;());\n</code></pre><p>LinkedHashMap中的get()方法不仅返回所匹配的值，并且在返回前还会将所匹配的key对应的entry调整在列表中的顺序（LinkedHashMap使用双链表来保存数据），让它处于列表的最后。当然，这种情况必须是在LinkedHashMap中accessOrder==true的情况下才生效的，反之就是get()方法不会改变被匹配的key对应的entry在列表中的位置</p>\n<p>LinkedHashMap:</p>\n<pre><code>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。  \n\n默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。  可以重写removeEldestEntry方法返回true值指定插入元素时移除最老的元素。 \n</code></pre><h5 id=\"2、-缓存策略分析\"><a href=\"#2、-缓存策略分析\" class=\"headerlink\" title=\"2、 缓存策略分析\"></a>2、 缓存策略分析</h5><p>UIL中的内存缓存策略</p>\n<pre><code>1. 只使用的是强引用缓存 \n\nLruMemoryCache（这个类就是这个开源框架默认的内存缓存类，缓存的是bitmap的强引用，下面我会从源码上面分析这个类）\n 2.使用强引用和弱引用相结合的缓存有\n\n UsingFreqLimitedMemoryCache（如果缓存的图片总量超过限定值，先删除使用频率最小的bitmap）\n\nLRULimitedMemoryCache（这个也是使用的lru算法，和LruMemoryCache不同的是，他缓存的是bitmap的弱引用）\nFIFOLimitedMemoryCache（先进先出的缓存策略，当超过设定值，先删除最先加入缓存的bitmap）\nLargestLimitedMemoryCache(当超过缓存限定值，先删除最大的bitmap对象)\nLimitedAgeMemoryCache（当 bitmap加入缓存中的时间超过我们设定的值，将其删除）\n 3.只使用弱引用缓存\n\n WeakMemoryCache（这个类缓存bitmap的总大小没有限制，唯一不足的地方就是不稳定，缓存的图片容易被回收掉）\n</code></pre><p>我们直接选择UIL中的默认配置缓存策略进行分析。</p>\n<p>ImageLoaderConfiguration config = ImageLoaderConfiguration.createDefault(context);<br>ImageLoaderConfiguration.createDefault(…)这个方法最后是调用Builder.build()方法创建默认的配置参数的。默认的内存缓存实现是LruMemoryCache，磁盘缓存是UnlimitedDiscCache。</p>\n<p>业务如下</p>\n<pre><code>① UI：请求数据，使用唯一的Key值索引Memory Cache中的Bitmap。\n\n② 内存缓存：缓存搜索，如果能找到Key值对应的Bitmap，则返回数据。否则执行第三步。\n\n③ 硬盘存储：使用唯一Key值对应的文件名，检索SDCard上的文件。\n\n④ 如果有对应文件，使用BitmapFactory.decode*方法，解码Bitmap并返回数据，同时将数据写入缓存。如果没有对应文件，执行第五步。\n\n⑤ 下载图片：启动异步线程，从数据源下载数据(Web)。\n\n⑥ 若下载成功，将数据同时写入硬盘和缓存，并将Bitmap显示在UI中。\n</code></pre><h5 id=\"3、-设计模式应用分析\"><a href=\"#3、-设计模式应用分析\" class=\"headerlink\" title=\"3、 设计模式应用分析\"></a>3、 设计模式应用分析</h5><ol>\n<li>单例模式的应用在</li>\n<li>builder模式</li>\n</ol>\n<h5 id=\"4、-线程池\"><a href=\"#4、-线程池\" class=\"headerlink\" title=\"4、 线程池\"></a>4、 线程池</h5><p>线程池能够带来三个好处：</p>\n<pre><code>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗\n第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行\n第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控\n</code></pre><p><strong>创建一个ThreadPoolExecutor需要的参数：</strong></p>\n<pre><code>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。\n\nrunnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。\n\nArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。\n\nLinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。\n\nSynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。\n\nPriorityBlockingQueue：一个具有优先级的无限阻塞队列。\n\nmaximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。\n\nThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。\n\nRejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。\n    # AbortPolicy：直接抛出异常。\n    # CallerRunsPolicy：只用调用者所在线程来运行任务。\n    # DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。\n    # DiscardPolicy：不处理，丢弃掉。\n当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。\n\nkeepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。\n\nTimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。\n</code></pre><p><strong>用Executors静态工厂方法创建的线程池类型：</strong></p>\n<pre><code>a) newFixedThreadPool：创建一个定长的线程池。达到最大线程数后，线程数不再增长。如果一个线程由于非预期Exception而结束，线程池会补充一个新的线程。\n\nb) newCachedThreadPool：创建一个可缓存的线程池。当池长度超过处理需求时，可以回收空闲的线程。\n\nc) newSingleThreadPool：创建一个单线程executor。\n\nd) newScheduledThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行。类似于Timer。但是，Timer是基于绝对时间，对系统时钟的改变是敏感的，而ScheduledThreadPoolExecutor只支持相对时间。\n     1) Timer是创建唯一的线程来执行所有的timer任务。如果一个任务超时了，会导致其他的TimerTask时间准确性出问题。\n     2）如果TimerTask抛出uncheck 异常，Timer将会产生无法预料的行为。因此，ScheduledThreadPoolExecutor可以完全代替Timer。\n</code></pre><p><strong>合理的配置线程池</strong></p>\n<pre><code>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：\n\n任务的性质：CPU密集型任务，IO密集型任务和混合型任务。\n任务的优先级：高，中和低。\n任务的执行时间：长，中和短。\n任务的依赖性：是否依赖其他系统资源，如数据库连接。\n\n任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。\n\n优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。\n\n执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。\n\n依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。\n\n建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"《Android-Universal-Image-Loader》\"><a href=\"#《Android-Universal-Image-Loader》\" class=\"headerlink\" title=\"《Android-Universal-Image-Loader》\"></a>《Android-Universal-Image-Loader》</h2><h5 id=\"1、-数据结构分析\"><a href=\"#1、-数据结构分析\" class=\"headerlink\" title=\"1、 数据结构分析\"></a>1、 数据结构分析</h5><pre><code>/** Stores not strong references to objects */\nprivate final Map&lt;String, Reference&lt;Bitmap&gt;&gt; softMap = Collections.synchronizedMap(new HashMap&lt;String, Reference&lt;Bitmap&gt;&gt;());\n\nprivate final List&lt;Bitmap&gt; hardCache = Collections.synchronizedList(new LinkedList&lt;Bitmap&gt;());\n</code></pre><p>LinkedHashMap中的get()方法不仅返回所匹配的值，并且在返回前还会将所匹配的key对应的entry调整在列表中的顺序（LinkedHashMap使用双链表来保存数据），让它处于列表的最后。当然，这种情况必须是在LinkedHashMap中accessOrder==true的情况下才生效的，反之就是get()方法不会改变被匹配的key对应的entry在列表中的位置</p>\n<p>LinkedHashMap:</p>\n<pre><code>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。  \n\n默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。  可以重写removeEldestEntry方法返回true值指定插入元素时移除最老的元素。 \n</code></pre><h5 id=\"2、-缓存策略分析\"><a href=\"#2、-缓存策略分析\" class=\"headerlink\" title=\"2、 缓存策略分析\"></a>2、 缓存策略分析</h5><p>UIL中的内存缓存策略</p>\n<pre><code>1. 只使用的是强引用缓存 \n\nLruMemoryCache（这个类就是这个开源框架默认的内存缓存类，缓存的是bitmap的强引用，下面我会从源码上面分析这个类）\n 2.使用强引用和弱引用相结合的缓存有\n\n UsingFreqLimitedMemoryCache（如果缓存的图片总量超过限定值，先删除使用频率最小的bitmap）\n\nLRULimitedMemoryCache（这个也是使用的lru算法，和LruMemoryCache不同的是，他缓存的是bitmap的弱引用）\nFIFOLimitedMemoryCache（先进先出的缓存策略，当超过设定值，先删除最先加入缓存的bitmap）\nLargestLimitedMemoryCache(当超过缓存限定值，先删除最大的bitmap对象)\nLimitedAgeMemoryCache（当 bitmap加入缓存中的时间超过我们设定的值，将其删除）\n 3.只使用弱引用缓存\n\n WeakMemoryCache（这个类缓存bitmap的总大小没有限制，唯一不足的地方就是不稳定，缓存的图片容易被回收掉）\n</code></pre><p>我们直接选择UIL中的默认配置缓存策略进行分析。</p>\n<p>ImageLoaderConfiguration config = ImageLoaderConfiguration.createDefault(context);<br>ImageLoaderConfiguration.createDefault(…)这个方法最后是调用Builder.build()方法创建默认的配置参数的。默认的内存缓存实现是LruMemoryCache，磁盘缓存是UnlimitedDiscCache。</p>\n<p>业务如下</p>\n<pre><code>① UI：请求数据，使用唯一的Key值索引Memory Cache中的Bitmap。\n\n② 内存缓存：缓存搜索，如果能找到Key值对应的Bitmap，则返回数据。否则执行第三步。\n\n③ 硬盘存储：使用唯一Key值对应的文件名，检索SDCard上的文件。\n\n④ 如果有对应文件，使用BitmapFactory.decode*方法，解码Bitmap并返回数据，同时将数据写入缓存。如果没有对应文件，执行第五步。\n\n⑤ 下载图片：启动异步线程，从数据源下载数据(Web)。\n\n⑥ 若下载成功，将数据同时写入硬盘和缓存，并将Bitmap显示在UI中。\n</code></pre><h5 id=\"3、-设计模式应用分析\"><a href=\"#3、-设计模式应用分析\" class=\"headerlink\" title=\"3、 设计模式应用分析\"></a>3、 设计模式应用分析</h5><ol>\n<li>单例模式的应用在</li>\n<li>builder模式</li>\n</ol>\n<h5 id=\"4、-线程池\"><a href=\"#4、-线程池\" class=\"headerlink\" title=\"4、 线程池\"></a>4、 线程池</h5><p>线程池能够带来三个好处：</p>\n<pre><code>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗\n第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行\n第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控\n</code></pre><p><strong>创建一个ThreadPoolExecutor需要的参数：</strong></p>\n<pre><code>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。\n\nrunnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。\n\nArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。\n\nLinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。\n\nSynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。\n\nPriorityBlockingQueue：一个具有优先级的无限阻塞队列。\n\nmaximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。\n\nThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。\n\nRejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。\n    # AbortPolicy：直接抛出异常。\n    # CallerRunsPolicy：只用调用者所在线程来运行任务。\n    # DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。\n    # DiscardPolicy：不处理，丢弃掉。\n当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。\n\nkeepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。\n\nTimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。\n</code></pre><p><strong>用Executors静态工厂方法创建的线程池类型：</strong></p>\n<pre><code>a) newFixedThreadPool：创建一个定长的线程池。达到最大线程数后，线程数不再增长。如果一个线程由于非预期Exception而结束，线程池会补充一个新的线程。\n\nb) newCachedThreadPool：创建一个可缓存的线程池。当池长度超过处理需求时，可以回收空闲的线程。\n\nc) newSingleThreadPool：创建一个单线程executor。\n\nd) newScheduledThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行。类似于Timer。但是，Timer是基于绝对时间，对系统时钟的改变是敏感的，而ScheduledThreadPoolExecutor只支持相对时间。\n     1) Timer是创建唯一的线程来执行所有的timer任务。如果一个任务超时了，会导致其他的TimerTask时间准确性出问题。\n     2）如果TimerTask抛出uncheck 异常，Timer将会产生无法预料的行为。因此，ScheduledThreadPoolExecutor可以完全代替Timer。\n</code></pre><p><strong>合理的配置线程池</strong></p>\n<pre><code>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：\n\n任务的性质：CPU密集型任务，IO密集型任务和混合型任务。\n任务的优先级：高，中和低。\n任务的执行时间：长，中和短。\n任务的依赖性：是否依赖其他系统资源，如数据库连接。\n\n任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。\n\n优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。\n\n执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。\n\n依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。\n\n建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。\n</code></pre>"},{"title":"面试总结记录","date":"2017-04-27T12:10:01.000Z","_content":"## 1、 Android性能分析工具\n\t\n\t1.1 TraceView:\n\t\t最简单的方式就是直接打开DDMS，选择一个进程，然后按上面的“Start Method Profiling”按钮，\n\t\t第2种方式就是使用android.os.Debug.startMethodTracing();和android.os.Debug.stopMethodTracing();方法\n\t\t重要指标 Calls+Recur Calls／Total（方法执行的次数）；Cpu Time／Call（方法耗时）\n\t1.2 Eclipse Memory Analyzer Tool 内存使用\n\t\n\t1.3 Dump UI Hierarchy for UI Atomator 分析UI层级\n\t\n\t1.4 systrace\n\t\tSystrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。\n\t\tSystrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：\n\t\t内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。\n\t\t数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。\n\t\t数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。\n\t\n\t1.5 Oprofile：性能数据采集和分析工具\n\t\n\t1.6 Hierarchy Viewer（层级查看器）\n\t\n参考：*http://www.jianshu.com/p/da2a4bfcba68*\n\n\t1.7 Battery Historian \n\t\tGoogle出品, 通过Android系统的bugreport文件来做电量使用分析的工具\n\t\thttps://github.com/google/battery-historian\n\t1.8 NetEase/Emmagee\n\t\t针对Android App的CPU, 内存, 网络, 电量等多项综合的测试分析.\n\t\thttps://github.com/NetEase/Emmagee\n\t\t\n\t1.9 Square\n\t\tSquare出品, 必属精品.\n\t\t类似与App探针的内存泄露监测工具.\n\t\thttps://github.com/square/leakcanary\n\t\t\n\t1.10 AndroidDevMetrics\n\t\t一个library, 用来检测Activity生命周期执行性能, Dagger2注入性能以及帧率性能的工具\n\t\thttps://github.com/frogermcs/AndroidDevMetrics\n\n2、 Android内存优化方案\n\n\t2.1 Android应用String/StringBuilder/StringBuffer优化建议\n\t字符串操作在Android应用开发中是十分常见的操作，也就是这个最简单的字符串操作却也暗藏很多潜在的性能问题，下面我们实例来说说。\n\t先看下面这个关于String和StringBuffer的对比例子：\n\t//性能差的实现\n\tString str1 = \"Name:\";\n\tString str2 = \"GJRS\";\n\tString Str = str1 + str2;\n\t//性能好的实现\n\tString str1 = \"Name:\";\n\tString str2 = \"GJRS\";\n\tStringBuffer str = new StringBuilder().append(str1).append(str2);\n\t\n\t通过这个例子可以看出来，String对象（记得是对象，不是常量）和StringBuffer对象的主要性能区别在于String对象是不可变的，所以每次对String对象做改变操作（譬如“+”操作）时其实都生成了新的String对象实例，所以会导致内存消耗性能问题；而StringBuffer对象做改变操作每次都会对自己进行操作，所以不需要消耗额外的内存空间。\n\t\n\t我们再看一个关于String和StringBuffer的对比例子：\n\t//性能差的实现\n\tStringBuffer str = new StringBuilder().append(\"Name:\").append(\"GJRS\");\n\t//性能好的实现\n\tString Str = \"Name:\" + \"GJRS\";\n\t在这种情况下你会发现StringBuffer的性能反而没有String的好，原因是在JVM解释时认为 \n\tString Str = \"Name:\" + \"GJRS\";就是String Str = \"Name:GJRS\";，所以自然比StringBuffer快了。\n\t可以发现，如果我们拼接的是字符串常量则String效率比StringBuffer高，如果拼接的是字符串对象，则StringBuffer比String效率高，我们在开发中要酌情选择。当然，除过注意StringBuffer和String的效率问题，我们还应该注意另一个问题，那就是StringBuffer和StringBuilder的区别，其实StringBuffer和StringBuilder都继承自同一个父类，只是StringBuffer是线程安全的，也就是说在不考虑多线程情况下StringBuilder的性能又比StringBuffer高。\n\tPS：如果想追究清楚他们之间具体细节差异，麻烦自己查看实现源码即可\n\n\t2.2 Android应用HashMap与ArrayMap及SparseArray优化建议\n\t在Android开发中涉及到数据逻辑部分大部分用的都是Java的API（譬如HashMap），但是对于Android设备来说有些Java的API并不适合，可能会导致系统性能下降，好在Google团队已经意识到这些问题，所以他们针对Android设备对Java的一些API进行了优化，优化最多就是使用了ArrayMap及SparseArray替代HashMap来获得性能提升。\n\t\n\tHashMap：\n\tHashMap内部使用一个默认容量为16的数组来存储数据，数组中每一个元素存放一个链表的头结点，其实整个HashMap内部结构就是一个哈希表的拉链结构。HashMap默认实现的扩容是以2倍增加，且获取一个节点采用了遍历法，所以相对来说无论从内存消耗还是节点查找上都是十分昂贵的。\n\t\n\tSparseArray：\n\tSparseArray比HashMap省内存是因为它避免了对Key进行自动装箱（int转Integer），它内部是用两个数组来进行数据存储的（一个存Key，一个存Value），它内部对数据采用了压缩方式来表示稀疏数组数据，从而节约内存空间，而且其查找节点的实现采用了二分法，很明显可以看见性能的提升。\n\t\n\tArrayMap：\n\tArrayMap内部使用两个数组进行数据存储，一个记录Key的Hash值，一个记录Value值，它和SparseArray类似，也会在查找时对Key采用二分法。\n\t有了上面的基本了解我们可以得出结论供开发时参考，当数据量不大（千位级内）且Key为int类型时使用SparseArray替换HashMap效率高；当数据量不大（千位级内）且数据类型为Map类型时使用ArrayMap替换HashMap效率高；其他情况下HashMap效率相对高于二者\n\t\n\t2.3 Android应用ContentProviderOperation优化建议\n\tContentProvider是Android应用开发的核心组件之一，有时候在开发中需要使用ContentProvider对多行数据进行操作，我们的做法一般是多次调运相关操作方法，殊不知这种实现方式是非常低性能的，取而代之的做法应该是使用批量操作，具体为了使批量更新、插入、删除数据操作更加方便官方提供了ContentProviderOperation工具类。所以在我们开发中遇到类似情景时请务必使用批量操作，具体的优势如下：\n\t所有的操作都在一个事务中执行，可以保证数据的完整性。\n\t批量操作在一个事务中执行，所以只用打开、关闭一个事务。\n\t减轻应用程序与ContentProvider间的多次频繁交互，提升性能。\n\t可以看见，这对于数据库操作来说是一个非常有用的优化措施，烦请务必重视（我们项目优化过，的确有很大提升）\n\n\t2.4 其他逻辑优化\n\t避免在Android中使用Java的枚举类型，因为编译后不但占空间，加载也费时，完全没有static final的变量好用、高效。\n\n\tHandler发送消息时尽量使用obtain去获取已经存在的Message对象进行复用，而不是新new Message对象，这样可以减轻内存压力。\n\t\n\t在使用后台Service时尽量将能够替换为IntentService的地方替换为此，这样可以减轻系统压力、省电、省内存、省CPU占用率。\n\t\n\t在当前类内部尽量不要通过自己的getXXX、setXXX对自己内部成员进行操作，而是直接使用，这样可以提高代码执行效率。\n\t\n\t不要一味的为了设计模式而过分的抽象代码，因为代码抽象系数与代码加载执行时间成正比。\n\t\n\t尽量减少锁个数、减小锁范围，避免造成性能问题。\n\t\n\t合理的选择使用for循环与增强型for循环，譬如不要在ArrayList上使用增强型for循环等。\n3、 Android UI性能优化方案\n\n4、 设计模式\n\n5、 Android网络访问框架选型和优化\n\t\n\t5.1 volley\n\t5.2 retrofit\n\t5.3 andrid-async-http\n\t\n\t\n\n6、 Bug解决系统：Bugly；BugTags；GT；iTest；Emmagee；\n\n7、 Android应用移动设备电池耗电性能分析\n\n有了UI性能优化、内存性能优化、代码编写优化之后我们在来说说应用开发中很重要的一个优化模块—–电量优化。\n\n7.1 Android应用耗电量概念\n\n在盒子等开发时可能电量优化不是特别重视（视盒子待机真假待机模式而定），但是在移动设备开发中耗电量是一个非常重要的指标，如果用户一旦发现我们的应用非常耗电，不好意思，他们大多会选择卸载来解决此类问题，所以耗电量是一个十分重要的问题。\n\n关于我们应用的耗电量情况我们可以进行定长时间测试，至于具体的耗电量统计等请参考此文，同时我们还可以直接通过Battery Historian Tool来查看详细的应用电量消耗情况。最简单常用办法是通过命令直接查看，如下：\n\nadb shell dumpsys batterystats\n\n其实我们一款应用耗电量最大的部分不是UI绘制显示等，常见耗电量最大原因基本都是因为网络数据交互、GPS定位、大量内存性能问题、冗余的后台线程和Service等造成。\n\n7.2 Android应用耗电量优化建议\n\n优化电量使用情况我们不仅可以使用系统提供的一些API去处理，还可以在平时编写代码时就养成好的习惯。具体的一些建议如下：\n\n在需要网络的应用中，执行某些操作前尽量先进行网络状态判断。\n\n在网络应用传输中使用高效率的数据格式和解析方法，譬如JSON等。\n\n在传输用户反馈或者下载OTA升级包等不是十分紧急的操作时尽量采用压缩数据进行传输且延迟到设备充电和WIFI状态时进行。\n\n在有必要的情况下尽量通过PowerManager.WakeLock和JobScheduler来控制一些逻辑操作达到省电优化。\n\n对定位要求不太高的场景尽量使用网络定位，而不是GPS定位。\n\n对于定时任务尽量使用AlarmManager，而不是sleep或者Timer进行管理。\n\n尽可能的减少网络请求次数和减小网络请求时间间隔。\n\n后台任务要尽可能少的唤醒CPU，譬如IM通信的长连接心跳时间间隔、一些应用的后台定时唤醒时间间隔等要设计合理。\n\n特殊耗电业务情况可以进行弹窗等友好的交互设计提醒用户该操作会耗用过多电量。\n\n可以看见，上面只是一些常见的电量消耗优化建议。总之，作为应用开发者的我们要意识到电量损耗对于用户来说是非常敏感的，只有我们做到合理的电量优化才能赢得用户的芳心。","source":"_posts/resume.md","raw":"---\ntitle: 面试总结记录\ndate: 2017-04-27 20:10:01\ntags: android 面试\n---\n## 1、 Android性能分析工具\n\t\n\t1.1 TraceView:\n\t\t最简单的方式就是直接打开DDMS，选择一个进程，然后按上面的“Start Method Profiling”按钮，\n\t\t第2种方式就是使用android.os.Debug.startMethodTracing();和android.os.Debug.stopMethodTracing();方法\n\t\t重要指标 Calls+Recur Calls／Total（方法执行的次数）；Cpu Time／Call（方法耗时）\n\t1.2 Eclipse Memory Analyzer Tool 内存使用\n\t\n\t1.3 Dump UI Hierarchy for UI Atomator 分析UI层级\n\t\n\t1.4 systrace\n\t\tSystrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。\n\t\tSystrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：\n\t\t内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。\n\t\t数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。\n\t\t数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。\n\t\n\t1.5 Oprofile：性能数据采集和分析工具\n\t\n\t1.6 Hierarchy Viewer（层级查看器）\n\t\n参考：*http://www.jianshu.com/p/da2a4bfcba68*\n\n\t1.7 Battery Historian \n\t\tGoogle出品, 通过Android系统的bugreport文件来做电量使用分析的工具\n\t\thttps://github.com/google/battery-historian\n\t1.8 NetEase/Emmagee\n\t\t针对Android App的CPU, 内存, 网络, 电量等多项综合的测试分析.\n\t\thttps://github.com/NetEase/Emmagee\n\t\t\n\t1.9 Square\n\t\tSquare出品, 必属精品.\n\t\t类似与App探针的内存泄露监测工具.\n\t\thttps://github.com/square/leakcanary\n\t\t\n\t1.10 AndroidDevMetrics\n\t\t一个library, 用来检测Activity生命周期执行性能, Dagger2注入性能以及帧率性能的工具\n\t\thttps://github.com/frogermcs/AndroidDevMetrics\n\n2、 Android内存优化方案\n\n\t2.1 Android应用String/StringBuilder/StringBuffer优化建议\n\t字符串操作在Android应用开发中是十分常见的操作，也就是这个最简单的字符串操作却也暗藏很多潜在的性能问题，下面我们实例来说说。\n\t先看下面这个关于String和StringBuffer的对比例子：\n\t//性能差的实现\n\tString str1 = \"Name:\";\n\tString str2 = \"GJRS\";\n\tString Str = str1 + str2;\n\t//性能好的实现\n\tString str1 = \"Name:\";\n\tString str2 = \"GJRS\";\n\tStringBuffer str = new StringBuilder().append(str1).append(str2);\n\t\n\t通过这个例子可以看出来，String对象（记得是对象，不是常量）和StringBuffer对象的主要性能区别在于String对象是不可变的，所以每次对String对象做改变操作（譬如“+”操作）时其实都生成了新的String对象实例，所以会导致内存消耗性能问题；而StringBuffer对象做改变操作每次都会对自己进行操作，所以不需要消耗额外的内存空间。\n\t\n\t我们再看一个关于String和StringBuffer的对比例子：\n\t//性能差的实现\n\tStringBuffer str = new StringBuilder().append(\"Name:\").append(\"GJRS\");\n\t//性能好的实现\n\tString Str = \"Name:\" + \"GJRS\";\n\t在这种情况下你会发现StringBuffer的性能反而没有String的好，原因是在JVM解释时认为 \n\tString Str = \"Name:\" + \"GJRS\";就是String Str = \"Name:GJRS\";，所以自然比StringBuffer快了。\n\t可以发现，如果我们拼接的是字符串常量则String效率比StringBuffer高，如果拼接的是字符串对象，则StringBuffer比String效率高，我们在开发中要酌情选择。当然，除过注意StringBuffer和String的效率问题，我们还应该注意另一个问题，那就是StringBuffer和StringBuilder的区别，其实StringBuffer和StringBuilder都继承自同一个父类，只是StringBuffer是线程安全的，也就是说在不考虑多线程情况下StringBuilder的性能又比StringBuffer高。\n\tPS：如果想追究清楚他们之间具体细节差异，麻烦自己查看实现源码即可\n\n\t2.2 Android应用HashMap与ArrayMap及SparseArray优化建议\n\t在Android开发中涉及到数据逻辑部分大部分用的都是Java的API（譬如HashMap），但是对于Android设备来说有些Java的API并不适合，可能会导致系统性能下降，好在Google团队已经意识到这些问题，所以他们针对Android设备对Java的一些API进行了优化，优化最多就是使用了ArrayMap及SparseArray替代HashMap来获得性能提升。\n\t\n\tHashMap：\n\tHashMap内部使用一个默认容量为16的数组来存储数据，数组中每一个元素存放一个链表的头结点，其实整个HashMap内部结构就是一个哈希表的拉链结构。HashMap默认实现的扩容是以2倍增加，且获取一个节点采用了遍历法，所以相对来说无论从内存消耗还是节点查找上都是十分昂贵的。\n\t\n\tSparseArray：\n\tSparseArray比HashMap省内存是因为它避免了对Key进行自动装箱（int转Integer），它内部是用两个数组来进行数据存储的（一个存Key，一个存Value），它内部对数据采用了压缩方式来表示稀疏数组数据，从而节约内存空间，而且其查找节点的实现采用了二分法，很明显可以看见性能的提升。\n\t\n\tArrayMap：\n\tArrayMap内部使用两个数组进行数据存储，一个记录Key的Hash值，一个记录Value值，它和SparseArray类似，也会在查找时对Key采用二分法。\n\t有了上面的基本了解我们可以得出结论供开发时参考，当数据量不大（千位级内）且Key为int类型时使用SparseArray替换HashMap效率高；当数据量不大（千位级内）且数据类型为Map类型时使用ArrayMap替换HashMap效率高；其他情况下HashMap效率相对高于二者\n\t\n\t2.3 Android应用ContentProviderOperation优化建议\n\tContentProvider是Android应用开发的核心组件之一，有时候在开发中需要使用ContentProvider对多行数据进行操作，我们的做法一般是多次调运相关操作方法，殊不知这种实现方式是非常低性能的，取而代之的做法应该是使用批量操作，具体为了使批量更新、插入、删除数据操作更加方便官方提供了ContentProviderOperation工具类。所以在我们开发中遇到类似情景时请务必使用批量操作，具体的优势如下：\n\t所有的操作都在一个事务中执行，可以保证数据的完整性。\n\t批量操作在一个事务中执行，所以只用打开、关闭一个事务。\n\t减轻应用程序与ContentProvider间的多次频繁交互，提升性能。\n\t可以看见，这对于数据库操作来说是一个非常有用的优化措施，烦请务必重视（我们项目优化过，的确有很大提升）\n\n\t2.4 其他逻辑优化\n\t避免在Android中使用Java的枚举类型，因为编译后不但占空间，加载也费时，完全没有static final的变量好用、高效。\n\n\tHandler发送消息时尽量使用obtain去获取已经存在的Message对象进行复用，而不是新new Message对象，这样可以减轻内存压力。\n\t\n\t在使用后台Service时尽量将能够替换为IntentService的地方替换为此，这样可以减轻系统压力、省电、省内存、省CPU占用率。\n\t\n\t在当前类内部尽量不要通过自己的getXXX、setXXX对自己内部成员进行操作，而是直接使用，这样可以提高代码执行效率。\n\t\n\t不要一味的为了设计模式而过分的抽象代码，因为代码抽象系数与代码加载执行时间成正比。\n\t\n\t尽量减少锁个数、减小锁范围，避免造成性能问题。\n\t\n\t合理的选择使用for循环与增强型for循环，譬如不要在ArrayList上使用增强型for循环等。\n3、 Android UI性能优化方案\n\n4、 设计模式\n\n5、 Android网络访问框架选型和优化\n\t\n\t5.1 volley\n\t5.2 retrofit\n\t5.3 andrid-async-http\n\t\n\t\n\n6、 Bug解决系统：Bugly；BugTags；GT；iTest；Emmagee；\n\n7、 Android应用移动设备电池耗电性能分析\n\n有了UI性能优化、内存性能优化、代码编写优化之后我们在来说说应用开发中很重要的一个优化模块—–电量优化。\n\n7.1 Android应用耗电量概念\n\n在盒子等开发时可能电量优化不是特别重视（视盒子待机真假待机模式而定），但是在移动设备开发中耗电量是一个非常重要的指标，如果用户一旦发现我们的应用非常耗电，不好意思，他们大多会选择卸载来解决此类问题，所以耗电量是一个十分重要的问题。\n\n关于我们应用的耗电量情况我们可以进行定长时间测试，至于具体的耗电量统计等请参考此文，同时我们还可以直接通过Battery Historian Tool来查看详细的应用电量消耗情况。最简单常用办法是通过命令直接查看，如下：\n\nadb shell dumpsys batterystats\n\n其实我们一款应用耗电量最大的部分不是UI绘制显示等，常见耗电量最大原因基本都是因为网络数据交互、GPS定位、大量内存性能问题、冗余的后台线程和Service等造成。\n\n7.2 Android应用耗电量优化建议\n\n优化电量使用情况我们不仅可以使用系统提供的一些API去处理，还可以在平时编写代码时就养成好的习惯。具体的一些建议如下：\n\n在需要网络的应用中，执行某些操作前尽量先进行网络状态判断。\n\n在网络应用传输中使用高效率的数据格式和解析方法，譬如JSON等。\n\n在传输用户反馈或者下载OTA升级包等不是十分紧急的操作时尽量采用压缩数据进行传输且延迟到设备充电和WIFI状态时进行。\n\n在有必要的情况下尽量通过PowerManager.WakeLock和JobScheduler来控制一些逻辑操作达到省电优化。\n\n对定位要求不太高的场景尽量使用网络定位，而不是GPS定位。\n\n对于定时任务尽量使用AlarmManager，而不是sleep或者Timer进行管理。\n\n尽可能的减少网络请求次数和减小网络请求时间间隔。\n\n后台任务要尽可能少的唤醒CPU，譬如IM通信的长连接心跳时间间隔、一些应用的后台定时唤醒时间间隔等要设计合理。\n\n特殊耗电业务情况可以进行弹窗等友好的交互设计提醒用户该操作会耗用过多电量。\n\n可以看见，上面只是一些常见的电量消耗优化建议。总之，作为应用开发者的我们要意识到电量损耗对于用户来说是非常敏感的，只有我们做到合理的电量优化才能赢得用户的芳心。","slug":"resume","published":1,"updated":"2019-07-15T06:41:57.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416ssp001580s6xteeahyi","content":"<h2 id=\"1、-Android性能分析工具\"><a href=\"#1、-Android性能分析工具\" class=\"headerlink\" title=\"1、 Android性能分析工具\"></a>1、 Android性能分析工具</h2><pre><code>1.1 TraceView:\n    最简单的方式就是直接打开DDMS，选择一个进程，然后按上面的“Start Method Profiling”按钮，\n    第2种方式就是使用android.os.Debug.startMethodTracing();和android.os.Debug.stopMethodTracing();方法\n    重要指标 Calls+Recur Calls／Total（方法执行的次数）；Cpu Time／Call（方法耗时）\n1.2 Eclipse Memory Analyzer Tool 内存使用\n\n1.3 Dump UI Hierarchy for UI Atomator 分析UI层级\n\n1.4 systrace\n    Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。\n    Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：\n    内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。\n    数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。\n    数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。\n\n1.5 Oprofile：性能数据采集和分析工具\n\n1.6 Hierarchy Viewer（层级查看器）\n</code></pre><p>参考：<em><a href=\"http://www.jianshu.com/p/da2a4bfcba68\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/da2a4bfcba68</a></em></p>\n<pre><code>1.7 Battery Historian \n    Google出品, 通过Android系统的bugreport文件来做电量使用分析的工具\n    https://github.com/google/battery-historian\n1.8 NetEase/Emmagee\n    针对Android App的CPU, 内存, 网络, 电量等多项综合的测试分析.\n    https://github.com/NetEase/Emmagee\n\n1.9 Square\n    Square出品, 必属精品.\n    类似与App探针的内存泄露监测工具.\n    https://github.com/square/leakcanary\n\n1.10 AndroidDevMetrics\n    一个library, 用来检测Activity生命周期执行性能, Dagger2注入性能以及帧率性能的工具\n    https://github.com/frogermcs/AndroidDevMetrics\n</code></pre><p>2、 Android内存优化方案</p>\n<pre><code>2.1 Android应用String/StringBuilder/StringBuffer优化建议\n字符串操作在Android应用开发中是十分常见的操作，也就是这个最简单的字符串操作却也暗藏很多潜在的性能问题，下面我们实例来说说。\n先看下面这个关于String和StringBuffer的对比例子：\n//性能差的实现\nString str1 = &quot;Name:&quot;;\nString str2 = &quot;GJRS&quot;;\nString Str = str1 + str2;\n//性能好的实现\nString str1 = &quot;Name:&quot;;\nString str2 = &quot;GJRS&quot;;\nStringBuffer str = new StringBuilder().append(str1).append(str2);\n\n通过这个例子可以看出来，String对象（记得是对象，不是常量）和StringBuffer对象的主要性能区别在于String对象是不可变的，所以每次对String对象做改变操作（譬如“+”操作）时其实都生成了新的String对象实例，所以会导致内存消耗性能问题；而StringBuffer对象做改变操作每次都会对自己进行操作，所以不需要消耗额外的内存空间。\n\n我们再看一个关于String和StringBuffer的对比例子：\n//性能差的实现\nStringBuffer str = new StringBuilder().append(&quot;Name:&quot;).append(&quot;GJRS&quot;);\n//性能好的实现\nString Str = &quot;Name:&quot; + &quot;GJRS&quot;;\n在这种情况下你会发现StringBuffer的性能反而没有String的好，原因是在JVM解释时认为 \nString Str = &quot;Name:&quot; + &quot;GJRS&quot;;就是String Str = &quot;Name:GJRS&quot;;，所以自然比StringBuffer快了。\n可以发现，如果我们拼接的是字符串常量则String效率比StringBuffer高，如果拼接的是字符串对象，则StringBuffer比String效率高，我们在开发中要酌情选择。当然，除过注意StringBuffer和String的效率问题，我们还应该注意另一个问题，那就是StringBuffer和StringBuilder的区别，其实StringBuffer和StringBuilder都继承自同一个父类，只是StringBuffer是线程安全的，也就是说在不考虑多线程情况下StringBuilder的性能又比StringBuffer高。\nPS：如果想追究清楚他们之间具体细节差异，麻烦自己查看实现源码即可\n\n2.2 Android应用HashMap与ArrayMap及SparseArray优化建议\n在Android开发中涉及到数据逻辑部分大部分用的都是Java的API（譬如HashMap），但是对于Android设备来说有些Java的API并不适合，可能会导致系统性能下降，好在Google团队已经意识到这些问题，所以他们针对Android设备对Java的一些API进行了优化，优化最多就是使用了ArrayMap及SparseArray替代HashMap来获得性能提升。\n\nHashMap：\nHashMap内部使用一个默认容量为16的数组来存储数据，数组中每一个元素存放一个链表的头结点，其实整个HashMap内部结构就是一个哈希表的拉链结构。HashMap默认实现的扩容是以2倍增加，且获取一个节点采用了遍历法，所以相对来说无论从内存消耗还是节点查找上都是十分昂贵的。\n\nSparseArray：\nSparseArray比HashMap省内存是因为它避免了对Key进行自动装箱（int转Integer），它内部是用两个数组来进行数据存储的（一个存Key，一个存Value），它内部对数据采用了压缩方式来表示稀疏数组数据，从而节约内存空间，而且其查找节点的实现采用了二分法，很明显可以看见性能的提升。\n\nArrayMap：\nArrayMap内部使用两个数组进行数据存储，一个记录Key的Hash值，一个记录Value值，它和SparseArray类似，也会在查找时对Key采用二分法。\n有了上面的基本了解我们可以得出结论供开发时参考，当数据量不大（千位级内）且Key为int类型时使用SparseArray替换HashMap效率高；当数据量不大（千位级内）且数据类型为Map类型时使用ArrayMap替换HashMap效率高；其他情况下HashMap效率相对高于二者\n\n2.3 Android应用ContentProviderOperation优化建议\nContentProvider是Android应用开发的核心组件之一，有时候在开发中需要使用ContentProvider对多行数据进行操作，我们的做法一般是多次调运相关操作方法，殊不知这种实现方式是非常低性能的，取而代之的做法应该是使用批量操作，具体为了使批量更新、插入、删除数据操作更加方便官方提供了ContentProviderOperation工具类。所以在我们开发中遇到类似情景时请务必使用批量操作，具体的优势如下：\n所有的操作都在一个事务中执行，可以保证数据的完整性。\n批量操作在一个事务中执行，所以只用打开、关闭一个事务。\n减轻应用程序与ContentProvider间的多次频繁交互，提升性能。\n可以看见，这对于数据库操作来说是一个非常有用的优化措施，烦请务必重视（我们项目优化过，的确有很大提升）\n\n2.4 其他逻辑优化\n避免在Android中使用Java的枚举类型，因为编译后不但占空间，加载也费时，完全没有static final的变量好用、高效。\n\nHandler发送消息时尽量使用obtain去获取已经存在的Message对象进行复用，而不是新new Message对象，这样可以减轻内存压力。\n\n在使用后台Service时尽量将能够替换为IntentService的地方替换为此，这样可以减轻系统压力、省电、省内存、省CPU占用率。\n\n在当前类内部尽量不要通过自己的getXXX、setXXX对自己内部成员进行操作，而是直接使用，这样可以提高代码执行效率。\n\n不要一味的为了设计模式而过分的抽象代码，因为代码抽象系数与代码加载执行时间成正比。\n\n尽量减少锁个数、减小锁范围，避免造成性能问题。\n\n合理的选择使用for循环与增强型for循环，譬如不要在ArrayList上使用增强型for循环等。\n</code></pre><p>3、 Android UI性能优化方案</p>\n<p>4、 设计模式</p>\n<p>5、 Android网络访问框架选型和优化</p>\n<pre><code>5.1 volley\n5.2 retrofit\n5.3 andrid-async-http\n</code></pre><p>6、 Bug解决系统：Bugly；BugTags；GT；iTest；Emmagee；</p>\n<p>7、 Android应用移动设备电池耗电性能分析</p>\n<p>有了UI性能优化、内存性能优化、代码编写优化之后我们在来说说应用开发中很重要的一个优化模块—–电量优化。</p>\n<p>7.1 Android应用耗电量概念</p>\n<p>在盒子等开发时可能电量优化不是特别重视（视盒子待机真假待机模式而定），但是在移动设备开发中耗电量是一个非常重要的指标，如果用户一旦发现我们的应用非常耗电，不好意思，他们大多会选择卸载来解决此类问题，所以耗电量是一个十分重要的问题。</p>\n<p>关于我们应用的耗电量情况我们可以进行定长时间测试，至于具体的耗电量统计等请参考此文，同时我们还可以直接通过Battery Historian Tool来查看详细的应用电量消耗情况。最简单常用办法是通过命令直接查看，如下：</p>\n<p>adb shell dumpsys batterystats</p>\n<p>其实我们一款应用耗电量最大的部分不是UI绘制显示等，常见耗电量最大原因基本都是因为网络数据交互、GPS定位、大量内存性能问题、冗余的后台线程和Service等造成。</p>\n<p>7.2 Android应用耗电量优化建议</p>\n<p>优化电量使用情况我们不仅可以使用系统提供的一些API去处理，还可以在平时编写代码时就养成好的习惯。具体的一些建议如下：</p>\n<p>在需要网络的应用中，执行某些操作前尽量先进行网络状态判断。</p>\n<p>在网络应用传输中使用高效率的数据格式和解析方法，譬如JSON等。</p>\n<p>在传输用户反馈或者下载OTA升级包等不是十分紧急的操作时尽量采用压缩数据进行传输且延迟到设备充电和WIFI状态时进行。</p>\n<p>在有必要的情况下尽量通过PowerManager.WakeLock和JobScheduler来控制一些逻辑操作达到省电优化。</p>\n<p>对定位要求不太高的场景尽量使用网络定位，而不是GPS定位。</p>\n<p>对于定时任务尽量使用AlarmManager，而不是sleep或者Timer进行管理。</p>\n<p>尽可能的减少网络请求次数和减小网络请求时间间隔。</p>\n<p>后台任务要尽可能少的唤醒CPU，譬如IM通信的长连接心跳时间间隔、一些应用的后台定时唤醒时间间隔等要设计合理。</p>\n<p>特殊耗电业务情况可以进行弹窗等友好的交互设计提醒用户该操作会耗用过多电量。</p>\n<p>可以看见，上面只是一些常见的电量消耗优化建议。总之，作为应用开发者的我们要意识到电量损耗对于用户来说是非常敏感的，只有我们做到合理的电量优化才能赢得用户的芳心。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、-Android性能分析工具\"><a href=\"#1、-Android性能分析工具\" class=\"headerlink\" title=\"1、 Android性能分析工具\"></a>1、 Android性能分析工具</h2><pre><code>1.1 TraceView:\n    最简单的方式就是直接打开DDMS，选择一个进程，然后按上面的“Start Method Profiling”按钮，\n    第2种方式就是使用android.os.Debug.startMethodTracing();和android.os.Debug.stopMethodTracing();方法\n    重要指标 Calls+Recur Calls／Total（方法执行的次数）；Cpu Time／Call（方法耗时）\n1.2 Eclipse Memory Analyzer Tool 内存使用\n\n1.3 Dump UI Hierarchy for UI Atomator 分析UI层级\n\n1.4 systrace\n    Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。\n    Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：\n    内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。\n    数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。\n    数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。\n\n1.5 Oprofile：性能数据采集和分析工具\n\n1.6 Hierarchy Viewer（层级查看器）\n</code></pre><p>参考：<em><a href=\"http://www.jianshu.com/p/da2a4bfcba68\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/da2a4bfcba68</a></em></p>\n<pre><code>1.7 Battery Historian \n    Google出品, 通过Android系统的bugreport文件来做电量使用分析的工具\n    https://github.com/google/battery-historian\n1.8 NetEase/Emmagee\n    针对Android App的CPU, 内存, 网络, 电量等多项综合的测试分析.\n    https://github.com/NetEase/Emmagee\n\n1.9 Square\n    Square出品, 必属精品.\n    类似与App探针的内存泄露监测工具.\n    https://github.com/square/leakcanary\n\n1.10 AndroidDevMetrics\n    一个library, 用来检测Activity生命周期执行性能, Dagger2注入性能以及帧率性能的工具\n    https://github.com/frogermcs/AndroidDevMetrics\n</code></pre><p>2、 Android内存优化方案</p>\n<pre><code>2.1 Android应用String/StringBuilder/StringBuffer优化建议\n字符串操作在Android应用开发中是十分常见的操作，也就是这个最简单的字符串操作却也暗藏很多潜在的性能问题，下面我们实例来说说。\n先看下面这个关于String和StringBuffer的对比例子：\n//性能差的实现\nString str1 = &quot;Name:&quot;;\nString str2 = &quot;GJRS&quot;;\nString Str = str1 + str2;\n//性能好的实现\nString str1 = &quot;Name:&quot;;\nString str2 = &quot;GJRS&quot;;\nStringBuffer str = new StringBuilder().append(str1).append(str2);\n\n通过这个例子可以看出来，String对象（记得是对象，不是常量）和StringBuffer对象的主要性能区别在于String对象是不可变的，所以每次对String对象做改变操作（譬如“+”操作）时其实都生成了新的String对象实例，所以会导致内存消耗性能问题；而StringBuffer对象做改变操作每次都会对自己进行操作，所以不需要消耗额外的内存空间。\n\n我们再看一个关于String和StringBuffer的对比例子：\n//性能差的实现\nStringBuffer str = new StringBuilder().append(&quot;Name:&quot;).append(&quot;GJRS&quot;);\n//性能好的实现\nString Str = &quot;Name:&quot; + &quot;GJRS&quot;;\n在这种情况下你会发现StringBuffer的性能反而没有String的好，原因是在JVM解释时认为 \nString Str = &quot;Name:&quot; + &quot;GJRS&quot;;就是String Str = &quot;Name:GJRS&quot;;，所以自然比StringBuffer快了。\n可以发现，如果我们拼接的是字符串常量则String效率比StringBuffer高，如果拼接的是字符串对象，则StringBuffer比String效率高，我们在开发中要酌情选择。当然，除过注意StringBuffer和String的效率问题，我们还应该注意另一个问题，那就是StringBuffer和StringBuilder的区别，其实StringBuffer和StringBuilder都继承自同一个父类，只是StringBuffer是线程安全的，也就是说在不考虑多线程情况下StringBuilder的性能又比StringBuffer高。\nPS：如果想追究清楚他们之间具体细节差异，麻烦自己查看实现源码即可\n\n2.2 Android应用HashMap与ArrayMap及SparseArray优化建议\n在Android开发中涉及到数据逻辑部分大部分用的都是Java的API（譬如HashMap），但是对于Android设备来说有些Java的API并不适合，可能会导致系统性能下降，好在Google团队已经意识到这些问题，所以他们针对Android设备对Java的一些API进行了优化，优化最多就是使用了ArrayMap及SparseArray替代HashMap来获得性能提升。\n\nHashMap：\nHashMap内部使用一个默认容量为16的数组来存储数据，数组中每一个元素存放一个链表的头结点，其实整个HashMap内部结构就是一个哈希表的拉链结构。HashMap默认实现的扩容是以2倍增加，且获取一个节点采用了遍历法，所以相对来说无论从内存消耗还是节点查找上都是十分昂贵的。\n\nSparseArray：\nSparseArray比HashMap省内存是因为它避免了对Key进行自动装箱（int转Integer），它内部是用两个数组来进行数据存储的（一个存Key，一个存Value），它内部对数据采用了压缩方式来表示稀疏数组数据，从而节约内存空间，而且其查找节点的实现采用了二分法，很明显可以看见性能的提升。\n\nArrayMap：\nArrayMap内部使用两个数组进行数据存储，一个记录Key的Hash值，一个记录Value值，它和SparseArray类似，也会在查找时对Key采用二分法。\n有了上面的基本了解我们可以得出结论供开发时参考，当数据量不大（千位级内）且Key为int类型时使用SparseArray替换HashMap效率高；当数据量不大（千位级内）且数据类型为Map类型时使用ArrayMap替换HashMap效率高；其他情况下HashMap效率相对高于二者\n\n2.3 Android应用ContentProviderOperation优化建议\nContentProvider是Android应用开发的核心组件之一，有时候在开发中需要使用ContentProvider对多行数据进行操作，我们的做法一般是多次调运相关操作方法，殊不知这种实现方式是非常低性能的，取而代之的做法应该是使用批量操作，具体为了使批量更新、插入、删除数据操作更加方便官方提供了ContentProviderOperation工具类。所以在我们开发中遇到类似情景时请务必使用批量操作，具体的优势如下：\n所有的操作都在一个事务中执行，可以保证数据的完整性。\n批量操作在一个事务中执行，所以只用打开、关闭一个事务。\n减轻应用程序与ContentProvider间的多次频繁交互，提升性能。\n可以看见，这对于数据库操作来说是一个非常有用的优化措施，烦请务必重视（我们项目优化过，的确有很大提升）\n\n2.4 其他逻辑优化\n避免在Android中使用Java的枚举类型，因为编译后不但占空间，加载也费时，完全没有static final的变量好用、高效。\n\nHandler发送消息时尽量使用obtain去获取已经存在的Message对象进行复用，而不是新new Message对象，这样可以减轻内存压力。\n\n在使用后台Service时尽量将能够替换为IntentService的地方替换为此，这样可以减轻系统压力、省电、省内存、省CPU占用率。\n\n在当前类内部尽量不要通过自己的getXXX、setXXX对自己内部成员进行操作，而是直接使用，这样可以提高代码执行效率。\n\n不要一味的为了设计模式而过分的抽象代码，因为代码抽象系数与代码加载执行时间成正比。\n\n尽量减少锁个数、减小锁范围，避免造成性能问题。\n\n合理的选择使用for循环与增强型for循环，譬如不要在ArrayList上使用增强型for循环等。\n</code></pre><p>3、 Android UI性能优化方案</p>\n<p>4、 设计模式</p>\n<p>5、 Android网络访问框架选型和优化</p>\n<pre><code>5.1 volley\n5.2 retrofit\n5.3 andrid-async-http\n</code></pre><p>6、 Bug解决系统：Bugly；BugTags；GT；iTest；Emmagee；</p>\n<p>7、 Android应用移动设备电池耗电性能分析</p>\n<p>有了UI性能优化、内存性能优化、代码编写优化之后我们在来说说应用开发中很重要的一个优化模块—–电量优化。</p>\n<p>7.1 Android应用耗电量概念</p>\n<p>在盒子等开发时可能电量优化不是特别重视（视盒子待机真假待机模式而定），但是在移动设备开发中耗电量是一个非常重要的指标，如果用户一旦发现我们的应用非常耗电，不好意思，他们大多会选择卸载来解决此类问题，所以耗电量是一个十分重要的问题。</p>\n<p>关于我们应用的耗电量情况我们可以进行定长时间测试，至于具体的耗电量统计等请参考此文，同时我们还可以直接通过Battery Historian Tool来查看详细的应用电量消耗情况。最简单常用办法是通过命令直接查看，如下：</p>\n<p>adb shell dumpsys batterystats</p>\n<p>其实我们一款应用耗电量最大的部分不是UI绘制显示等，常见耗电量最大原因基本都是因为网络数据交互、GPS定位、大量内存性能问题、冗余的后台线程和Service等造成。</p>\n<p>7.2 Android应用耗电量优化建议</p>\n<p>优化电量使用情况我们不仅可以使用系统提供的一些API去处理，还可以在平时编写代码时就养成好的习惯。具体的一些建议如下：</p>\n<p>在需要网络的应用中，执行某些操作前尽量先进行网络状态判断。</p>\n<p>在网络应用传输中使用高效率的数据格式和解析方法，譬如JSON等。</p>\n<p>在传输用户反馈或者下载OTA升级包等不是十分紧急的操作时尽量采用压缩数据进行传输且延迟到设备充电和WIFI状态时进行。</p>\n<p>在有必要的情况下尽量通过PowerManager.WakeLock和JobScheduler来控制一些逻辑操作达到省电优化。</p>\n<p>对定位要求不太高的场景尽量使用网络定位，而不是GPS定位。</p>\n<p>对于定时任务尽量使用AlarmManager，而不是sleep或者Timer进行管理。</p>\n<p>尽可能的减少网络请求次数和减小网络请求时间间隔。</p>\n<p>后台任务要尽可能少的唤醒CPU，譬如IM通信的长连接心跳时间间隔、一些应用的后台定时唤醒时间间隔等要设计合理。</p>\n<p>特殊耗电业务情况可以进行弹窗等友好的交互设计提醒用户该操作会耗用过多电量。</p>\n<p>可以看见，上面只是一些常见的电量消耗优化建议。总之，作为应用开发者的我们要意识到电量损耗对于用户来说是非常敏感的，只有我们做到合理的电量优化才能赢得用户的芳心。</p>\n"},{"title":"串口工具","date":"2019-07-15T06:26:28.000Z","comments":1,"_content":"\n## 完整代码\n```\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.deemons.serialportlib.SerialPort;\nimport com.glodon.tool.DataUtils;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * 串口帮助类\n * <p>\n * 使用简述\n * <p>\n * 添加库：implementation \"com.deemons.serialport:serialport:1.2.0\"\n *\n * @see\n * <a href=“https://github.com/Deemonser/AndroidSerialPort”>https://github.com/Deemonser/AndroidSerialPort</a>\n * <p>\n * @see\n * <a href=“http://pm.glodon.com/newjira/browse/GLW-1234”>通信协议：http://pm.glodon.com/newjira/browse/GLW-1234</a>\n * <p>\n * Created by lichongmac@163.com on 2019-07-12.\n */\npublic class SerialPortHelper {\n    private static final String TAG = SerialPortHelper.class.getSimpleName();\n\n    private SerialPort mSerialPort;\n\n    private String filePath = \"/dev/ttyS2\";\n    private int baudRate = 115200;\n\n    private static SerialPortHelper sSerialPortHelper;\n\n    private SerialPortHelper() {\n        openSerialPort();\n    }\n\n    public void openSerialPort() {\n        closeSerialPort();\n        try {\n            mSerialPort = new SerialPort(filePath, baudRate);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        new ReceiveThread().start();\n    }\n\n    public static SerialPortHelper getInstance() {\n        if (sSerialPortHelper == null) {\n            sSerialPortHelper = new SerialPortHelper();\n        }\n        return sSerialPortHelper;\n    }\n\n    public void closeSerialPort() {\n        if (mSerialPort != null) {\n            isStart = false;\n            mSerialPort.close();\n        }\n    }\n\n    private boolean isStart = false;\n\n    /**\n     * 接收串口数据的线程\n     */\n    private class ReceiveThread extends Thread {\n\n        public ReceiveThread() {\n            isStart = true;\n        }\n\n        private String dataBuffer = \"\";\n        private String CMD_HEADER = \"BB\";\n\n        @Override\n        public void run() {\n            super.run();\n            //条件判断，只要条件为true，则一直执行这个线程\n            while (isStart) {\n                if (mSerialPort.getInputStream() == null) {\n                    Log.e(TAG, \"数据流出现未知异常\");\n                    return;\n                }\n\n                byte[] readData = new byte[1024];\n                try {\n                    int size = mSerialPort.getInputStream().read(readData);\n                    if (size > 0) {\n\n                        String data = DataUtils.ByteArrToHex(readData, 0, size);\n                        if (!TextUtils.isEmpty(data)) {\n                            Log.i(TAG, data);\n                            dataBuffer += data;\n                        }\n                        while (dataBuffer.contains(CMD_HEADER) && dataBuffer.length() > 10) {\n//                            Log.i(TAG, \"start dataBuffer = \" + dataBuffer);\n                            int start = dataBuffer.indexOf(CMD_HEADER) + CMD_HEADER.length();\n                            String msgType = dataBuffer.substring(start, start + 2);\n                            String msgComm = dataBuffer.substring(start + 2, start + 4);\n                            String contentLength = dataBuffer.substring(start + 4, start + 8);\n\n                            int length = DataUtils.HexToInt(contentLength);\n\n                            if (start + 8 + length * 2 > dataBuffer.length())\n                                break;\n\n                            String content = dataBuffer.substring(start + 8,\n                                    start + 8 + length * 2);\n                            Log.i(TAG, \"消息类型：\" + msgType\n                                    + \"，指令：\" + msgComm\n                                    + \"，数据长度：\" + length\n                                    + \"，content：\" + content\n                            );\n                            //通知观察者或监听者消息内容\n                            SerialPortHelper.getInstance().notify(msgType, msgComm, content);\n\n                            dataBuffer = dataBuffer.substring(start + 8 + length * 2);\n                            if (dataBuffer.contains(CMD_HEADER)) {//剔除尾部和校验位\n                                dataBuffer = dataBuffer.substring(dataBuffer.indexOf(CMD_HEADER));\n                            }\n//                            Log.i(TAG, \"end dataBuffer = \" + dataBuffer);\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        }\n    }\n\n    public interface SerialPortListener {\n        void onReceive(String msgType, String msgComm, String content);\n    }\n\n    List<SerialPortListener> mListeners = new CopyOnWriteArrayList();\n\n    public void addListener(SerialPortListener listener) {\n        if (!mListeners.contains(listener)) {\n            mListeners.add(listener);\n        }\n    }\n\n    public void removeListener(SerialPortListener listener) {\n        if (mListeners.contains(listener)) {\n            mListeners.remove(listener);\n        }\n    }\n\n    public void notify(String msgType, String msgComm, String content) {\n        for (SerialPortListener listener : mListeners)\n            listener.onReceive(msgType, msgComm, content);\n    }\n}\n\n```\n### 辅助类\n```\nimport android.text.TextUtils;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 串口数据转换工具类\n * Created by Administrator on 2016/6/2.\n */\npublic class DataUtils {\n    //-------------------------------------------------------\n    // 判断奇数或偶数，位运算，最后一位是1则为奇数，为0是偶数\n    public static int isOdd(int num) {\n        return num & 1;\n    }\n\n    //-------------------------------------------------------\n    //Hex字符串转int\n    public static int HexToInt(String inHex) {\n        if(TextUtils.isEmpty(inHex)) {\n            return 0;\n        }\n        try {\n\n        return Integer.parseInt(inHex, 16);\n        }catch (NumberFormatException e){\n            e.printStackTrace();\n        }\n        return 0;\n    }\n\n    public static String IntToHex(int intHex){\n        return Integer.toHexString(intHex);\n    }\n\n    //-------------------------------------------------------\n    //Hex字符串转byte\n    public static byte HexToByte(String inHex) {\n        return (byte) Integer.parseInt(inHex, 16);\n    }\n\n    //-------------------------------------------------------\n    //1字节转2个Hex字符\n    public static String Byte2Hex(Byte inByte) {\n        return String.format(\"%02x\", new Object[]{inByte}).toUpperCase();\n    }\n\n    //-------------------------------------------------------\n    //字节数组转转hex字符串\n    public static String ByteArrToHex(byte[] inBytArr) {\n        StringBuilder strBuilder = new StringBuilder();\n        for (byte valueOf : inBytArr) {\n            strBuilder.append(Byte2Hex(Byte.valueOf(valueOf)));\n            strBuilder.append(\" \");\n        }\n        return strBuilder.toString();\n    }\n\n    //-------------------------------------------------------\n    //字节数组转转hex字符串，可选长度\n    public static String ByteArrToHex(byte[] inBytArr, int offset, int byteCount) {\n        StringBuilder strBuilder = new StringBuilder();\n        int j = byteCount;\n        for (int i = offset; i < j; i++) {\n            strBuilder.append(Byte2Hex(Byte.valueOf(inBytArr[i])));\n        }\n        return strBuilder.toString();\n    }\n\n    // ascii byte数 组转成String字符串，可选长度\n    public static String byteOfASCIIToString(byte[] inBytArr, int offset, int byteCount){\n        StringBuilder strBuilder = new StringBuilder();\n        int j = byteCount;\n        for (int i = offset; i < j; i++) {\n            char c=(char)inBytArr[i];\n            strBuilder.append(c);\n        }\n        return strBuilder.toString();\n    }\n\n\n    //-------------------------------------------------------\n    //转hex字符串转字节数组\n    public static byte[] HexToByteArr(String inHex) {\n        byte[] result;\n        int hexlen = inHex.length();\n        if (isOdd(hexlen) == 1) {\n            hexlen++;\n            result = new byte[(hexlen / 2)];\n            inHex = \"0\" + inHex;\n        } else {\n            result = new byte[(hexlen / 2)];\n        }\n        int j = 0;\n        for (int i = 0; i < hexlen; i += 2) {\n            result[j] = HexToByte(inHex.substring(i, i + 2));\n            j++;\n        }\n        return result;\n    }\n\n    /**\n     * 按照指定长度切割字符串\n     *\n     * @param inputString 需要切割的源字符串\n     * @param length      指定的长度\n     * @return\n     */\n    public static List<String> getDivLines(String inputString, int length) {\n        List<String> divList = new ArrayList<>();\n        int remainder = (inputString.length()) % length;\n        // 一共要分割成几段\n        int number = (int) Math.floor((inputString.length()) / length);\n        for (int index = 0; index < number; index++) {\n            String childStr = inputString.substring(index * length, (index + 1) * length);\n            divList.add(childStr);\n        }\n        if (remainder > 0) {\n            String cStr = inputString.substring(number * length, inputString.length());\n            divList.add(cStr);\n        }\n        return divList;\n    }\n\n    /**\n     * 计算长度，两个字节长度\n     *\n     * @param val value\n     * @return 结果\n     */\n    public static String twoByte(String val) {\n        if (val.length() > 4) {\n            val = val.substring(0, 4);\n        } else {\n            int l = 4 - val.length();\n            for (int i = 0; i < l; i++) {\n                val = \"0\" + val;\n            }\n        }\n        return val;\n    }\n\n    /**\n     * 校验和\n     *\n     * @param cmd 指令\n     * @return 结果\n     */\n    public static String sum(String cmd) {\n        List<String> cmdList = DataUtils.getDivLines(cmd, 2);\n        int sumInt = 0;\n        for (String c : cmdList) {\n            sumInt += DataUtils.HexToInt(c);\n        }\n        String sum = DataUtils.IntToHex(sumInt);\n        sum = DataUtils.twoByte(sum);\n        cmd += sum;\n        return cmd.toUpperCase();\n    }\n\n    public static int str8ToInt(String[] str){\n        int sum=0;\n        for(int i=0;i<str.length;i++){\n\n            int value=computerBinary(str[i],str.length-1-i);\n\n            sum+=value;\n        }\n        return sum;\n    }\n    public static int str8ToInt(String str){\n        int sum=0;\n        for(int i=0;i<str.length();i++){\n            String strIndex=str.charAt(i)+\"\";\n            int value=computerBinary(strIndex,str.length()-1-i);\n\n            sum+=value;\n        }\n        return sum;\n    }\n    private static int computerBinary(String c, int index) {\n        int vaule=Integer.valueOf(c);\n        for(int i=0;i<index;i++){\n            vaule*=2;\n        }\n        return vaule;\n    }\n\n}\n\n```\n\n## 参考\n[GitHub地址](https://github.com/Deemonser/AndroidSerialPort)\n[]()","source":"_posts/serial-prot-helper.md","raw":"---\ntitle: 串口工具\ndate: 2019-07-15 14:26:28\ncomments: true\ntags: 串口工具\n---\n\n## 完整代码\n```\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.deemons.serialportlib.SerialPort;\nimport com.glodon.tool.DataUtils;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * 串口帮助类\n * <p>\n * 使用简述\n * <p>\n * 添加库：implementation \"com.deemons.serialport:serialport:1.2.0\"\n *\n * @see\n * <a href=“https://github.com/Deemonser/AndroidSerialPort”>https://github.com/Deemonser/AndroidSerialPort</a>\n * <p>\n * @see\n * <a href=“http://pm.glodon.com/newjira/browse/GLW-1234”>通信协议：http://pm.glodon.com/newjira/browse/GLW-1234</a>\n * <p>\n * Created by lichongmac@163.com on 2019-07-12.\n */\npublic class SerialPortHelper {\n    private static final String TAG = SerialPortHelper.class.getSimpleName();\n\n    private SerialPort mSerialPort;\n\n    private String filePath = \"/dev/ttyS2\";\n    private int baudRate = 115200;\n\n    private static SerialPortHelper sSerialPortHelper;\n\n    private SerialPortHelper() {\n        openSerialPort();\n    }\n\n    public void openSerialPort() {\n        closeSerialPort();\n        try {\n            mSerialPort = new SerialPort(filePath, baudRate);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        new ReceiveThread().start();\n    }\n\n    public static SerialPortHelper getInstance() {\n        if (sSerialPortHelper == null) {\n            sSerialPortHelper = new SerialPortHelper();\n        }\n        return sSerialPortHelper;\n    }\n\n    public void closeSerialPort() {\n        if (mSerialPort != null) {\n            isStart = false;\n            mSerialPort.close();\n        }\n    }\n\n    private boolean isStart = false;\n\n    /**\n     * 接收串口数据的线程\n     */\n    private class ReceiveThread extends Thread {\n\n        public ReceiveThread() {\n            isStart = true;\n        }\n\n        private String dataBuffer = \"\";\n        private String CMD_HEADER = \"BB\";\n\n        @Override\n        public void run() {\n            super.run();\n            //条件判断，只要条件为true，则一直执行这个线程\n            while (isStart) {\n                if (mSerialPort.getInputStream() == null) {\n                    Log.e(TAG, \"数据流出现未知异常\");\n                    return;\n                }\n\n                byte[] readData = new byte[1024];\n                try {\n                    int size = mSerialPort.getInputStream().read(readData);\n                    if (size > 0) {\n\n                        String data = DataUtils.ByteArrToHex(readData, 0, size);\n                        if (!TextUtils.isEmpty(data)) {\n                            Log.i(TAG, data);\n                            dataBuffer += data;\n                        }\n                        while (dataBuffer.contains(CMD_HEADER) && dataBuffer.length() > 10) {\n//                            Log.i(TAG, \"start dataBuffer = \" + dataBuffer);\n                            int start = dataBuffer.indexOf(CMD_HEADER) + CMD_HEADER.length();\n                            String msgType = dataBuffer.substring(start, start + 2);\n                            String msgComm = dataBuffer.substring(start + 2, start + 4);\n                            String contentLength = dataBuffer.substring(start + 4, start + 8);\n\n                            int length = DataUtils.HexToInt(contentLength);\n\n                            if (start + 8 + length * 2 > dataBuffer.length())\n                                break;\n\n                            String content = dataBuffer.substring(start + 8,\n                                    start + 8 + length * 2);\n                            Log.i(TAG, \"消息类型：\" + msgType\n                                    + \"，指令：\" + msgComm\n                                    + \"，数据长度：\" + length\n                                    + \"，content：\" + content\n                            );\n                            //通知观察者或监听者消息内容\n                            SerialPortHelper.getInstance().notify(msgType, msgComm, content);\n\n                            dataBuffer = dataBuffer.substring(start + 8 + length * 2);\n                            if (dataBuffer.contains(CMD_HEADER)) {//剔除尾部和校验位\n                                dataBuffer = dataBuffer.substring(dataBuffer.indexOf(CMD_HEADER));\n                            }\n//                            Log.i(TAG, \"end dataBuffer = \" + dataBuffer);\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        }\n    }\n\n    public interface SerialPortListener {\n        void onReceive(String msgType, String msgComm, String content);\n    }\n\n    List<SerialPortListener> mListeners = new CopyOnWriteArrayList();\n\n    public void addListener(SerialPortListener listener) {\n        if (!mListeners.contains(listener)) {\n            mListeners.add(listener);\n        }\n    }\n\n    public void removeListener(SerialPortListener listener) {\n        if (mListeners.contains(listener)) {\n            mListeners.remove(listener);\n        }\n    }\n\n    public void notify(String msgType, String msgComm, String content) {\n        for (SerialPortListener listener : mListeners)\n            listener.onReceive(msgType, msgComm, content);\n    }\n}\n\n```\n### 辅助类\n```\nimport android.text.TextUtils;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 串口数据转换工具类\n * Created by Administrator on 2016/6/2.\n */\npublic class DataUtils {\n    //-------------------------------------------------------\n    // 判断奇数或偶数，位运算，最后一位是1则为奇数，为0是偶数\n    public static int isOdd(int num) {\n        return num & 1;\n    }\n\n    //-------------------------------------------------------\n    //Hex字符串转int\n    public static int HexToInt(String inHex) {\n        if(TextUtils.isEmpty(inHex)) {\n            return 0;\n        }\n        try {\n\n        return Integer.parseInt(inHex, 16);\n        }catch (NumberFormatException e){\n            e.printStackTrace();\n        }\n        return 0;\n    }\n\n    public static String IntToHex(int intHex){\n        return Integer.toHexString(intHex);\n    }\n\n    //-------------------------------------------------------\n    //Hex字符串转byte\n    public static byte HexToByte(String inHex) {\n        return (byte) Integer.parseInt(inHex, 16);\n    }\n\n    //-------------------------------------------------------\n    //1字节转2个Hex字符\n    public static String Byte2Hex(Byte inByte) {\n        return String.format(\"%02x\", new Object[]{inByte}).toUpperCase();\n    }\n\n    //-------------------------------------------------------\n    //字节数组转转hex字符串\n    public static String ByteArrToHex(byte[] inBytArr) {\n        StringBuilder strBuilder = new StringBuilder();\n        for (byte valueOf : inBytArr) {\n            strBuilder.append(Byte2Hex(Byte.valueOf(valueOf)));\n            strBuilder.append(\" \");\n        }\n        return strBuilder.toString();\n    }\n\n    //-------------------------------------------------------\n    //字节数组转转hex字符串，可选长度\n    public static String ByteArrToHex(byte[] inBytArr, int offset, int byteCount) {\n        StringBuilder strBuilder = new StringBuilder();\n        int j = byteCount;\n        for (int i = offset; i < j; i++) {\n            strBuilder.append(Byte2Hex(Byte.valueOf(inBytArr[i])));\n        }\n        return strBuilder.toString();\n    }\n\n    // ascii byte数 组转成String字符串，可选长度\n    public static String byteOfASCIIToString(byte[] inBytArr, int offset, int byteCount){\n        StringBuilder strBuilder = new StringBuilder();\n        int j = byteCount;\n        for (int i = offset; i < j; i++) {\n            char c=(char)inBytArr[i];\n            strBuilder.append(c);\n        }\n        return strBuilder.toString();\n    }\n\n\n    //-------------------------------------------------------\n    //转hex字符串转字节数组\n    public static byte[] HexToByteArr(String inHex) {\n        byte[] result;\n        int hexlen = inHex.length();\n        if (isOdd(hexlen) == 1) {\n            hexlen++;\n            result = new byte[(hexlen / 2)];\n            inHex = \"0\" + inHex;\n        } else {\n            result = new byte[(hexlen / 2)];\n        }\n        int j = 0;\n        for (int i = 0; i < hexlen; i += 2) {\n            result[j] = HexToByte(inHex.substring(i, i + 2));\n            j++;\n        }\n        return result;\n    }\n\n    /**\n     * 按照指定长度切割字符串\n     *\n     * @param inputString 需要切割的源字符串\n     * @param length      指定的长度\n     * @return\n     */\n    public static List<String> getDivLines(String inputString, int length) {\n        List<String> divList = new ArrayList<>();\n        int remainder = (inputString.length()) % length;\n        // 一共要分割成几段\n        int number = (int) Math.floor((inputString.length()) / length);\n        for (int index = 0; index < number; index++) {\n            String childStr = inputString.substring(index * length, (index + 1) * length);\n            divList.add(childStr);\n        }\n        if (remainder > 0) {\n            String cStr = inputString.substring(number * length, inputString.length());\n            divList.add(cStr);\n        }\n        return divList;\n    }\n\n    /**\n     * 计算长度，两个字节长度\n     *\n     * @param val value\n     * @return 结果\n     */\n    public static String twoByte(String val) {\n        if (val.length() > 4) {\n            val = val.substring(0, 4);\n        } else {\n            int l = 4 - val.length();\n            for (int i = 0; i < l; i++) {\n                val = \"0\" + val;\n            }\n        }\n        return val;\n    }\n\n    /**\n     * 校验和\n     *\n     * @param cmd 指令\n     * @return 结果\n     */\n    public static String sum(String cmd) {\n        List<String> cmdList = DataUtils.getDivLines(cmd, 2);\n        int sumInt = 0;\n        for (String c : cmdList) {\n            sumInt += DataUtils.HexToInt(c);\n        }\n        String sum = DataUtils.IntToHex(sumInt);\n        sum = DataUtils.twoByte(sum);\n        cmd += sum;\n        return cmd.toUpperCase();\n    }\n\n    public static int str8ToInt(String[] str){\n        int sum=0;\n        for(int i=0;i<str.length;i++){\n\n            int value=computerBinary(str[i],str.length-1-i);\n\n            sum+=value;\n        }\n        return sum;\n    }\n    public static int str8ToInt(String str){\n        int sum=0;\n        for(int i=0;i<str.length();i++){\n            String strIndex=str.charAt(i)+\"\";\n            int value=computerBinary(strIndex,str.length()-1-i);\n\n            sum+=value;\n        }\n        return sum;\n    }\n    private static int computerBinary(String c, int index) {\n        int vaule=Integer.valueOf(c);\n        for(int i=0;i<index;i++){\n            vaule*=2;\n        }\n        return vaule;\n    }\n\n}\n\n```\n\n## 参考\n[GitHub地址](https://github.com/Deemonser/AndroidSerialPort)\n[]()","slug":"serial-prot-helper","published":1,"updated":"2019-07-15T06:42:03.338Z","layout":"post","photos":[],"link":"","_id":"cjy416ssr001780s60eqz8tbq","content":"<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import android.text.TextUtils;</span><br><span class=\"line\">import android.util.Log;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.deemons.serialportlib.SerialPort;</span><br><span class=\"line\">import com.glodon.tool.DataUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\">import java.util.concurrent.CopyOnWriteArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 串口帮助类</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * 使用简述</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * 添加库：implementation &quot;com.deemons.serialport:serialport:1.2.0&quot;</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @see</span><br><span class=\"line\"> * &lt;a href=“https://github.com/Deemonser/AndroidSerialPort”&gt;https://github.com/Deemonser/AndroidSerialPort&lt;/a&gt;</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * @see</span><br><span class=\"line\"> * &lt;a href=“http://pm.glodon.com/newjira/browse/GLW-1234”&gt;通信协议：http://pm.glodon.com/newjira/browse/GLW-1234&lt;/a&gt;</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * Created by lichongmac@163.com on 2019-07-12.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SerialPortHelper &#123;</span><br><span class=\"line\">    private static final String TAG = SerialPortHelper.class.getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    private SerialPort mSerialPort;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String filePath = &quot;/dev/ttyS2&quot;;</span><br><span class=\"line\">    private int baudRate = 115200;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static SerialPortHelper sSerialPortHelper;</span><br><span class=\"line\"></span><br><span class=\"line\">    private SerialPortHelper() &#123;</span><br><span class=\"line\">        openSerialPort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void openSerialPort() &#123;</span><br><span class=\"line\">        closeSerialPort();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mSerialPort = new SerialPort(filePath, baudRate);</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        new ReceiveThread().start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SerialPortHelper getInstance() &#123;</span><br><span class=\"line\">        if (sSerialPortHelper == null) &#123;</span><br><span class=\"line\">            sSerialPortHelper = new SerialPortHelper();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sSerialPortHelper;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void closeSerialPort() &#123;</span><br><span class=\"line\">        if (mSerialPort != null) &#123;</span><br><span class=\"line\">            isStart = false;</span><br><span class=\"line\">            mSerialPort.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private boolean isStart = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 接收串口数据的线程</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private class ReceiveThread extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ReceiveThread() &#123;</span><br><span class=\"line\">            isStart = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        private String dataBuffer = &quot;&quot;;</span><br><span class=\"line\">        private String CMD_HEADER = &quot;BB&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            super.run();</span><br><span class=\"line\">            //条件判断，只要条件为true，则一直执行这个线程</span><br><span class=\"line\">            while (isStart) &#123;</span><br><span class=\"line\">                if (mSerialPort.getInputStream() == null) &#123;</span><br><span class=\"line\">                    Log.e(TAG, &quot;数据流出现未知异常&quot;);</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                byte[] readData = new byte[1024];</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    int size = mSerialPort.getInputStream().read(readData);</span><br><span class=\"line\">                    if (size &gt; 0) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        String data = DataUtils.ByteArrToHex(readData, 0, size);</span><br><span class=\"line\">                        if (!TextUtils.isEmpty(data)) &#123;</span><br><span class=\"line\">                            Log.i(TAG, data);</span><br><span class=\"line\">                            dataBuffer += data;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        while (dataBuffer.contains(CMD_HEADER) &amp;&amp; dataBuffer.length() &gt; 10) &#123;</span><br><span class=\"line\">//                            Log.i(TAG, &quot;start dataBuffer = &quot; + dataBuffer);</span><br><span class=\"line\">                            int start = dataBuffer.indexOf(CMD_HEADER) + CMD_HEADER.length();</span><br><span class=\"line\">                            String msgType = dataBuffer.substring(start, start + 2);</span><br><span class=\"line\">                            String msgComm = dataBuffer.substring(start + 2, start + 4);</span><br><span class=\"line\">                            String contentLength = dataBuffer.substring(start + 4, start + 8);</span><br><span class=\"line\"></span><br><span class=\"line\">                            int length = DataUtils.HexToInt(contentLength);</span><br><span class=\"line\"></span><br><span class=\"line\">                            if (start + 8 + length * 2 &gt; dataBuffer.length())</span><br><span class=\"line\">                                break;</span><br><span class=\"line\"></span><br><span class=\"line\">                            String content = dataBuffer.substring(start + 8,</span><br><span class=\"line\">                                    start + 8 + length * 2);</span><br><span class=\"line\">                            Log.i(TAG, &quot;消息类型：&quot; + msgType</span><br><span class=\"line\">                                    + &quot;，指令：&quot; + msgComm</span><br><span class=\"line\">                                    + &quot;，数据长度：&quot; + length</span><br><span class=\"line\">                                    + &quot;，content：&quot; + content</span><br><span class=\"line\">                            );</span><br><span class=\"line\">                            //通知观察者或监听者消息内容</span><br><span class=\"line\">                            SerialPortHelper.getInstance().notify(msgType, msgComm, content);</span><br><span class=\"line\"></span><br><span class=\"line\">                            dataBuffer = dataBuffer.substring(start + 8 + length * 2);</span><br><span class=\"line\">                            if (dataBuffer.contains(CMD_HEADER)) &#123;//剔除尾部和校验位</span><br><span class=\"line\">                                dataBuffer = dataBuffer.substring(dataBuffer.indexOf(CMD_HEADER));</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">//                            Log.i(TAG, &quot;end dataBuffer = &quot; + dataBuffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public interface SerialPortListener &#123;</span><br><span class=\"line\">        void onReceive(String msgType, String msgComm, String content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;SerialPortListener&gt; mListeners = new CopyOnWriteArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    public void addListener(SerialPortListener listener) &#123;</span><br><span class=\"line\">        if (!mListeners.contains(listener)) &#123;</span><br><span class=\"line\">            mListeners.add(listener);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void removeListener(SerialPortListener listener) &#123;</span><br><span class=\"line\">        if (mListeners.contains(listener)) &#123;</span><br><span class=\"line\">            mListeners.remove(listener);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void notify(String msgType, String msgComm, String content) &#123;</span><br><span class=\"line\">        for (SerialPortListener listener : mListeners)</span><br><span class=\"line\">            listener.onReceive(msgType, msgComm, content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"辅助类\"><a href=\"#辅助类\" class=\"headerlink\" title=\"辅助类\"></a>辅助类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import android.text.TextUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 串口数据转换工具类</span><br><span class=\"line\"> * Created by Administrator on 2016/6/2.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class DataUtils &#123;</span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    // 判断奇数或偶数，位运算，最后一位是1则为奇数，为0是偶数</span><br><span class=\"line\">    public static int isOdd(int num) &#123;</span><br><span class=\"line\">        return num &amp; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    //Hex字符串转int</span><br><span class=\"line\">    public static int HexToInt(String inHex) &#123;</span><br><span class=\"line\">        if(TextUtils.isEmpty(inHex)) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return Integer.parseInt(inHex, 16);</span><br><span class=\"line\">        &#125;catch (NumberFormatException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static String IntToHex(int intHex)&#123;</span><br><span class=\"line\">        return Integer.toHexString(intHex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    //Hex字符串转byte</span><br><span class=\"line\">    public static byte HexToByte(String inHex) &#123;</span><br><span class=\"line\">        return (byte) Integer.parseInt(inHex, 16);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    //1字节转2个Hex字符</span><br><span class=\"line\">    public static String Byte2Hex(Byte inByte) &#123;</span><br><span class=\"line\">        return String.format(&quot;%02x&quot;, new Object[]&#123;inByte&#125;).toUpperCase();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    //字节数组转转hex字符串</span><br><span class=\"line\">    public static String ByteArrToHex(byte[] inBytArr) &#123;</span><br><span class=\"line\">        StringBuilder strBuilder = new StringBuilder();</span><br><span class=\"line\">        for (byte valueOf : inBytArr) &#123;</span><br><span class=\"line\">            strBuilder.append(Byte2Hex(Byte.valueOf(valueOf)));</span><br><span class=\"line\">            strBuilder.append(&quot; &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return strBuilder.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    //字节数组转转hex字符串，可选长度</span><br><span class=\"line\">    public static String ByteArrToHex(byte[] inBytArr, int offset, int byteCount) &#123;</span><br><span class=\"line\">        StringBuilder strBuilder = new StringBuilder();</span><br><span class=\"line\">        int j = byteCount;</span><br><span class=\"line\">        for (int i = offset; i &lt; j; i++) &#123;</span><br><span class=\"line\">            strBuilder.append(Byte2Hex(Byte.valueOf(inBytArr[i])));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return strBuilder.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ascii byte数 组转成String字符串，可选长度</span><br><span class=\"line\">    public static String byteOfASCIIToString(byte[] inBytArr, int offset, int byteCount)&#123;</span><br><span class=\"line\">        StringBuilder strBuilder = new StringBuilder();</span><br><span class=\"line\">        int j = byteCount;</span><br><span class=\"line\">        for (int i = offset; i &lt; j; i++) &#123;</span><br><span class=\"line\">            char c=(char)inBytArr[i];</span><br><span class=\"line\">            strBuilder.append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return strBuilder.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    //转hex字符串转字节数组</span><br><span class=\"line\">    public static byte[] HexToByteArr(String inHex) &#123;</span><br><span class=\"line\">        byte[] result;</span><br><span class=\"line\">        int hexlen = inHex.length();</span><br><span class=\"line\">        if (isOdd(hexlen) == 1) &#123;</span><br><span class=\"line\">            hexlen++;</span><br><span class=\"line\">            result = new byte[(hexlen / 2)];</span><br><span class=\"line\">            inHex = &quot;0&quot; + inHex;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            result = new byte[(hexlen / 2)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int j = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; hexlen; i += 2) &#123;</span><br><span class=\"line\">            result[j] = HexToByte(inHex.substring(i, i + 2));</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 按照指定长度切割字符串</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param inputString 需要切割的源字符串</span><br><span class=\"line\">     * @param length      指定的长度</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static List&lt;String&gt; getDivLines(String inputString, int length) &#123;</span><br><span class=\"line\">        List&lt;String&gt; divList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        int remainder = (inputString.length()) % length;</span><br><span class=\"line\">        // 一共要分割成几段</span><br><span class=\"line\">        int number = (int) Math.floor((inputString.length()) / length);</span><br><span class=\"line\">        for (int index = 0; index &lt; number; index++) &#123;</span><br><span class=\"line\">            String childStr = inputString.substring(index * length, (index + 1) * length);</span><br><span class=\"line\">            divList.add(childStr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (remainder &gt; 0) &#123;</span><br><span class=\"line\">            String cStr = inputString.substring(number * length, inputString.length());</span><br><span class=\"line\">            divList.add(cStr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return divList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 计算长度，两个字节长度</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param val value</span><br><span class=\"line\">     * @return 结果</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static String twoByte(String val) &#123;</span><br><span class=\"line\">        if (val.length() &gt; 4) &#123;</span><br><span class=\"line\">            val = val.substring(0, 4);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            int l = 4 - val.length();</span><br><span class=\"line\">            for (int i = 0; i &lt; l; i++) &#123;</span><br><span class=\"line\">                val = &quot;0&quot; + val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 校验和</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param cmd 指令</span><br><span class=\"line\">     * @return 结果</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static String sum(String cmd) &#123;</span><br><span class=\"line\">        List&lt;String&gt; cmdList = DataUtils.getDivLines(cmd, 2);</span><br><span class=\"line\">        int sumInt = 0;</span><br><span class=\"line\">        for (String c : cmdList) &#123;</span><br><span class=\"line\">            sumInt += DataUtils.HexToInt(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String sum = DataUtils.IntToHex(sumInt);</span><br><span class=\"line\">        sum = DataUtils.twoByte(sum);</span><br><span class=\"line\">        cmd += sum;</span><br><span class=\"line\">        return cmd.toUpperCase();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static int str8ToInt(String[] str)&#123;</span><br><span class=\"line\">        int sum=0;</span><br><span class=\"line\">        for(int i=0;i&lt;str.length;i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            int value=computerBinary(str[i],str.length-1-i);</span><br><span class=\"line\"></span><br><span class=\"line\">            sum+=value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static int str8ToInt(String str)&#123;</span><br><span class=\"line\">        int sum=0;</span><br><span class=\"line\">        for(int i=0;i&lt;str.length();i++)&#123;</span><br><span class=\"line\">            String strIndex=str.charAt(i)+&quot;&quot;;</span><br><span class=\"line\">            int value=computerBinary(strIndex,str.length()-1-i);</span><br><span class=\"line\"></span><br><span class=\"line\">            sum+=value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private static int computerBinary(String c, int index) &#123;</span><br><span class=\"line\">        int vaule=Integer.valueOf(c);</span><br><span class=\"line\">        for(int i=0;i&lt;index;i++)&#123;</span><br><span class=\"line\">            vaule*=2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return vaule;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/Deemonser/AndroidSerialPort\" target=\"_blank\" rel=\"noopener\">GitHub地址</a><br><a href></a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import android.text.TextUtils;</span><br><span class=\"line\">import android.util.Log;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.deemons.serialportlib.SerialPort;</span><br><span class=\"line\">import com.glodon.tool.DataUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\">import java.util.concurrent.CopyOnWriteArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 串口帮助类</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * 使用简述</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * 添加库：implementation &quot;com.deemons.serialport:serialport:1.2.0&quot;</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @see</span><br><span class=\"line\"> * &lt;a href=“https://github.com/Deemonser/AndroidSerialPort”&gt;https://github.com/Deemonser/AndroidSerialPort&lt;/a&gt;</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * @see</span><br><span class=\"line\"> * &lt;a href=“http://pm.glodon.com/newjira/browse/GLW-1234”&gt;通信协议：http://pm.glodon.com/newjira/browse/GLW-1234&lt;/a&gt;</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * Created by lichongmac@163.com on 2019-07-12.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SerialPortHelper &#123;</span><br><span class=\"line\">    private static final String TAG = SerialPortHelper.class.getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    private SerialPort mSerialPort;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String filePath = &quot;/dev/ttyS2&quot;;</span><br><span class=\"line\">    private int baudRate = 115200;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static SerialPortHelper sSerialPortHelper;</span><br><span class=\"line\"></span><br><span class=\"line\">    private SerialPortHelper() &#123;</span><br><span class=\"line\">        openSerialPort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void openSerialPort() &#123;</span><br><span class=\"line\">        closeSerialPort();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mSerialPort = new SerialPort(filePath, baudRate);</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        new ReceiveThread().start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static SerialPortHelper getInstance() &#123;</span><br><span class=\"line\">        if (sSerialPortHelper == null) &#123;</span><br><span class=\"line\">            sSerialPortHelper = new SerialPortHelper();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sSerialPortHelper;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void closeSerialPort() &#123;</span><br><span class=\"line\">        if (mSerialPort != null) &#123;</span><br><span class=\"line\">            isStart = false;</span><br><span class=\"line\">            mSerialPort.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private boolean isStart = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 接收串口数据的线程</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private class ReceiveThread extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ReceiveThread() &#123;</span><br><span class=\"line\">            isStart = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        private String dataBuffer = &quot;&quot;;</span><br><span class=\"line\">        private String CMD_HEADER = &quot;BB&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            super.run();</span><br><span class=\"line\">            //条件判断，只要条件为true，则一直执行这个线程</span><br><span class=\"line\">            while (isStart) &#123;</span><br><span class=\"line\">                if (mSerialPort.getInputStream() == null) &#123;</span><br><span class=\"line\">                    Log.e(TAG, &quot;数据流出现未知异常&quot;);</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                byte[] readData = new byte[1024];</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    int size = mSerialPort.getInputStream().read(readData);</span><br><span class=\"line\">                    if (size &gt; 0) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                        String data = DataUtils.ByteArrToHex(readData, 0, size);</span><br><span class=\"line\">                        if (!TextUtils.isEmpty(data)) &#123;</span><br><span class=\"line\">                            Log.i(TAG, data);</span><br><span class=\"line\">                            dataBuffer += data;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        while (dataBuffer.contains(CMD_HEADER) &amp;&amp; dataBuffer.length() &gt; 10) &#123;</span><br><span class=\"line\">//                            Log.i(TAG, &quot;start dataBuffer = &quot; + dataBuffer);</span><br><span class=\"line\">                            int start = dataBuffer.indexOf(CMD_HEADER) + CMD_HEADER.length();</span><br><span class=\"line\">                            String msgType = dataBuffer.substring(start, start + 2);</span><br><span class=\"line\">                            String msgComm = dataBuffer.substring(start + 2, start + 4);</span><br><span class=\"line\">                            String contentLength = dataBuffer.substring(start + 4, start + 8);</span><br><span class=\"line\"></span><br><span class=\"line\">                            int length = DataUtils.HexToInt(contentLength);</span><br><span class=\"line\"></span><br><span class=\"line\">                            if (start + 8 + length * 2 &gt; dataBuffer.length())</span><br><span class=\"line\">                                break;</span><br><span class=\"line\"></span><br><span class=\"line\">                            String content = dataBuffer.substring(start + 8,</span><br><span class=\"line\">                                    start + 8 + length * 2);</span><br><span class=\"line\">                            Log.i(TAG, &quot;消息类型：&quot; + msgType</span><br><span class=\"line\">                                    + &quot;，指令：&quot; + msgComm</span><br><span class=\"line\">                                    + &quot;，数据长度：&quot; + length</span><br><span class=\"line\">                                    + &quot;，content：&quot; + content</span><br><span class=\"line\">                            );</span><br><span class=\"line\">                            //通知观察者或监听者消息内容</span><br><span class=\"line\">                            SerialPortHelper.getInstance().notify(msgType, msgComm, content);</span><br><span class=\"line\"></span><br><span class=\"line\">                            dataBuffer = dataBuffer.substring(start + 8 + length * 2);</span><br><span class=\"line\">                            if (dataBuffer.contains(CMD_HEADER)) &#123;//剔除尾部和校验位</span><br><span class=\"line\">                                dataBuffer = dataBuffer.substring(dataBuffer.indexOf(CMD_HEADER));</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">//                            Log.i(TAG, &quot;end dataBuffer = &quot; + dataBuffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public interface SerialPortListener &#123;</span><br><span class=\"line\">        void onReceive(String msgType, String msgComm, String content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;SerialPortListener&gt; mListeners = new CopyOnWriteArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    public void addListener(SerialPortListener listener) &#123;</span><br><span class=\"line\">        if (!mListeners.contains(listener)) &#123;</span><br><span class=\"line\">            mListeners.add(listener);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void removeListener(SerialPortListener listener) &#123;</span><br><span class=\"line\">        if (mListeners.contains(listener)) &#123;</span><br><span class=\"line\">            mListeners.remove(listener);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void notify(String msgType, String msgComm, String content) &#123;</span><br><span class=\"line\">        for (SerialPortListener listener : mListeners)</span><br><span class=\"line\">            listener.onReceive(msgType, msgComm, content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"辅助类\"><a href=\"#辅助类\" class=\"headerlink\" title=\"辅助类\"></a>辅助类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import android.text.TextUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 串口数据转换工具类</span><br><span class=\"line\"> * Created by Administrator on 2016/6/2.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class DataUtils &#123;</span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    // 判断奇数或偶数，位运算，最后一位是1则为奇数，为0是偶数</span><br><span class=\"line\">    public static int isOdd(int num) &#123;</span><br><span class=\"line\">        return num &amp; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    //Hex字符串转int</span><br><span class=\"line\">    public static int HexToInt(String inHex) &#123;</span><br><span class=\"line\">        if(TextUtils.isEmpty(inHex)) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return Integer.parseInt(inHex, 16);</span><br><span class=\"line\">        &#125;catch (NumberFormatException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static String IntToHex(int intHex)&#123;</span><br><span class=\"line\">        return Integer.toHexString(intHex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    //Hex字符串转byte</span><br><span class=\"line\">    public static byte HexToByte(String inHex) &#123;</span><br><span class=\"line\">        return (byte) Integer.parseInt(inHex, 16);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    //1字节转2个Hex字符</span><br><span class=\"line\">    public static String Byte2Hex(Byte inByte) &#123;</span><br><span class=\"line\">        return String.format(&quot;%02x&quot;, new Object[]&#123;inByte&#125;).toUpperCase();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    //字节数组转转hex字符串</span><br><span class=\"line\">    public static String ByteArrToHex(byte[] inBytArr) &#123;</span><br><span class=\"line\">        StringBuilder strBuilder = new StringBuilder();</span><br><span class=\"line\">        for (byte valueOf : inBytArr) &#123;</span><br><span class=\"line\">            strBuilder.append(Byte2Hex(Byte.valueOf(valueOf)));</span><br><span class=\"line\">            strBuilder.append(&quot; &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return strBuilder.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    //字节数组转转hex字符串，可选长度</span><br><span class=\"line\">    public static String ByteArrToHex(byte[] inBytArr, int offset, int byteCount) &#123;</span><br><span class=\"line\">        StringBuilder strBuilder = new StringBuilder();</span><br><span class=\"line\">        int j = byteCount;</span><br><span class=\"line\">        for (int i = offset; i &lt; j; i++) &#123;</span><br><span class=\"line\">            strBuilder.append(Byte2Hex(Byte.valueOf(inBytArr[i])));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return strBuilder.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ascii byte数 组转成String字符串，可选长度</span><br><span class=\"line\">    public static String byteOfASCIIToString(byte[] inBytArr, int offset, int byteCount)&#123;</span><br><span class=\"line\">        StringBuilder strBuilder = new StringBuilder();</span><br><span class=\"line\">        int j = byteCount;</span><br><span class=\"line\">        for (int i = offset; i &lt; j; i++) &#123;</span><br><span class=\"line\">            char c=(char)inBytArr[i];</span><br><span class=\"line\">            strBuilder.append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return strBuilder.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    //-------------------------------------------------------</span><br><span class=\"line\">    //转hex字符串转字节数组</span><br><span class=\"line\">    public static byte[] HexToByteArr(String inHex) &#123;</span><br><span class=\"line\">        byte[] result;</span><br><span class=\"line\">        int hexlen = inHex.length();</span><br><span class=\"line\">        if (isOdd(hexlen) == 1) &#123;</span><br><span class=\"line\">            hexlen++;</span><br><span class=\"line\">            result = new byte[(hexlen / 2)];</span><br><span class=\"line\">            inHex = &quot;0&quot; + inHex;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            result = new byte[(hexlen / 2)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int j = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; hexlen; i += 2) &#123;</span><br><span class=\"line\">            result[j] = HexToByte(inHex.substring(i, i + 2));</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 按照指定长度切割字符串</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param inputString 需要切割的源字符串</span><br><span class=\"line\">     * @param length      指定的长度</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static List&lt;String&gt; getDivLines(String inputString, int length) &#123;</span><br><span class=\"line\">        List&lt;String&gt; divList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        int remainder = (inputString.length()) % length;</span><br><span class=\"line\">        // 一共要分割成几段</span><br><span class=\"line\">        int number = (int) Math.floor((inputString.length()) / length);</span><br><span class=\"line\">        for (int index = 0; index &lt; number; index++) &#123;</span><br><span class=\"line\">            String childStr = inputString.substring(index * length, (index + 1) * length);</span><br><span class=\"line\">            divList.add(childStr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (remainder &gt; 0) &#123;</span><br><span class=\"line\">            String cStr = inputString.substring(number * length, inputString.length());</span><br><span class=\"line\">            divList.add(cStr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return divList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 计算长度，两个字节长度</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param val value</span><br><span class=\"line\">     * @return 结果</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static String twoByte(String val) &#123;</span><br><span class=\"line\">        if (val.length() &gt; 4) &#123;</span><br><span class=\"line\">            val = val.substring(0, 4);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            int l = 4 - val.length();</span><br><span class=\"line\">            for (int i = 0; i &lt; l; i++) &#123;</span><br><span class=\"line\">                val = &quot;0&quot; + val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 校验和</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param cmd 指令</span><br><span class=\"line\">     * @return 结果</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static String sum(String cmd) &#123;</span><br><span class=\"line\">        List&lt;String&gt; cmdList = DataUtils.getDivLines(cmd, 2);</span><br><span class=\"line\">        int sumInt = 0;</span><br><span class=\"line\">        for (String c : cmdList) &#123;</span><br><span class=\"line\">            sumInt += DataUtils.HexToInt(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String sum = DataUtils.IntToHex(sumInt);</span><br><span class=\"line\">        sum = DataUtils.twoByte(sum);</span><br><span class=\"line\">        cmd += sum;</span><br><span class=\"line\">        return cmd.toUpperCase();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static int str8ToInt(String[] str)&#123;</span><br><span class=\"line\">        int sum=0;</span><br><span class=\"line\">        for(int i=0;i&lt;str.length;i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            int value=computerBinary(str[i],str.length-1-i);</span><br><span class=\"line\"></span><br><span class=\"line\">            sum+=value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static int str8ToInt(String str)&#123;</span><br><span class=\"line\">        int sum=0;</span><br><span class=\"line\">        for(int i=0;i&lt;str.length();i++)&#123;</span><br><span class=\"line\">            String strIndex=str.charAt(i)+&quot;&quot;;</span><br><span class=\"line\">            int value=computerBinary(strIndex,str.length()-1-i);</span><br><span class=\"line\"></span><br><span class=\"line\">            sum+=value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private static int computerBinary(String c, int index) &#123;</span><br><span class=\"line\">        int vaule=Integer.valueOf(c);</span><br><span class=\"line\">        for(int i=0;i&lt;index;i++)&#123;</span><br><span class=\"line\">            vaule*=2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return vaule;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/Deemonser/AndroidSerialPort\" target=\"_blank\" rel=\"noopener\">GitHub地址</a><br><a href></a></p>\n"},{"title":"《大话数据结构》","date":"2017-03-30T09:38:41.000Z","_content":"## 第一章\n### 一、名词解释\n1、 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合\n\n2、 数据：是描述客观事物的符号，是计算机中可以操作的对象是能被计算机识别；并输入计算机处理的符号集合\n\n3、 数据元素：是组成数据的有一定意义的基本单位，在计算机中通常作为整体处理；也被称为记录\n\n4、 数据项：一个数据元素可以由若干个数据项组成\n\n5、 数据项是数据不可分割的最小单位\n\n6、 数据对象：是性质相同的数据元素的集合，是数据的子集\n\n7、 逻辑结构：是指数据对象中元素之间的相互关系\n\n\t7.1、 集合结构：集合结构中的数据元素除了同属于一个集合处，它们之间没有其他关系\n\t\n\t7.2、 线性结构：数据元素之间是一对一的关系\n\t\n\t7.3、 树形结构：数据元素存在一种一对多的层次关系\n\t\n\t7.4、 图形结构：数据元素是多对多的关系\n\t\n8、 物理结构：是指数据的逻辑结构在计算机中存储形式\n\t\n\t8.1、 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的\n\t\n\t8.2、 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的\n\t\n9、 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称\n\t\n\t9.1、 原子类型：是不可以再分解的基本类型包括整型、实型、字符型等\n\t\n\t9.2、 结构类型：由若干个类型组合而成，是可以再分解的，例如：整型数组是由若干整型数据组成的\n\t\n10、 抽象数据类型（Abstract Data Type；ADT）是指一个数学模型及定义在该模型上的一组操作\n\n## 第二章 算法\n1、 算法：是解决特定问题解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作\n\t\n\t注：算法至少有一个或多个输出\n\n2、 算法的特性\n\t\n\t2.1 有穷性： 指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成\n\t\n\t2.2 确定性：算法的每一步骤都具有确定的含义，不会出现二义性\n\t\n\t2.3 可行性：算法的每一步都必须是可行的，也就是说每一步都能够通过执行有限次数完成\n\t\n3、 算法设计的要求\n\t\n\t3.1 正确性：算法的正确性是指算法至少应该具有输入，输出和加工处理无歧义性，能正确反映问题的需求能够得到问题的正确答案\n\t\n\t3.2 可读性：算法设计的另一目的是为了便于阅读理解和交流\n\t\n\t3.3 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果\n\t\n\t3.4 时间效率高和存储量低\n\t\n4、 算法效率的度量方法\n\t\n\t4.1 事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低\n\t\n\t4.2 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算\n\t\n\t注： 一个程序的运行时间，依赖于算法的好坏和问题的输入规模\n\t\n5、 函数的渐进增长：给定两个函数f（n）和g（n），如果存在一个整数N，使得对于所有的n>N,f(n)总是比g（n）大，那么我们说f（n）的增长渐进快于g（n）\n\n\t注： 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数\n\n6、 算法时间复杂度定义：在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级，算法的时间复杂度，也就是算法的时间度量，记作T（n）=O（f（n）），它表示随问题规模n的增长，算法执行时间的增长率和f（n）的增长率相同，称作算法的渐进时间复杂度。简称为时间复杂度，其中f（n）是问题规模n的某个函数。\n\n7、 推导大O阶\n\n\t7.1 用常数 1 取代运行时间中的所有加法常数。\n\t\n\t7.2 在修改后的运行次数函数中，只保留最高阶项\n\t\n\t7.3 如果最高阶存在且不是 1，则去除与这个项相乘的常数，得到的结果就是大O阶\n\t\n8、 线性阶\n\n9、 对数阶：O（log n）\n\n10、 平方阶： O（n*n）\n\n11、 常见的时间复杂度\n\t\n| 执行次数的函数     | 阶| 非正式术语|\n|:--------|---------:|:-------:|\n| 12 \t\t\t\t  | O（1） | 常数阶      |\n| 2*n+3            | O（n）   | 线性阶      |\n| 3*n^2+2*n+1     | O（n^2） | 平方阶      |\n| 5*log_2 n+20    | O（log_n）   | 对数阶      |\n| 2*n+3*n*log_2 n+19     | O（n*log_n）   | n*log_n阶      |\n| 6*n^3+2*n^2+3n+4           | O（n^3）   | 立方阶      |\n| 2^n           | O（2^n）   | 指数阶      |\n\n12、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了，在应用中，这里一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间\n\n13、算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S（n）=O（f（n）），其中，n为问题的规模，f（n）为语句关于n所占存储空间的函数\n\n## 第三章 线性表\n\n1、 线性表：零个或多个数据元素的有限序列\n\n2、 若将线性表记为（a_1,...,a_i-1,a_i,a_i+1,...,a_n）,则表中a_i-1领先于a_i,a_i领先于a_i+1,称a_i-1是a_i的直接前驱元素，a_i+1是a_i的直接后继元素。当i=1,2,...,n-1时，a_i有仅有一个后继元素，当i=2，3，...,n时，a_i有仅有一个直接前驱。\n\n\t注：1） 线性表元素的个数n（n>=0）定义为线性表的长度，当n=0时，称为空表。\n\t\n\t\t2） 在较复杂的线性表中，一个数据元素可以由若干个数据项组成\n\n3、 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素\n\t\n\t属性：\n\t\t1） 存储空间的启始位置\n\t\t2） 线性表的最大存储位置\n\t\t3） 线性表的当前长度\n\t\t\n4、 线性表顺序存储结构优缺点\n\t\n\t优点\n\t\t1） 无须为表中元素之间的逻辑关系而增加额外的存储空间\n\t\t2） 可以快速地存取表中任一位置的元素\n\t\t\n\t缺点\n\t\t1） 插入和删除操作需要移动大量元素\n\t\t2） 当线性表长度变化较大时，难以确定存储空间的容量\n\t\t3） 造成存储空间的“碎片”\n\t\t\n5、 线性表的链式存储结构的特点是用任一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。\n\n6、 为了表示每个数据元素a_i与其直接后继数据元素a_i+1之间的逻辑关系，对数据元素a_i来说，除来存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链，这两部分信息组成数据元素a_i的存储映像，称为节点（Node）。\n\tn个结点（a_i的存储映像）链结成一个链表，即为线性表（a_i,a_2,...a_n）的链式存储结构，因此链表的每个结点中包含一个指针域，所以叫做单链表\n\t\n7、 单链表结构与顺序存储结构优缺点\n\t\n\t1） 存储分配方式\n\t\t*  顺序存储结构用一段连续的存储单元依次存储线性表的数据元素\n\t\t*  单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素\n\t\t\n\t2）时间性能\n\t\t*  查找\n\t\t\t1） 顺序存储结构O（1）\n\t\t\t2） 单链表O（n）\n\t\t*  插入和删除\n\t\t\t1） 顺序存储结构需要平均移动表长一半的元素，时间为O（n）\n\t\t\t2） 单链表在线出某位置的指针后，插入和删除时间仅为O（1）\n\t\t\t\n\t\t*  空间性能\n\t\t\t1） 顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢\n\t\t\t2） 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制\n\t\n### 8、 静态链表：用数组描述的链表叫做静态链表\n\n9、 静态链表的优缺点：\n\t\n\t*  优点\n\t\t1） 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中插入和删除操作需要移动大量元素的缺点\n\t*  缺点\n\t\t1） 没有解决连续存储分配带来的表长难以确定的问题\n\t\t2） 失去了顺序存储结构随机存取的特性\n\t\n10、 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表\n\n11、 双向链表（double linked list）是在单链表的每个结点，再设置一个指向其前驱结点的指针域\t\t\n\n## 第四章 线性表\n1、 栈（stack）是限定仅在表尾进行插入和删除操作的线性表\n\n\t注：允许插入和删除的一端称为栈顶（top）另一端称为栈底（bootom），不含任何数据元素的栈称为空栈，栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构\n\t\n2、 栈的顺序存储结构\n\n3、 两栈共享空间\n\n4、 栈的链式存储结构，简称为链栈\n\n\t注： 如果栈的使用过程中元素变化不可预料，有时很小，有时很大，那么最好用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些\n\t\n5、 栈的应用--递归\n\n6、 斐波那契数列实现\n\n7、 递归定义： 把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数\n\n8、 每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出\n\n9、 迭代和递归的区别是： 迭代使用的是循环结构；递归使用的是选择结构\n\n10、 栈的应用--四则运算表达式求值\n\t\n\t10.1  后缀（逆波兰）表示法定义\n\n11、 中缀表达式转后缀表达式\n\n12、 队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表\n\n\t注： 队列是一种先进先出（Fist In First Out）的线性表，简称FIFO，允许插入的一端为对尾，允许删除的一端称为对头\n\t\n13、 队列顺序存储\n\n14、 循环队列定义： 头尾相接的顺序存储结构称为循环队列\n\n15、 队列的链式存储结构： 其实就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列\n\n\t注：可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时则用链队列\n\t\n## 第五章 串\n1、 串（String）是由零个或多个字符组成的有限序列，又名叫字符串\n\n2、 串的顺序存储结构\n\n3、串的链式存储结构\n\n\t注：串的链式存储结构除了在连接串与串操作有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好\n\t\n\n4、 朴素的模式匹配算法\n\n5、 KMP模式匹配算法\n\n7、 KMP模式匹配算法改进\n\n**练习**\n\t\n\t《璇玑图》破解诗篇的算法\n\t\n## 第六章 树 \t\n1、 树（Tree）是n（n>=0）个结点的有限集。n=0时称为空树，在任意一棵非空树中\n\t\n\t1） 有且仅有一个特定的称为根（root）的结点；\n\t2） 当n>1时，其余结点可分为m（m>0）个互不相交的有限集T_1,T_2,...、T_m,其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）如图6-2-1 所示。\n\t\n2、 结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点的度的最大值\n\n3、 结点的子树的根称为该结点的孩子（child）相应地，该结点称为孩子的双亲\n\n4、 同一个双亲的孩子之间互称兄弟（sibling）结点的祖先是从根到该结点所经分支上的所有结点，以某结点为根的子树中的任一结点都称为该结点的子孙\n\n5、 结点的层次（level）从根开始定义起，根为第一层；根的孩子为第二层\n\n6、 双亲在同一层的结点互为堂兄弟\n\n7、 树中结点的最大层次称为树的深度（Depth）或高度\n\n8、如果将树中结点的各个子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树\n\n9、 森林（Forest）是m（m>=0）棵互不相交的树的集合\n\n10、 双亲表示法：在每个结点中，附设一个指示器指示其双亲结点在树组中的位置\n\n11、 存储结构的设计是一个非常灵活的过程，一个存储结构设计得是否合理，取决于基于该存储结构的运算是否合适，是否方便，时间复杂度好不好等\n\n12、 每个结点有多个指针域；其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表表示法\n\n13、孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有 n 个孩子链表，如果是叶子结点则次单链表为空，然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维中\n\n14、 孩子兄弟表示法： 任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的左兄弟如果存在也是唯一的，因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟\n\n15、 二叉树（Binary Tree）是 n （n>=0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成\n\n16、 二叉树五种形态\n\t\n\t16.1 空二叉树\n\t16.2 只有一个根结点\n\t16.3 根结点只有左子树\n\t16.4 根结点只有右子树\n\t16.5 根结点既有左子树又有右子树\n\t\n17、 斜树：所有的结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树\n\n18、 满二叉树： 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。\n\n19、 完全二叉树： 对一棵具有 n 个结点的二叉树按层序编号，如果编号为i（1<=i<=n）的结点与同样深度的满二叉树中编号为i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树\n\n20、 二叉树的性质\n\t\n\t20.1 在二叉树的第 i 层中至多有2^i-1个结点（i>=1）\n\t\n\t20.2 深度为k 的二叉树至多有（2^k）-1个结点（k>=1）\n\t\n\t20.3 对任何一棵二叉树T，如果其终端结点数为 n_0,度为2的结点数为n_2;则 n_0=n_2+1\n\t\n\t20.4 具有 n 个结点的完全二叉树的深度为【log_2 n】+1(|x|表示不大于x的最大整数)\n\t\n\t20.5 如果对一棵有 n 个结点的完全二叉树（其深度为【log_2 n】+1）的结点按层序编号（从第1层到【log_2 n】+1层，每个层从左到右），对任一结点 i (i<=i<=n)有：\n\t\t20.5.1 如果i=1，则其双亲是结点【i／2】\n\t\t20.5.2 如果2*i>n;则结点 i 无左孩子（结点 i 为叶子结点）；否则左孩子是结点2*i\n\t\t20.5.3 如果2*i+1>n,则结点 i 无右孩子，否则右孩子结点2*i+1\n\t\t\n21、 二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等\n\n22、 二叉链表： 二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，这样称的链表叫做二叉树\n\n23、 二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点使得每个结点被访问一次且仅被访问一次\n\n24、 前序遍历：规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树\n\n25、 中序遍历： 规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点最后中序遍历右子树\n\n26、 后序遍历： 树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点\n\n27、 层序遍历：若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点，逐个访问\n\n28、 指向前驱荷后继的指针称为线索；加上线索的二叉树称为线索链表，相应地二叉树就称为线索二叉树（Threaded Binary Tree）\n\t\n\t注： 如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱荷后继，那么采用线索二叉链表的存储结构就是非常不错的选择\n\t\n29、 赫夫曼树及其应用 --最基本压缩编码方法\n\n30、 设需要编码的字符集为{d_1,d_2,...,d_n} 各个字符在电文中出现的次数或频率集合为{w_1,w_2,...,w_n} 以d_1,d_2,...,d_n作为叶子结点，以w_1,w_2,...,w_n 作为相应叶子结点的权值来构造一棵赫夫曼树，规定赫夫曼树的左分支代表O，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的O和1的序列便为该结点对应字符的编码；这就是赫夫曼编码\n\n## 第七章 图\n1、 图（Graph）是由顶点的有穷非空集合和顶点之间的集合组成，通常表示为G（V，E），其中，G表示一个图，V是图，G中顶点的集合，E是图G中边的集合\n\n2、 有向边：若从顶点V_i 到V_j的边有方向，则称这条边为有向边，也称为弧（Arc）\n\n3、 在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单的图\n\n4、 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图\n\n5、 有很少边或弧的图称为稀疏图，反之称为稠密图\n\n6、 路径的长度是路径上的边或弧的数目。第一个顶点到最后一个顶点相同的路径称为回路或环。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点最后一个顶点之外，其余顶点不重复出现回路称为简单回路\n\n7、 在无向图G中，如果从顶点V到V1有路径，则称V和V1是连通的。如果对于图中任意两个顶点V_i,Vj属于V，Vi和Vj是连通的，则称G是连通图（Connected Graph）\n\n8、 无向图中的极大连通子图称为连通分量\n\n9、 在有向量图G中，如果对于每一对Vi，Vj属于V，Vi不等于Vj从Vi到Vj 和从Vj到Vi都存在路径，则称G是强连通图，有向图中的极大强连通子图称做有向图的强连通分量\n\n10、 图的邻接矩阵（Adjacency Matrix）存储方式，是用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息\n\n11、 邻接表：数组与链表相结合的存储方法称为邻接表\n\n12、 十子链表：能把邻接表与逆邻接表结合起来\n\n13、 ivex和jvex 是与某条边依附的两个顶点在顶点表中的下标，ilink 指向依附顶点ivex的下一条边，jlink 指向依附顶点jvex的下一条边。这就是邻接多重表结构\n\n14、 边集数组：是由两个一维数组构成。一个是存储顶点的信息，另一个是存储边的信息。这个边数组每个数据元素由一条边的起点下标（begin），终点下标（end）和权（weight）组成\n\n15、 深度优先遍历：也就称为深度优先搜索，简称为DFS\n\n16、 广度优先遍历：又称为广度优先搜索，简称BFS\n\n17、 我们把构造连通网的最少代价生成树称为最小生成树\n\n18、 普里姆算法\n\n19、 克鲁斯卡贝算法\n\n20、 最短路径 对于网图来说：最短路径：是指两顶点之间经过的边上权值之和最少的路径，并且我们称路经上的第一个顶点是源点，最后一个顶点是终点\n\n21、 迪杰斯特拉算法\n\n22、弗洛伊德算法： 如果你面临需要所有顶点至所有顶点的最短路径问题时，弗洛伊德算法应该是不错的选择\n\n23、 拓扑排序：在一个表示工程的有向图中，用顶点表示活动用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网（Activing On Vertex Network）\n\t拓扑排序：其实就是对一个有向图构造拓扑序排的过程\n\t\n24、 关键路径：路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动\n\n\n## 第八章 查找\n1、 查找表（Search Table） 是由同一类型的数据元素（或记录）构成的集合\n\n2、 关键字（Key）是数据元素中某个数据项的值\n\n3、 查找（Searching）就是根据给定某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）\n\n4、 静态查找表（Static Search Table）：只作查找操作的查找表\n\n5、 动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从表中删除已经存在的某个数据元素\n\n6、 顺序查找（Sequential Search）：又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功\n\n7、 折半查找（Binary Search） 时间复杂度（O_log n）\n\n8、 插值查找（Interpolation Search）是根据要查找的关键字key 与 查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式\n\t\tkey-a【low】\n\t-------------------\n\t\ta【high】-a【low】\n\n9、 **斐波那契查找**\n\n10、 折半查找是进行加法与除法运算 mid=（low + high）／2），插值查找进行复杂的四则运算\n\t（mid=low + （high-low））*（key-a【low】）／（a【high】-a【low】），\n\t而斐波那契查找只是最简单加减法运算（mid=low+F【k-1】-1），在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率\n\t\n11、 索引就是把一个关键字与它对应的记录相关联的过程\n\n12、 索引按照结构可以分为线性索引、树型索引和多级索引\n\n13、 线性索引就是将索引项集合组织为线性结构也称为索引表\n\n14、 稠密索引：将数据集中的每个记录对应一个索引项\n\n\t注：对于稠密索引这个索引来说，索引项一定是按照关键码有序的排列\n\t\n15、 分块索引： 是把数据集的记录分成了若干块，并且这些块需要满足两个条件\n\n\t15.1 块内无序 即每一块内的记录不要求有序\n\t\n\t15.2 块间有序\n\t\n\t15.3 最大关键码： 它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大\n\t\n\t15.4 存储了块中的记录个数，以便于循环时使用\n\t\n\t15.5 用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历\n\t\n\t\n16、 倒排索引\n\n17、 其中记录号表存储具有相同次关键字的所有记录号（可以是指向记录的指针或者是该记录的主关键字），这样的索引方法就是倒排索引（inverted index）\n\n18、 二叉排列树（Binary Sort Tree）又称为二叉查找树，它或者是一棵空树，或者是具有下列性质的二叉树\n\t\n\t18.1 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值\n\t\n\t18.2 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值\n\t\n\t18.3 它的左右子树也分别为二叉排列树\n\n19、 二叉排序树插入操作\n\n20、 平衡二叉树（Self-Balancing Binary Search Tree 或Height-Balanced Binary Search Tree）是一种二叉树，其中一个节点的左子树和右子树的高度差至多等于1\n\n21、 将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor）\n\n\t注：距离插入结点最近的，且平衡因子的绝对值大于1 的结点为根的子树，称为最小不平衡子树\n\t\n\n22、 多路查找树（muitl - way Search tree） 其每一个结点的孩子树可以多于两个，且每一个结点处可以存储对过元素\n\n23、 2-3树：是这样一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为 3 结点）\n\t23.1 一个2 结点包含一个元素和两个孩子，一个3 结点包含一小一大两个元素和三个孩子\n\t\n24、 2-3-4树：就是2-3树的概念扩展，包括了4结点的使用，一个4结点包含小、中大三个元素和四个孩子（或没有孩子）\n\n25、 B树（B-tree）是一种平衡的多路查找树\n\n26、 B+树的结构特别适合带有范围的查找，比如查找我们学校18～22岁的学生人数\n\n27、 散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）\n\n\t注：这种对应关系f称为散列函数，又称为哈希（Hash）函数，按这个思想采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）\n\t\n28、 散列技术既是一种存储方法，也是一种查找方法\n\n29、 散列技术最适合的求解问题是查找与给定值相等的记录\n\n30、 散列函数因素参与：\n\t\n\t30.1 计算散列地址所需的时间\n\t\n\t30.2 关键字的长度\n\t\n\t30.3 散列表的大小\n\t\n\t30.4 关键字的分布情况\n\t\n\t30.5 记录查找的频率，综合这些因素\n\t\n31、 开放定址法： 一旦发生了冲突；就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入\n\n\tf（key）=（f（key）+d_i）MODm(d_i=1,2,3,..,m-1)\n解决冲突的开放地址法称为线性探测法增加平方运算的目的是为了不让关键字都聚集在某一块区域我们称这种方法为二次探测法\n\n\tf_i(key)=(f(key)+d_i)MOD m (d_i=1^2,-1^2,2^2,-2^2,...,q^2,-q^2) q<=m/2\n在冲突时，对于移量d_i采用随机函数i+算得到，我们称之为随机探测法 \n\n## 第九章 排序\n1、 排序：假设含有n个记录的序列为{r_1,r_2,...,r_n},其相应的关键字分别为{k_1,k_2,...,k_n},需确定1，2，。。。n的一种排列p_1,p_2,...,p_n,使其相应的关键字满足k_p1<=k_p2<=···<=k_pn非递减（或非递增）关系，即使序列成为一个按关键字有序的序列{r_p1,r_p2,...,r_pn},这样的操作就称为排序。\n\n2、 排序的稳定性：假设k_i=k_j(1<=i<=n,1<=j<=n,j!=j)且在排序前的序列中r_i;则称所用的排序方法是稳定；反之，若可能使得排序后的序列r_i领先r_2,则称所用的排序方法是不稳定的。\n\n3、 内排序与外排序：内排序是在整个排序过程中，待排序的所有记录全部被放置在内存中。\n\t\t\t\t\t外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行\n\t\t\t\t\t\n\t\t\t\t\t3.1 时间性能\n\t\t\t\t\t3.2 辅助空间\n\t\t\t\t\t3.3 算法的复杂性\n\n4、 插入排序；交换排序；选择排序和归并排序\n\n5、 七种排序算法\n\t\n\t5.1 简单算法：冒泡排序；简单选择排序；直接插入排序\n\t\n\t5.2 改进算法：希尔排序；堆排序；归并排序；快速排序\n\n6、 冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止\n\n\t6.1 冒泡排序优化，时间复杂度O（n^2）\n7、 简单选择排序算法（Simple selection Sort）就是通过n-i 次关键字间比较，从n-i+1记录中选出关键字最小的记录，并和第i（1<=i<=n）个记录交换之 时间复杂度O（n^2）\n\n8、 直接插入排序算法（Straight Insertion Sort）基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表 时间复杂度O（n^2）\n\n9、 希尔排序\n\n10、 希尔排序原理：所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间。将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序\n\n11、 堆：堆是具有下列性质的完全二叉树；每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值；称为小顶堆\n\n12、 堆排序（Heap Sort）：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值。如此反复执行，便能得到一个有序序列\n\n13、 归并算法（Merging Sort）：假设初始序列含有 n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到【n/2】（【x】表示不小于x的最小整数）个长度为2或1的有序子序列，再两两归并，...如此重复，直至得到一个长度为n的有序序列为止，这种排序称为2路归并排序。\n时间复杂度O（n+log n）\n\n14、 快速排序算法：通过一趟排序将待记录分割成独立的两个部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的\n\n\n","source":"_posts/book-3_data-structure.md","raw":"---\ntitle: 《大话数据结构》\ndate: 2017-03-30 17:38:41\ntags: 数据结构 java\n---\n## 第一章\n### 一、名词解释\n1、 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合\n\n2、 数据：是描述客观事物的符号，是计算机中可以操作的对象是能被计算机识别；并输入计算机处理的符号集合\n\n3、 数据元素：是组成数据的有一定意义的基本单位，在计算机中通常作为整体处理；也被称为记录\n\n4、 数据项：一个数据元素可以由若干个数据项组成\n\n5、 数据项是数据不可分割的最小单位\n\n6、 数据对象：是性质相同的数据元素的集合，是数据的子集\n\n7、 逻辑结构：是指数据对象中元素之间的相互关系\n\n\t7.1、 集合结构：集合结构中的数据元素除了同属于一个集合处，它们之间没有其他关系\n\t\n\t7.2、 线性结构：数据元素之间是一对一的关系\n\t\n\t7.3、 树形结构：数据元素存在一种一对多的层次关系\n\t\n\t7.4、 图形结构：数据元素是多对多的关系\n\t\n8、 物理结构：是指数据的逻辑结构在计算机中存储形式\n\t\n\t8.1、 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的\n\t\n\t8.2、 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的\n\t\n9、 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称\n\t\n\t9.1、 原子类型：是不可以再分解的基本类型包括整型、实型、字符型等\n\t\n\t9.2、 结构类型：由若干个类型组合而成，是可以再分解的，例如：整型数组是由若干整型数据组成的\n\t\n10、 抽象数据类型（Abstract Data Type；ADT）是指一个数学模型及定义在该模型上的一组操作\n\n## 第二章 算法\n1、 算法：是解决特定问题解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作\n\t\n\t注：算法至少有一个或多个输出\n\n2、 算法的特性\n\t\n\t2.1 有穷性： 指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成\n\t\n\t2.2 确定性：算法的每一步骤都具有确定的含义，不会出现二义性\n\t\n\t2.3 可行性：算法的每一步都必须是可行的，也就是说每一步都能够通过执行有限次数完成\n\t\n3、 算法设计的要求\n\t\n\t3.1 正确性：算法的正确性是指算法至少应该具有输入，输出和加工处理无歧义性，能正确反映问题的需求能够得到问题的正确答案\n\t\n\t3.2 可读性：算法设计的另一目的是为了便于阅读理解和交流\n\t\n\t3.3 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果\n\t\n\t3.4 时间效率高和存储量低\n\t\n4、 算法效率的度量方法\n\t\n\t4.1 事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低\n\t\n\t4.2 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算\n\t\n\t注： 一个程序的运行时间，依赖于算法的好坏和问题的输入规模\n\t\n5、 函数的渐进增长：给定两个函数f（n）和g（n），如果存在一个整数N，使得对于所有的n>N,f(n)总是比g（n）大，那么我们说f（n）的增长渐进快于g（n）\n\n\t注： 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数\n\n6、 算法时间复杂度定义：在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级，算法的时间复杂度，也就是算法的时间度量，记作T（n）=O（f（n）），它表示随问题规模n的增长，算法执行时间的增长率和f（n）的增长率相同，称作算法的渐进时间复杂度。简称为时间复杂度，其中f（n）是问题规模n的某个函数。\n\n7、 推导大O阶\n\n\t7.1 用常数 1 取代运行时间中的所有加法常数。\n\t\n\t7.2 在修改后的运行次数函数中，只保留最高阶项\n\t\n\t7.3 如果最高阶存在且不是 1，则去除与这个项相乘的常数，得到的结果就是大O阶\n\t\n8、 线性阶\n\n9、 对数阶：O（log n）\n\n10、 平方阶： O（n*n）\n\n11、 常见的时间复杂度\n\t\n| 执行次数的函数     | 阶| 非正式术语|\n|:--------|---------:|:-------:|\n| 12 \t\t\t\t  | O（1） | 常数阶      |\n| 2*n+3            | O（n）   | 线性阶      |\n| 3*n^2+2*n+1     | O（n^2） | 平方阶      |\n| 5*log_2 n+20    | O（log_n）   | 对数阶      |\n| 2*n+3*n*log_2 n+19     | O（n*log_n）   | n*log_n阶      |\n| 6*n^3+2*n^2+3n+4           | O（n^3）   | 立方阶      |\n| 2^n           | O（2^n）   | 指数阶      |\n\n12、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了，在应用中，这里一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间\n\n13、算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S（n）=O（f（n）），其中，n为问题的规模，f（n）为语句关于n所占存储空间的函数\n\n## 第三章 线性表\n\n1、 线性表：零个或多个数据元素的有限序列\n\n2、 若将线性表记为（a_1,...,a_i-1,a_i,a_i+1,...,a_n）,则表中a_i-1领先于a_i,a_i领先于a_i+1,称a_i-1是a_i的直接前驱元素，a_i+1是a_i的直接后继元素。当i=1,2,...,n-1时，a_i有仅有一个后继元素，当i=2，3，...,n时，a_i有仅有一个直接前驱。\n\n\t注：1） 线性表元素的个数n（n>=0）定义为线性表的长度，当n=0时，称为空表。\n\t\n\t\t2） 在较复杂的线性表中，一个数据元素可以由若干个数据项组成\n\n3、 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素\n\t\n\t属性：\n\t\t1） 存储空间的启始位置\n\t\t2） 线性表的最大存储位置\n\t\t3） 线性表的当前长度\n\t\t\n4、 线性表顺序存储结构优缺点\n\t\n\t优点\n\t\t1） 无须为表中元素之间的逻辑关系而增加额外的存储空间\n\t\t2） 可以快速地存取表中任一位置的元素\n\t\t\n\t缺点\n\t\t1） 插入和删除操作需要移动大量元素\n\t\t2） 当线性表长度变化较大时，难以确定存储空间的容量\n\t\t3） 造成存储空间的“碎片”\n\t\t\n5、 线性表的链式存储结构的特点是用任一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。\n\n6、 为了表示每个数据元素a_i与其直接后继数据元素a_i+1之间的逻辑关系，对数据元素a_i来说，除来存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链，这两部分信息组成数据元素a_i的存储映像，称为节点（Node）。\n\tn个结点（a_i的存储映像）链结成一个链表，即为线性表（a_i,a_2,...a_n）的链式存储结构，因此链表的每个结点中包含一个指针域，所以叫做单链表\n\t\n7、 单链表结构与顺序存储结构优缺点\n\t\n\t1） 存储分配方式\n\t\t*  顺序存储结构用一段连续的存储单元依次存储线性表的数据元素\n\t\t*  单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素\n\t\t\n\t2）时间性能\n\t\t*  查找\n\t\t\t1） 顺序存储结构O（1）\n\t\t\t2） 单链表O（n）\n\t\t*  插入和删除\n\t\t\t1） 顺序存储结构需要平均移动表长一半的元素，时间为O（n）\n\t\t\t2） 单链表在线出某位置的指针后，插入和删除时间仅为O（1）\n\t\t\t\n\t\t*  空间性能\n\t\t\t1） 顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢\n\t\t\t2） 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制\n\t\n### 8、 静态链表：用数组描述的链表叫做静态链表\n\n9、 静态链表的优缺点：\n\t\n\t*  优点\n\t\t1） 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中插入和删除操作需要移动大量元素的缺点\n\t*  缺点\n\t\t1） 没有解决连续存储分配带来的表长难以确定的问题\n\t\t2） 失去了顺序存储结构随机存取的特性\n\t\n10、 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表\n\n11、 双向链表（double linked list）是在单链表的每个结点，再设置一个指向其前驱结点的指针域\t\t\n\n## 第四章 线性表\n1、 栈（stack）是限定仅在表尾进行插入和删除操作的线性表\n\n\t注：允许插入和删除的一端称为栈顶（top）另一端称为栈底（bootom），不含任何数据元素的栈称为空栈，栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构\n\t\n2、 栈的顺序存储结构\n\n3、 两栈共享空间\n\n4、 栈的链式存储结构，简称为链栈\n\n\t注： 如果栈的使用过程中元素变化不可预料，有时很小，有时很大，那么最好用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些\n\t\n5、 栈的应用--递归\n\n6、 斐波那契数列实现\n\n7、 递归定义： 把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数\n\n8、 每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出\n\n9、 迭代和递归的区别是： 迭代使用的是循环结构；递归使用的是选择结构\n\n10、 栈的应用--四则运算表达式求值\n\t\n\t10.1  后缀（逆波兰）表示法定义\n\n11、 中缀表达式转后缀表达式\n\n12、 队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表\n\n\t注： 队列是一种先进先出（Fist In First Out）的线性表，简称FIFO，允许插入的一端为对尾，允许删除的一端称为对头\n\t\n13、 队列顺序存储\n\n14、 循环队列定义： 头尾相接的顺序存储结构称为循环队列\n\n15、 队列的链式存储结构： 其实就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列\n\n\t注：可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时则用链队列\n\t\n## 第五章 串\n1、 串（String）是由零个或多个字符组成的有限序列，又名叫字符串\n\n2、 串的顺序存储结构\n\n3、串的链式存储结构\n\n\t注：串的链式存储结构除了在连接串与串操作有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好\n\t\n\n4、 朴素的模式匹配算法\n\n5、 KMP模式匹配算法\n\n7、 KMP模式匹配算法改进\n\n**练习**\n\t\n\t《璇玑图》破解诗篇的算法\n\t\n## 第六章 树 \t\n1、 树（Tree）是n（n>=0）个结点的有限集。n=0时称为空树，在任意一棵非空树中\n\t\n\t1） 有且仅有一个特定的称为根（root）的结点；\n\t2） 当n>1时，其余结点可分为m（m>0）个互不相交的有限集T_1,T_2,...、T_m,其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）如图6-2-1 所示。\n\t\n2、 结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点的度的最大值\n\n3、 结点的子树的根称为该结点的孩子（child）相应地，该结点称为孩子的双亲\n\n4、 同一个双亲的孩子之间互称兄弟（sibling）结点的祖先是从根到该结点所经分支上的所有结点，以某结点为根的子树中的任一结点都称为该结点的子孙\n\n5、 结点的层次（level）从根开始定义起，根为第一层；根的孩子为第二层\n\n6、 双亲在同一层的结点互为堂兄弟\n\n7、 树中结点的最大层次称为树的深度（Depth）或高度\n\n8、如果将树中结点的各个子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树\n\n9、 森林（Forest）是m（m>=0）棵互不相交的树的集合\n\n10、 双亲表示法：在每个结点中，附设一个指示器指示其双亲结点在树组中的位置\n\n11、 存储结构的设计是一个非常灵活的过程，一个存储结构设计得是否合理，取决于基于该存储结构的运算是否合适，是否方便，时间复杂度好不好等\n\n12、 每个结点有多个指针域；其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表表示法\n\n13、孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有 n 个孩子链表，如果是叶子结点则次单链表为空，然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维中\n\n14、 孩子兄弟表示法： 任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的左兄弟如果存在也是唯一的，因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟\n\n15、 二叉树（Binary Tree）是 n （n>=0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成\n\n16、 二叉树五种形态\n\t\n\t16.1 空二叉树\n\t16.2 只有一个根结点\n\t16.3 根结点只有左子树\n\t16.4 根结点只有右子树\n\t16.5 根结点既有左子树又有右子树\n\t\n17、 斜树：所有的结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树\n\n18、 满二叉树： 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。\n\n19、 完全二叉树： 对一棵具有 n 个结点的二叉树按层序编号，如果编号为i（1<=i<=n）的结点与同样深度的满二叉树中编号为i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树\n\n20、 二叉树的性质\n\t\n\t20.1 在二叉树的第 i 层中至多有2^i-1个结点（i>=1）\n\t\n\t20.2 深度为k 的二叉树至多有（2^k）-1个结点（k>=1）\n\t\n\t20.3 对任何一棵二叉树T，如果其终端结点数为 n_0,度为2的结点数为n_2;则 n_0=n_2+1\n\t\n\t20.4 具有 n 个结点的完全二叉树的深度为【log_2 n】+1(|x|表示不大于x的最大整数)\n\t\n\t20.5 如果对一棵有 n 个结点的完全二叉树（其深度为【log_2 n】+1）的结点按层序编号（从第1层到【log_2 n】+1层，每个层从左到右），对任一结点 i (i<=i<=n)有：\n\t\t20.5.1 如果i=1，则其双亲是结点【i／2】\n\t\t20.5.2 如果2*i>n;则结点 i 无左孩子（结点 i 为叶子结点）；否则左孩子是结点2*i\n\t\t20.5.3 如果2*i+1>n,则结点 i 无右孩子，否则右孩子结点2*i+1\n\t\t\n21、 二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等\n\n22、 二叉链表： 二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，这样称的链表叫做二叉树\n\n23、 二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点使得每个结点被访问一次且仅被访问一次\n\n24、 前序遍历：规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树\n\n25、 中序遍历： 规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点最后中序遍历右子树\n\n26、 后序遍历： 树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点\n\n27、 层序遍历：若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点，逐个访问\n\n28、 指向前驱荷后继的指针称为线索；加上线索的二叉树称为线索链表，相应地二叉树就称为线索二叉树（Threaded Binary Tree）\n\t\n\t注： 如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱荷后继，那么采用线索二叉链表的存储结构就是非常不错的选择\n\t\n29、 赫夫曼树及其应用 --最基本压缩编码方法\n\n30、 设需要编码的字符集为{d_1,d_2,...,d_n} 各个字符在电文中出现的次数或频率集合为{w_1,w_2,...,w_n} 以d_1,d_2,...,d_n作为叶子结点，以w_1,w_2,...,w_n 作为相应叶子结点的权值来构造一棵赫夫曼树，规定赫夫曼树的左分支代表O，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的O和1的序列便为该结点对应字符的编码；这就是赫夫曼编码\n\n## 第七章 图\n1、 图（Graph）是由顶点的有穷非空集合和顶点之间的集合组成，通常表示为G（V，E），其中，G表示一个图，V是图，G中顶点的集合，E是图G中边的集合\n\n2、 有向边：若从顶点V_i 到V_j的边有方向，则称这条边为有向边，也称为弧（Arc）\n\n3、 在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单的图\n\n4、 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图\n\n5、 有很少边或弧的图称为稀疏图，反之称为稠密图\n\n6、 路径的长度是路径上的边或弧的数目。第一个顶点到最后一个顶点相同的路径称为回路或环。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点最后一个顶点之外，其余顶点不重复出现回路称为简单回路\n\n7、 在无向图G中，如果从顶点V到V1有路径，则称V和V1是连通的。如果对于图中任意两个顶点V_i,Vj属于V，Vi和Vj是连通的，则称G是连通图（Connected Graph）\n\n8、 无向图中的极大连通子图称为连通分量\n\n9、 在有向量图G中，如果对于每一对Vi，Vj属于V，Vi不等于Vj从Vi到Vj 和从Vj到Vi都存在路径，则称G是强连通图，有向图中的极大强连通子图称做有向图的强连通分量\n\n10、 图的邻接矩阵（Adjacency Matrix）存储方式，是用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息\n\n11、 邻接表：数组与链表相结合的存储方法称为邻接表\n\n12、 十子链表：能把邻接表与逆邻接表结合起来\n\n13、 ivex和jvex 是与某条边依附的两个顶点在顶点表中的下标，ilink 指向依附顶点ivex的下一条边，jlink 指向依附顶点jvex的下一条边。这就是邻接多重表结构\n\n14、 边集数组：是由两个一维数组构成。一个是存储顶点的信息，另一个是存储边的信息。这个边数组每个数据元素由一条边的起点下标（begin），终点下标（end）和权（weight）组成\n\n15、 深度优先遍历：也就称为深度优先搜索，简称为DFS\n\n16、 广度优先遍历：又称为广度优先搜索，简称BFS\n\n17、 我们把构造连通网的最少代价生成树称为最小生成树\n\n18、 普里姆算法\n\n19、 克鲁斯卡贝算法\n\n20、 最短路径 对于网图来说：最短路径：是指两顶点之间经过的边上权值之和最少的路径，并且我们称路经上的第一个顶点是源点，最后一个顶点是终点\n\n21、 迪杰斯特拉算法\n\n22、弗洛伊德算法： 如果你面临需要所有顶点至所有顶点的最短路径问题时，弗洛伊德算法应该是不错的选择\n\n23、 拓扑排序：在一个表示工程的有向图中，用顶点表示活动用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网（Activing On Vertex Network）\n\t拓扑排序：其实就是对一个有向图构造拓扑序排的过程\n\t\n24、 关键路径：路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动\n\n\n## 第八章 查找\n1、 查找表（Search Table） 是由同一类型的数据元素（或记录）构成的集合\n\n2、 关键字（Key）是数据元素中某个数据项的值\n\n3、 查找（Searching）就是根据给定某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）\n\n4、 静态查找表（Static Search Table）：只作查找操作的查找表\n\n5、 动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从表中删除已经存在的某个数据元素\n\n6、 顺序查找（Sequential Search）：又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功\n\n7、 折半查找（Binary Search） 时间复杂度（O_log n）\n\n8、 插值查找（Interpolation Search）是根据要查找的关键字key 与 查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式\n\t\tkey-a【low】\n\t-------------------\n\t\ta【high】-a【low】\n\n9、 **斐波那契查找**\n\n10、 折半查找是进行加法与除法运算 mid=（low + high）／2），插值查找进行复杂的四则运算\n\t（mid=low + （high-low））*（key-a【low】）／（a【high】-a【low】），\n\t而斐波那契查找只是最简单加减法运算（mid=low+F【k-1】-1），在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率\n\t\n11、 索引就是把一个关键字与它对应的记录相关联的过程\n\n12、 索引按照结构可以分为线性索引、树型索引和多级索引\n\n13、 线性索引就是将索引项集合组织为线性结构也称为索引表\n\n14、 稠密索引：将数据集中的每个记录对应一个索引项\n\n\t注：对于稠密索引这个索引来说，索引项一定是按照关键码有序的排列\n\t\n15、 分块索引： 是把数据集的记录分成了若干块，并且这些块需要满足两个条件\n\n\t15.1 块内无序 即每一块内的记录不要求有序\n\t\n\t15.2 块间有序\n\t\n\t15.3 最大关键码： 它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大\n\t\n\t15.4 存储了块中的记录个数，以便于循环时使用\n\t\n\t15.5 用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历\n\t\n\t\n16、 倒排索引\n\n17、 其中记录号表存储具有相同次关键字的所有记录号（可以是指向记录的指针或者是该记录的主关键字），这样的索引方法就是倒排索引（inverted index）\n\n18、 二叉排列树（Binary Sort Tree）又称为二叉查找树，它或者是一棵空树，或者是具有下列性质的二叉树\n\t\n\t18.1 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值\n\t\n\t18.2 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值\n\t\n\t18.3 它的左右子树也分别为二叉排列树\n\n19、 二叉排序树插入操作\n\n20、 平衡二叉树（Self-Balancing Binary Search Tree 或Height-Balanced Binary Search Tree）是一种二叉树，其中一个节点的左子树和右子树的高度差至多等于1\n\n21、 将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor）\n\n\t注：距离插入结点最近的，且平衡因子的绝对值大于1 的结点为根的子树，称为最小不平衡子树\n\t\n\n22、 多路查找树（muitl - way Search tree） 其每一个结点的孩子树可以多于两个，且每一个结点处可以存储对过元素\n\n23、 2-3树：是这样一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为 3 结点）\n\t23.1 一个2 结点包含一个元素和两个孩子，一个3 结点包含一小一大两个元素和三个孩子\n\t\n24、 2-3-4树：就是2-3树的概念扩展，包括了4结点的使用，一个4结点包含小、中大三个元素和四个孩子（或没有孩子）\n\n25、 B树（B-tree）是一种平衡的多路查找树\n\n26、 B+树的结构特别适合带有范围的查找，比如查找我们学校18～22岁的学生人数\n\n27、 散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）\n\n\t注：这种对应关系f称为散列函数，又称为哈希（Hash）函数，按这个思想采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）\n\t\n28、 散列技术既是一种存储方法，也是一种查找方法\n\n29、 散列技术最适合的求解问题是查找与给定值相等的记录\n\n30、 散列函数因素参与：\n\t\n\t30.1 计算散列地址所需的时间\n\t\n\t30.2 关键字的长度\n\t\n\t30.3 散列表的大小\n\t\n\t30.4 关键字的分布情况\n\t\n\t30.5 记录查找的频率，综合这些因素\n\t\n31、 开放定址法： 一旦发生了冲突；就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入\n\n\tf（key）=（f（key）+d_i）MODm(d_i=1,2,3,..,m-1)\n解决冲突的开放地址法称为线性探测法增加平方运算的目的是为了不让关键字都聚集在某一块区域我们称这种方法为二次探测法\n\n\tf_i(key)=(f(key)+d_i)MOD m (d_i=1^2,-1^2,2^2,-2^2,...,q^2,-q^2) q<=m/2\n在冲突时，对于移量d_i采用随机函数i+算得到，我们称之为随机探测法 \n\n## 第九章 排序\n1、 排序：假设含有n个记录的序列为{r_1,r_2,...,r_n},其相应的关键字分别为{k_1,k_2,...,k_n},需确定1，2，。。。n的一种排列p_1,p_2,...,p_n,使其相应的关键字满足k_p1<=k_p2<=···<=k_pn非递减（或非递增）关系，即使序列成为一个按关键字有序的序列{r_p1,r_p2,...,r_pn},这样的操作就称为排序。\n\n2、 排序的稳定性：假设k_i=k_j(1<=i<=n,1<=j<=n,j!=j)且在排序前的序列中r_i;则称所用的排序方法是稳定；反之，若可能使得排序后的序列r_i领先r_2,则称所用的排序方法是不稳定的。\n\n3、 内排序与外排序：内排序是在整个排序过程中，待排序的所有记录全部被放置在内存中。\n\t\t\t\t\t外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行\n\t\t\t\t\t\n\t\t\t\t\t3.1 时间性能\n\t\t\t\t\t3.2 辅助空间\n\t\t\t\t\t3.3 算法的复杂性\n\n4、 插入排序；交换排序；选择排序和归并排序\n\n5、 七种排序算法\n\t\n\t5.1 简单算法：冒泡排序；简单选择排序；直接插入排序\n\t\n\t5.2 改进算法：希尔排序；堆排序；归并排序；快速排序\n\n6、 冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止\n\n\t6.1 冒泡排序优化，时间复杂度O（n^2）\n7、 简单选择排序算法（Simple selection Sort）就是通过n-i 次关键字间比较，从n-i+1记录中选出关键字最小的记录，并和第i（1<=i<=n）个记录交换之 时间复杂度O（n^2）\n\n8、 直接插入排序算法（Straight Insertion Sort）基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表 时间复杂度O（n^2）\n\n9、 希尔排序\n\n10、 希尔排序原理：所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间。将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序\n\n11、 堆：堆是具有下列性质的完全二叉树；每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值；称为小顶堆\n\n12、 堆排序（Heap Sort）：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值。如此反复执行，便能得到一个有序序列\n\n13、 归并算法（Merging Sort）：假设初始序列含有 n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到【n/2】（【x】表示不小于x的最小整数）个长度为2或1的有序子序列，再两两归并，...如此重复，直至得到一个长度为n的有序序列为止，这种排序称为2路归并排序。\n时间复杂度O（n+log n）\n\n14、 快速排序算法：通过一趟排序将待记录分割成独立的两个部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的\n\n\n","slug":"book-3_data-structure","published":1,"updated":"2019-07-15T06:41:57.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy416swo001d80s6fs5e32je","content":"<h2 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h2><h3 id=\"一、名词解释\"><a href=\"#一、名词解释\" class=\"headerlink\" title=\"一、名词解释\"></a>一、名词解释</h3><p>1、 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合</p>\n<p>2、 数据：是描述客观事物的符号，是计算机中可以操作的对象是能被计算机识别；并输入计算机处理的符号集合</p>\n<p>3、 数据元素：是组成数据的有一定意义的基本单位，在计算机中通常作为整体处理；也被称为记录</p>\n<p>4、 数据项：一个数据元素可以由若干个数据项组成</p>\n<p>5、 数据项是数据不可分割的最小单位</p>\n<p>6、 数据对象：是性质相同的数据元素的集合，是数据的子集</p>\n<p>7、 逻辑结构：是指数据对象中元素之间的相互关系</p>\n<pre><code>7.1、 集合结构：集合结构中的数据元素除了同属于一个集合处，它们之间没有其他关系\n\n7.2、 线性结构：数据元素之间是一对一的关系\n\n7.3、 树形结构：数据元素存在一种一对多的层次关系\n\n7.4、 图形结构：数据元素是多对多的关系\n</code></pre><p>8、 物理结构：是指数据的逻辑结构在计算机中存储形式</p>\n<pre><code>8.1、 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的\n\n8.2、 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的\n</code></pre><p>9、 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</p>\n<pre><code>9.1、 原子类型：是不可以再分解的基本类型包括整型、实型、字符型等\n\n9.2、 结构类型：由若干个类型组合而成，是可以再分解的，例如：整型数组是由若干整型数据组成的\n</code></pre><p>10、 抽象数据类型（Abstract Data Type；ADT）是指一个数学模型及定义在该模型上的一组操作</p>\n<h2 id=\"第二章-算法\"><a href=\"#第二章-算法\" class=\"headerlink\" title=\"第二章 算法\"></a>第二章 算法</h2><p>1、 算法：是解决特定问题解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作</p>\n<pre><code>注：算法至少有一个或多个输出\n</code></pre><p>2、 算法的特性</p>\n<pre><code>2.1 有穷性： 指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成\n\n2.2 确定性：算法的每一步骤都具有确定的含义，不会出现二义性\n\n2.3 可行性：算法的每一步都必须是可行的，也就是说每一步都能够通过执行有限次数完成\n</code></pre><p>3、 算法设计的要求</p>\n<pre><code>3.1 正确性：算法的正确性是指算法至少应该具有输入，输出和加工处理无歧义性，能正确反映问题的需求能够得到问题的正确答案\n\n3.2 可读性：算法设计的另一目的是为了便于阅读理解和交流\n\n3.3 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果\n\n3.4 时间效率高和存储量低\n</code></pre><p>4、 算法效率的度量方法</p>\n<pre><code>4.1 事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低\n\n4.2 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算\n\n注： 一个程序的运行时间，依赖于算法的好坏和问题的输入规模\n</code></pre><p>5、 函数的渐进增长：给定两个函数f（n）和g（n），如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g（n）大，那么我们说f（n）的增长渐进快于g（n）</p>\n<pre><code>注： 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数\n</code></pre><p>6、 算法时间复杂度定义：在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级，算法的时间复杂度，也就是算法的时间度量，记作T（n）=O（f（n）），它表示随问题规模n的增长，算法执行时间的增长率和f（n）的增长率相同，称作算法的渐进时间复杂度。简称为时间复杂度，其中f（n）是问题规模n的某个函数。</p>\n<p>7、 推导大O阶</p>\n<pre><code>7.1 用常数 1 取代运行时间中的所有加法常数。\n\n7.2 在修改后的运行次数函数中，只保留最高阶项\n\n7.3 如果最高阶存在且不是 1，则去除与这个项相乘的常数，得到的结果就是大O阶\n</code></pre><p>8、 线性阶</p>\n<p>9、 对数阶：O（log n）</p>\n<p>10、 平方阶： O（n*n）</p>\n<p>11、 常见的时间复杂度</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">执行次数的函数</th>\n<th style=\"text-align:right\">阶</th>\n<th style=\"text-align:center\">非正式术语</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">12</td>\n<td style=\"text-align:right\">O（1）</td>\n<td style=\"text-align:center\">常数阶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2*n+3</td>\n<td style=\"text-align:right\">O（n）</td>\n<td style=\"text-align:center\">线性阶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3<em>n^2+2</em>n+1</td>\n<td style=\"text-align:right\">O（n^2）</td>\n<td style=\"text-align:center\">平方阶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5*log_2 n+20</td>\n<td style=\"text-align:right\">O（log_n）</td>\n<td style=\"text-align:center\">对数阶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2<em>n+3</em>n*log_2 n+19</td>\n<td style=\"text-align:right\">O（n*log_n）</td>\n<td style=\"text-align:center\">n*log_n阶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6<em>n^3+2</em>n^2+3n+4</td>\n<td style=\"text-align:right\">O（n^3）</td>\n<td style=\"text-align:center\">立方阶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2^n</td>\n<td style=\"text-align:right\">O（2^n）</td>\n<td style=\"text-align:center\">指数阶</td>\n</tr>\n</tbody>\n</table>\n<p>12、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了，在应用中，这里一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间</p>\n<p>13、算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S（n）=O（f（n）），其中，n为问题的规模，f（n）为语句关于n所占存储空间的函数</p>\n<h2 id=\"第三章-线性表\"><a href=\"#第三章-线性表\" class=\"headerlink\" title=\"第三章 线性表\"></a>第三章 线性表</h2><p>1、 线性表：零个或多个数据元素的有限序列</p>\n<p>2、 若将线性表记为（a_1,…,a_i-1,a_i,a_i+1,…,a_n）,则表中a_i-1领先于a_i,a_i领先于a_i+1,称a_i-1是a_i的直接前驱元素，a_i+1是a_i的直接后继元素。当i=1,2,…,n-1时，a_i有仅有一个后继元素，当i=2，3，…,n时，a_i有仅有一个直接前驱。</p>\n<pre><code>注：1） 线性表元素的个数n（n&gt;=0）定义为线性表的长度，当n=0时，称为空表。\n\n    2） 在较复杂的线性表中，一个数据元素可以由若干个数据项组成\n</code></pre><p>3、 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素</p>\n<pre><code>属性：\n    1） 存储空间的启始位置\n    2） 线性表的最大存储位置\n    3） 线性表的当前长度\n</code></pre><p>4、 线性表顺序存储结构优缺点</p>\n<pre><code>优点\n    1） 无须为表中元素之间的逻辑关系而增加额外的存储空间\n    2） 可以快速地存取表中任一位置的元素\n\n缺点\n    1） 插入和删除操作需要移动大量元素\n    2） 当线性表长度变化较大时，难以确定存储空间的容量\n    3） 造成存储空间的“碎片”\n</code></pre><p>5、 线性表的链式存储结构的特点是用任一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。</p>\n<p>6、 为了表示每个数据元素a_i与其直接后继数据元素a_i+1之间的逻辑关系，对数据元素a_i来说，除来存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链，这两部分信息组成数据元素a_i的存储映像，称为节点（Node）。<br>    n个结点（a_i的存储映像）链结成一个链表，即为线性表（a_i,a_2,…a_n）的链式存储结构，因此链表的每个结点中包含一个指针域，所以叫做单链表</p>\n<p>7、 单链表结构与顺序存储结构优缺点</p>\n<pre><code>1） 存储分配方式\n    *  顺序存储结构用一段连续的存储单元依次存储线性表的数据元素\n    *  单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素\n\n2）时间性能\n    *  查找\n        1） 顺序存储结构O（1）\n        2） 单链表O（n）\n    *  插入和删除\n        1） 顺序存储结构需要平均移动表长一半的元素，时间为O（n）\n        2） 单链表在线出某位置的指针后，插入和删除时间仅为O（1）\n\n    *  空间性能\n        1） 顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢\n        2） 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制\n</code></pre><h3 id=\"8、-静态链表：用数组描述的链表叫做静态链表\"><a href=\"#8、-静态链表：用数组描述的链表叫做静态链表\" class=\"headerlink\" title=\"8、 静态链表：用数组描述的链表叫做静态链表\"></a>8、 静态链表：用数组描述的链表叫做静态链表</h3><p>9、 静态链表的优缺点：</p>\n<pre><code>*  优点\n    1） 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中插入和删除操作需要移动大量元素的缺点\n*  缺点\n    1） 没有解决连续存储分配带来的表长难以确定的问题\n    2） 失去了顺序存储结构随机存取的特性\n</code></pre><p>10、 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表</p>\n<p>11、 双向链表（double linked list）是在单链表的每个结点，再设置一个指向其前驱结点的指针域        </p>\n<h2 id=\"第四章-线性表\"><a href=\"#第四章-线性表\" class=\"headerlink\" title=\"第四章 线性表\"></a>第四章 线性表</h2><p>1、 栈（stack）是限定仅在表尾进行插入和删除操作的线性表</p>\n<pre><code>注：允许插入和删除的一端称为栈顶（top）另一端称为栈底（bootom），不含任何数据元素的栈称为空栈，栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构\n</code></pre><p>2、 栈的顺序存储结构</p>\n<p>3、 两栈共享空间</p>\n<p>4、 栈的链式存储结构，简称为链栈</p>\n<pre><code>注： 如果栈的使用过程中元素变化不可预料，有时很小，有时很大，那么最好用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些\n</code></pre><p>5、 栈的应用–递归</p>\n<p>6、 斐波那契数列实现</p>\n<p>7、 递归定义： 把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数</p>\n<p>8、 每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</p>\n<p>9、 迭代和递归的区别是： 迭代使用的是循环结构；递归使用的是选择结构</p>\n<p>10、 栈的应用–四则运算表达式求值</p>\n<pre><code>10.1  后缀（逆波兰）表示法定义\n</code></pre><p>11、 中缀表达式转后缀表达式</p>\n<p>12、 队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表</p>\n<pre><code>注： 队列是一种先进先出（Fist In First Out）的线性表，简称FIFO，允许插入的一端为对尾，允许删除的一端称为对头\n</code></pre><p>13、 队列顺序存储</p>\n<p>14、 循环队列定义： 头尾相接的顺序存储结构称为循环队列</p>\n<p>15、 队列的链式存储结构： 其实就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列</p>\n<pre><code>注：可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时则用链队列\n</code></pre><h2 id=\"第五章-串\"><a href=\"#第五章-串\" class=\"headerlink\" title=\"第五章 串\"></a>第五章 串</h2><p>1、 串（String）是由零个或多个字符组成的有限序列，又名叫字符串</p>\n<p>2、 串的顺序存储结构</p>\n<p>3、串的链式存储结构</p>\n<pre><code>注：串的链式存储结构除了在连接串与串操作有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好\n</code></pre><p>4、 朴素的模式匹配算法</p>\n<p>5、 KMP模式匹配算法</p>\n<p>7、 KMP模式匹配算法改进</p>\n<p><strong>练习</strong></p>\n<pre><code>《璇玑图》破解诗篇的算法\n</code></pre><h2 id=\"第六章-树\"><a href=\"#第六章-树\" class=\"headerlink\" title=\"第六章 树\"></a>第六章 树</h2><p>1、 树（Tree）是n（n&gt;=0）个结点的有限集。n=0时称为空树，在任意一棵非空树中</p>\n<pre><code>1） 有且仅有一个特定的称为根（root）的结点；\n2） 当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集T_1,T_2,...、T_m,其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）如图6-2-1 所示。\n</code></pre><p>2、 结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点的度的最大值</p>\n<p>3、 结点的子树的根称为该结点的孩子（child）相应地，该结点称为孩子的双亲</p>\n<p>4、 同一个双亲的孩子之间互称兄弟（sibling）结点的祖先是从根到该结点所经分支上的所有结点，以某结点为根的子树中的任一结点都称为该结点的子孙</p>\n<p>5、 结点的层次（level）从根开始定义起，根为第一层；根的孩子为第二层</p>\n<p>6、 双亲在同一层的结点互为堂兄弟</p>\n<p>7、 树中结点的最大层次称为树的深度（Depth）或高度</p>\n<p>8、如果将树中结点的各个子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树</p>\n<p>9、 森林（Forest）是m（m&gt;=0）棵互不相交的树的集合</p>\n<p>10、 双亲表示法：在每个结点中，附设一个指示器指示其双亲结点在树组中的位置</p>\n<p>11、 存储结构的设计是一个非常灵活的过程，一个存储结构设计得是否合理，取决于基于该存储结构的运算是否合适，是否方便，时间复杂度好不好等</p>\n<p>12、 每个结点有多个指针域；其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表表示法</p>\n<p>13、孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有 n 个孩子链表，如果是叶子结点则次单链表为空，然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维中</p>\n<p>14、 孩子兄弟表示法： 任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的左兄弟如果存在也是唯一的，因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p>\n<p>15、 二叉树（Binary Tree）是 n （n&gt;=0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成</p>\n<p>16、 二叉树五种形态</p>\n<pre><code>16.1 空二叉树\n16.2 只有一个根结点\n16.3 根结点只有左子树\n16.4 根结点只有右子树\n16.5 根结点既有左子树又有右子树\n</code></pre><p>17、 斜树：所有的结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树</p>\n<p>18、 满二叉树： 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p>\n<p>19、 完全二叉树： 对一棵具有 n 个结点的二叉树按层序编号，如果编号为i（1&lt;=i&lt;=n）的结点与同样深度的满二叉树中编号为i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</p>\n<p>20、 二叉树的性质</p>\n<pre><code>20.1 在二叉树的第 i 层中至多有2^i-1个结点（i&gt;=1）\n\n20.2 深度为k 的二叉树至多有（2^k）-1个结点（k&gt;=1）\n\n20.3 对任何一棵二叉树T，如果其终端结点数为 n_0,度为2的结点数为n_2;则 n_0=n_2+1\n\n20.4 具有 n 个结点的完全二叉树的深度为【log_2 n】+1(|x|表示不大于x的最大整数)\n\n20.5 如果对一棵有 n 个结点的完全二叉树（其深度为【log_2 n】+1）的结点按层序编号（从第1层到【log_2 n】+1层，每个层从左到右），对任一结点 i (i&lt;=i&lt;=n)有：\n    20.5.1 如果i=1，则其双亲是结点【i／2】\n    20.5.2 如果2*i&gt;n;则结点 i 无左孩子（结点 i 为叶子结点）；否则左孩子是结点2*i\n    20.5.3 如果2*i+1&gt;n,则结点 i 无右孩子，否则右孩子结点2*i+1\n</code></pre><p>21、 二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等</p>\n<p>22、 二叉链表： 二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，这样称的链表叫做二叉树</p>\n<p>23、 二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点使得每个结点被访问一次且仅被访问一次</p>\n<p>24、 前序遍历：规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树</p>\n<p>25、 中序遍历： 规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点最后中序遍历右子树</p>\n<p>26、 后序遍历： 树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点</p>\n<p>27、 层序遍历：若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点，逐个访问</p>\n<p>28、 指向前驱荷后继的指针称为线索；加上线索的二叉树称为线索链表，相应地二叉树就称为线索二叉树（Threaded Binary Tree）</p>\n<pre><code>注： 如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱荷后继，那么采用线索二叉链表的存储结构就是非常不错的选择\n</code></pre><p>29、 赫夫曼树及其应用 –最基本压缩编码方法</p>\n<p>30、 设需要编码的字符集为{d_1,d_2,…,d_n} 各个字符在电文中出现的次数或频率集合为{w_1,w_2,…,w_n} 以d_1,d_2,…,d_n作为叶子结点，以w_1,w_2,…,w_n 作为相应叶子结点的权值来构造一棵赫夫曼树，规定赫夫曼树的左分支代表O，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的O和1的序列便为该结点对应字符的编码；这就是赫夫曼编码</p>\n<h2 id=\"第七章-图\"><a href=\"#第七章-图\" class=\"headerlink\" title=\"第七章 图\"></a>第七章 图</h2><p>1、 图（Graph）是由顶点的有穷非空集合和顶点之间的集合组成，通常表示为G（V，E），其中，G表示一个图，V是图，G中顶点的集合，E是图G中边的集合</p>\n<p>2、 有向边：若从顶点V_i 到V_j的边有方向，则称这条边为有向边，也称为弧（Arc）</p>\n<p>3、 在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单的图</p>\n<p>4、 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图</p>\n<p>5、 有很少边或弧的图称为稀疏图，反之称为稠密图</p>\n<p>6、 路径的长度是路径上的边或弧的数目。第一个顶点到最后一个顶点相同的路径称为回路或环。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点最后一个顶点之外，其余顶点不重复出现回路称为简单回路</p>\n<p>7、 在无向图G中，如果从顶点V到V1有路径，则称V和V1是连通的。如果对于图中任意两个顶点V_i,Vj属于V，Vi和Vj是连通的，则称G是连通图（Connected Graph）</p>\n<p>8、 无向图中的极大连通子图称为连通分量</p>\n<p>9、 在有向量图G中，如果对于每一对Vi，Vj属于V，Vi不等于Vj从Vi到Vj 和从Vj到Vi都存在路径，则称G是强连通图，有向图中的极大强连通子图称做有向图的强连通分量</p>\n<p>10、 图的邻接矩阵（Adjacency Matrix）存储方式，是用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息</p>\n<p>11、 邻接表：数组与链表相结合的存储方法称为邻接表</p>\n<p>12、 十子链表：能把邻接表与逆邻接表结合起来</p>\n<p>13、 ivex和jvex 是与某条边依附的两个顶点在顶点表中的下标，ilink 指向依附顶点ivex的下一条边，jlink 指向依附顶点jvex的下一条边。这就是邻接多重表结构</p>\n<p>14、 边集数组：是由两个一维数组构成。一个是存储顶点的信息，另一个是存储边的信息。这个边数组每个数据元素由一条边的起点下标（begin），终点下标（end）和权（weight）组成</p>\n<p>15、 深度优先遍历：也就称为深度优先搜索，简称为DFS</p>\n<p>16、 广度优先遍历：又称为广度优先搜索，简称BFS</p>\n<p>17、 我们把构造连通网的最少代价生成树称为最小生成树</p>\n<p>18、 普里姆算法</p>\n<p>19、 克鲁斯卡贝算法</p>\n<p>20、 最短路径 对于网图来说：最短路径：是指两顶点之间经过的边上权值之和最少的路径，并且我们称路经上的第一个顶点是源点，最后一个顶点是终点</p>\n<p>21、 迪杰斯特拉算法</p>\n<p>22、弗洛伊德算法： 如果你面临需要所有顶点至所有顶点的最短路径问题时，弗洛伊德算法应该是不错的选择</p>\n<p>23、 拓扑排序：在一个表示工程的有向图中，用顶点表示活动用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网（Activing On Vertex Network）<br>    拓扑排序：其实就是对一个有向图构造拓扑序排的过程</p>\n<p>24、 关键路径：路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动</p>\n<h2 id=\"第八章-查找\"><a href=\"#第八章-查找\" class=\"headerlink\" title=\"第八章 查找\"></a>第八章 查找</h2><p>1、 查找表（Search Table） 是由同一类型的数据元素（或记录）构成的集合</p>\n<p>2、 关键字（Key）是数据元素中某个数据项的值</p>\n<p>3、 查找（Searching）就是根据给定某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）</p>\n<p>4、 静态查找表（Static Search Table）：只作查找操作的查找表</p>\n<p>5、 动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从表中删除已经存在的某个数据元素</p>\n<p>6、 顺序查找（Sequential Search）：又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功</p>\n<p>7、 折半查找（Binary Search） 时间复杂度（O_log n）</p>\n<p>8、 插值查找（Interpolation Search）是根据要查找的关键字key 与 查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式</p>\n<pre><code>    key-a【low】\n-------------------\n    a【high】-a【low】\n</code></pre><p>9、 <strong>斐波那契查找</strong></p>\n<p>10、 折半查找是进行加法与除法运算 mid=（low + high）／2），插值查找进行复杂的四则运算<br>    （mid=low + （high-low））*（key-a【low】）／（a【high】-a【low】），<br>    而斐波那契查找只是最简单加减法运算（mid=low+F【k-1】-1），在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率</p>\n<p>11、 索引就是把一个关键字与它对应的记录相关联的过程</p>\n<p>12、 索引按照结构可以分为线性索引、树型索引和多级索引</p>\n<p>13、 线性索引就是将索引项集合组织为线性结构也称为索引表</p>\n<p>14、 稠密索引：将数据集中的每个记录对应一个索引项</p>\n<pre><code>注：对于稠密索引这个索引来说，索引项一定是按照关键码有序的排列\n</code></pre><p>15、 分块索引： 是把数据集的记录分成了若干块，并且这些块需要满足两个条件</p>\n<pre><code>15.1 块内无序 即每一块内的记录不要求有序\n\n15.2 块间有序\n\n15.3 最大关键码： 它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大\n\n15.4 存储了块中的记录个数，以便于循环时使用\n\n15.5 用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历\n</code></pre><p>16、 倒排索引</p>\n<p>17、 其中记录号表存储具有相同次关键字的所有记录号（可以是指向记录的指针或者是该记录的主关键字），这样的索引方法就是倒排索引（inverted index）</p>\n<p>18、 二叉排列树（Binary Sort Tree）又称为二叉查找树，它或者是一棵空树，或者是具有下列性质的二叉树</p>\n<pre><code>18.1 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值\n\n18.2 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值\n\n18.3 它的左右子树也分别为二叉排列树\n</code></pre><p>19、 二叉排序树插入操作</p>\n<p>20、 平衡二叉树（Self-Balancing Binary Search Tree 或Height-Balanced Binary Search Tree）是一种二叉树，其中一个节点的左子树和右子树的高度差至多等于1</p>\n<p>21、 将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor）</p>\n<pre><code>注：距离插入结点最近的，且平衡因子的绝对值大于1 的结点为根的子树，称为最小不平衡子树\n</code></pre><p>22、 多路查找树（muitl - way Search tree） 其每一个结点的孩子树可以多于两个，且每一个结点处可以存储对过元素</p>\n<p>23、 2-3树：是这样一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为 3 结点）<br>    23.1 一个2 结点包含一个元素和两个孩子，一个3 结点包含一小一大两个元素和三个孩子</p>\n<p>24、 2-3-4树：就是2-3树的概念扩展，包括了4结点的使用，一个4结点包含小、中大三个元素和四个孩子（或没有孩子）</p>\n<p>25、 B树（B-tree）是一种平衡的多路查找树</p>\n<p>26、 B+树的结构特别适合带有范围的查找，比如查找我们学校18～22岁的学生人数</p>\n<p>27、 散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）</p>\n<pre><code>注：这种对应关系f称为散列函数，又称为哈希（Hash）函数，按这个思想采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）\n</code></pre><p>28、 散列技术既是一种存储方法，也是一种查找方法</p>\n<p>29、 散列技术最适合的求解问题是查找与给定值相等的记录</p>\n<p>30、 散列函数因素参与：</p>\n<pre><code>30.1 计算散列地址所需的时间\n\n30.2 关键字的长度\n\n30.3 散列表的大小\n\n30.4 关键字的分布情况\n\n30.5 记录查找的频率，综合这些因素\n</code></pre><p>31、 开放定址法： 一旦发生了冲突；就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</p>\n<pre><code>f（key）=（f（key）+d_i）MODm(d_i=1,2,3,..,m-1)\n</code></pre><p>解决冲突的开放地址法称为线性探测法增加平方运算的目的是为了不让关键字都聚集在某一块区域我们称这种方法为二次探测法</p>\n<pre><code>f_i(key)=(f(key)+d_i)MOD m (d_i=1^2,-1^2,2^2,-2^2,...,q^2,-q^2) q&lt;=m/2\n</code></pre><p>在冲突时，对于移量d_i采用随机函数i+算得到，我们称之为随机探测法 </p>\n<h2 id=\"第九章-排序\"><a href=\"#第九章-排序\" class=\"headerlink\" title=\"第九章 排序\"></a>第九章 排序</h2><p>1、 排序：假设含有n个记录的序列为{r_1,r_2,…,r_n},其相应的关键字分别为{k_1,k_2,…,k_n},需确定1，2，。。。n的一种排列p_1,p_2,…,p_n,使其相应的关键字满足k_p1&lt;=k_p2&lt;=···&lt;=k_pn非递减（或非递增）关系，即使序列成为一个按关键字有序的序列{r_p1,r_p2,…,r_pn},这样的操作就称为排序。</p>\n<p>2、 排序的稳定性：假设k_i=k_j(1&lt;=i&lt;=n,1&lt;=j&lt;=n,j!=j)且在排序前的序列中r_i;则称所用的排序方法是稳定；反之，若可能使得排序后的序列r_i领先r_2,则称所用的排序方法是不稳定的。</p>\n<p>3、 内排序与外排序：内排序是在整个排序过程中，待排序的所有记录全部被放置在内存中。<br>                    外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行</p>\n<pre><code>3.1 时间性能\n3.2 辅助空间\n3.3 算法的复杂性\n</code></pre><p>4、 插入排序；交换排序；选择排序和归并排序</p>\n<p>5、 七种排序算法</p>\n<pre><code>5.1 简单算法：冒泡排序；简单选择排序；直接插入排序\n\n5.2 改进算法：希尔排序；堆排序；归并排序；快速排序\n</code></pre><p>6、 冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止</p>\n<pre><code>6.1 冒泡排序优化，时间复杂度O（n^2）\n</code></pre><p>7、 简单选择排序算法（Simple selection Sort）就是通过n-i 次关键字间比较，从n-i+1记录中选出关键字最小的记录，并和第i（1&lt;=i&lt;=n）个记录交换之 时间复杂度O（n^2）</p>\n<p>8、 直接插入排序算法（Straight Insertion Sort）基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表 时间复杂度O（n^2）</p>\n<p>9、 希尔排序</p>\n<p>10、 希尔排序原理：所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间。将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序</p>\n<p>11、 堆：堆是具有下列性质的完全二叉树；每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值；称为小顶堆</p>\n<p>12、 堆排序（Heap Sort）：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值。如此反复执行，便能得到一个有序序列</p>\n<p>13、 归并算法（Merging Sort）：假设初始序列含有 n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到【n/2】（【x】表示不小于x的最小整数）个长度为2或1的有序子序列，再两两归并，…如此重复，直至得到一个长度为n的有序序列为止，这种排序称为2路归并排序。<br>时间复杂度O（n+log n）</p>\n<p>14、 快速排序算法：通过一趟排序将待记录分割成独立的两个部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h2><h3 id=\"一、名词解释\"><a href=\"#一、名词解释\" class=\"headerlink\" title=\"一、名词解释\"></a>一、名词解释</h3><p>1、 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合</p>\n<p>2、 数据：是描述客观事物的符号，是计算机中可以操作的对象是能被计算机识别；并输入计算机处理的符号集合</p>\n<p>3、 数据元素：是组成数据的有一定意义的基本单位，在计算机中通常作为整体处理；也被称为记录</p>\n<p>4、 数据项：一个数据元素可以由若干个数据项组成</p>\n<p>5、 数据项是数据不可分割的最小单位</p>\n<p>6、 数据对象：是性质相同的数据元素的集合，是数据的子集</p>\n<p>7、 逻辑结构：是指数据对象中元素之间的相互关系</p>\n<pre><code>7.1、 集合结构：集合结构中的数据元素除了同属于一个集合处，它们之间没有其他关系\n\n7.2、 线性结构：数据元素之间是一对一的关系\n\n7.3、 树形结构：数据元素存在一种一对多的层次关系\n\n7.4、 图形结构：数据元素是多对多的关系\n</code></pre><p>8、 物理结构：是指数据的逻辑结构在计算机中存储形式</p>\n<pre><code>8.1、 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的\n\n8.2、 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的\n</code></pre><p>9、 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</p>\n<pre><code>9.1、 原子类型：是不可以再分解的基本类型包括整型、实型、字符型等\n\n9.2、 结构类型：由若干个类型组合而成，是可以再分解的，例如：整型数组是由若干整型数据组成的\n</code></pre><p>10、 抽象数据类型（Abstract Data Type；ADT）是指一个数学模型及定义在该模型上的一组操作</p>\n<h2 id=\"第二章-算法\"><a href=\"#第二章-算法\" class=\"headerlink\" title=\"第二章 算法\"></a>第二章 算法</h2><p>1、 算法：是解决特定问题解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作</p>\n<pre><code>注：算法至少有一个或多个输出\n</code></pre><p>2、 算法的特性</p>\n<pre><code>2.1 有穷性： 指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成\n\n2.2 确定性：算法的每一步骤都具有确定的含义，不会出现二义性\n\n2.3 可行性：算法的每一步都必须是可行的，也就是说每一步都能够通过执行有限次数完成\n</code></pre><p>3、 算法设计的要求</p>\n<pre><code>3.1 正确性：算法的正确性是指算法至少应该具有输入，输出和加工处理无歧义性，能正确反映问题的需求能够得到问题的正确答案\n\n3.2 可读性：算法设计的另一目的是为了便于阅读理解和交流\n\n3.3 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果\n\n3.4 时间效率高和存储量低\n</code></pre><p>4、 算法效率的度量方法</p>\n<pre><code>4.1 事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低\n\n4.2 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算\n\n注： 一个程序的运行时间，依赖于算法的好坏和问题的输入规模\n</code></pre><p>5、 函数的渐进增长：给定两个函数f（n）和g（n），如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g（n）大，那么我们说f（n）的增长渐进快于g（n）</p>\n<pre><code>注： 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数\n</code></pre><p>6、 算法时间复杂度定义：在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级，算法的时间复杂度，也就是算法的时间度量，记作T（n）=O（f（n）），它表示随问题规模n的增长，算法执行时间的增长率和f（n）的增长率相同，称作算法的渐进时间复杂度。简称为时间复杂度，其中f（n）是问题规模n的某个函数。</p>\n<p>7、 推导大O阶</p>\n<pre><code>7.1 用常数 1 取代运行时间中的所有加法常数。\n\n7.2 在修改后的运行次数函数中，只保留最高阶项\n\n7.3 如果最高阶存在且不是 1，则去除与这个项相乘的常数，得到的结果就是大O阶\n</code></pre><p>8、 线性阶</p>\n<p>9、 对数阶：O（log n）</p>\n<p>10、 平方阶： O（n*n）</p>\n<p>11、 常见的时间复杂度</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">执行次数的函数</th>\n<th style=\"text-align:right\">阶</th>\n<th style=\"text-align:center\">非正式术语</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">12</td>\n<td style=\"text-align:right\">O（1）</td>\n<td style=\"text-align:center\">常数阶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2*n+3</td>\n<td style=\"text-align:right\">O（n）</td>\n<td style=\"text-align:center\">线性阶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3<em>n^2+2</em>n+1</td>\n<td style=\"text-align:right\">O（n^2）</td>\n<td style=\"text-align:center\">平方阶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5*log_2 n+20</td>\n<td style=\"text-align:right\">O（log_n）</td>\n<td style=\"text-align:center\">对数阶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2<em>n+3</em>n*log_2 n+19</td>\n<td style=\"text-align:right\">O（n*log_n）</td>\n<td style=\"text-align:center\">n*log_n阶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6<em>n^3+2</em>n^2+3n+4</td>\n<td style=\"text-align:right\">O（n^3）</td>\n<td style=\"text-align:center\">立方阶</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2^n</td>\n<td style=\"text-align:right\">O（2^n）</td>\n<td style=\"text-align:center\">指数阶</td>\n</tr>\n</tbody>\n</table>\n<p>12、最坏情况运行时间是一种保证，那就是运行时间将不会再坏了，在应用中，这里一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间</p>\n<p>13、算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S（n）=O（f（n）），其中，n为问题的规模，f（n）为语句关于n所占存储空间的函数</p>\n<h2 id=\"第三章-线性表\"><a href=\"#第三章-线性表\" class=\"headerlink\" title=\"第三章 线性表\"></a>第三章 线性表</h2><p>1、 线性表：零个或多个数据元素的有限序列</p>\n<p>2、 若将线性表记为（a_1,…,a_i-1,a_i,a_i+1,…,a_n）,则表中a_i-1领先于a_i,a_i领先于a_i+1,称a_i-1是a_i的直接前驱元素，a_i+1是a_i的直接后继元素。当i=1,2,…,n-1时，a_i有仅有一个后继元素，当i=2，3，…,n时，a_i有仅有一个直接前驱。</p>\n<pre><code>注：1） 线性表元素的个数n（n&gt;=0）定义为线性表的长度，当n=0时，称为空表。\n\n    2） 在较复杂的线性表中，一个数据元素可以由若干个数据项组成\n</code></pre><p>3、 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素</p>\n<pre><code>属性：\n    1） 存储空间的启始位置\n    2） 线性表的最大存储位置\n    3） 线性表的当前长度\n</code></pre><p>4、 线性表顺序存储结构优缺点</p>\n<pre><code>优点\n    1） 无须为表中元素之间的逻辑关系而增加额外的存储空间\n    2） 可以快速地存取表中任一位置的元素\n\n缺点\n    1） 插入和删除操作需要移动大量元素\n    2） 当线性表长度变化较大时，难以确定存储空间的容量\n    3） 造成存储空间的“碎片”\n</code></pre><p>5、 线性表的链式存储结构的特点是用任一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。</p>\n<p>6、 为了表示每个数据元素a_i与其直接后继数据元素a_i+1之间的逻辑关系，对数据元素a_i来说，除来存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链，这两部分信息组成数据元素a_i的存储映像，称为节点（Node）。<br>    n个结点（a_i的存储映像）链结成一个链表，即为线性表（a_i,a_2,…a_n）的链式存储结构，因此链表的每个结点中包含一个指针域，所以叫做单链表</p>\n<p>7、 单链表结构与顺序存储结构优缺点</p>\n<pre><code>1） 存储分配方式\n    *  顺序存储结构用一段连续的存储单元依次存储线性表的数据元素\n    *  单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素\n\n2）时间性能\n    *  查找\n        1） 顺序存储结构O（1）\n        2） 单链表O（n）\n    *  插入和删除\n        1） 顺序存储结构需要平均移动表长一半的元素，时间为O（n）\n        2） 单链表在线出某位置的指针后，插入和删除时间仅为O（1）\n\n    *  空间性能\n        1） 顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢\n        2） 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制\n</code></pre><h3 id=\"8、-静态链表：用数组描述的链表叫做静态链表\"><a href=\"#8、-静态链表：用数组描述的链表叫做静态链表\" class=\"headerlink\" title=\"8、 静态链表：用数组描述的链表叫做静态链表\"></a>8、 静态链表：用数组描述的链表叫做静态链表</h3><p>9、 静态链表的优缺点：</p>\n<pre><code>*  优点\n    1） 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中插入和删除操作需要移动大量元素的缺点\n*  缺点\n    1） 没有解决连续存储分配带来的表长难以确定的问题\n    2） 失去了顺序存储结构随机存取的特性\n</code></pre><p>10、 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表</p>\n<p>11、 双向链表（double linked list）是在单链表的每个结点，再设置一个指向其前驱结点的指针域        </p>\n<h2 id=\"第四章-线性表\"><a href=\"#第四章-线性表\" class=\"headerlink\" title=\"第四章 线性表\"></a>第四章 线性表</h2><p>1、 栈（stack）是限定仅在表尾进行插入和删除操作的线性表</p>\n<pre><code>注：允许插入和删除的一端称为栈顶（top）另一端称为栈底（bootom），不含任何数据元素的栈称为空栈，栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构\n</code></pre><p>2、 栈的顺序存储结构</p>\n<p>3、 两栈共享空间</p>\n<p>4、 栈的链式存储结构，简称为链栈</p>\n<pre><code>注： 如果栈的使用过程中元素变化不可预料，有时很小，有时很大，那么最好用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些\n</code></pre><p>5、 栈的应用–递归</p>\n<p>6、 斐波那契数列实现</p>\n<p>7、 递归定义： 把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数</p>\n<p>8、 每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</p>\n<p>9、 迭代和递归的区别是： 迭代使用的是循环结构；递归使用的是选择结构</p>\n<p>10、 栈的应用–四则运算表达式求值</p>\n<pre><code>10.1  后缀（逆波兰）表示法定义\n</code></pre><p>11、 中缀表达式转后缀表达式</p>\n<p>12、 队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表</p>\n<pre><code>注： 队列是一种先进先出（Fist In First Out）的线性表，简称FIFO，允许插入的一端为对尾，允许删除的一端称为对头\n</code></pre><p>13、 队列顺序存储</p>\n<p>14、 循环队列定义： 头尾相接的顺序存储结构称为循环队列</p>\n<p>15、 队列的链式存储结构： 其实就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列</p>\n<pre><code>注：可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时则用链队列\n</code></pre><h2 id=\"第五章-串\"><a href=\"#第五章-串\" class=\"headerlink\" title=\"第五章 串\"></a>第五章 串</h2><p>1、 串（String）是由零个或多个字符组成的有限序列，又名叫字符串</p>\n<p>2、 串的顺序存储结构</p>\n<p>3、串的链式存储结构</p>\n<pre><code>注：串的链式存储结构除了在连接串与串操作有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好\n</code></pre><p>4、 朴素的模式匹配算法</p>\n<p>5、 KMP模式匹配算法</p>\n<p>7、 KMP模式匹配算法改进</p>\n<p><strong>练习</strong></p>\n<pre><code>《璇玑图》破解诗篇的算法\n</code></pre><h2 id=\"第六章-树\"><a href=\"#第六章-树\" class=\"headerlink\" title=\"第六章 树\"></a>第六章 树</h2><p>1、 树（Tree）是n（n&gt;=0）个结点的有限集。n=0时称为空树，在任意一棵非空树中</p>\n<pre><code>1） 有且仅有一个特定的称为根（root）的结点；\n2） 当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集T_1,T_2,...、T_m,其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）如图6-2-1 所示。\n</code></pre><p>2、 结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点的度的最大值</p>\n<p>3、 结点的子树的根称为该结点的孩子（child）相应地，该结点称为孩子的双亲</p>\n<p>4、 同一个双亲的孩子之间互称兄弟（sibling）结点的祖先是从根到该结点所经分支上的所有结点，以某结点为根的子树中的任一结点都称为该结点的子孙</p>\n<p>5、 结点的层次（level）从根开始定义起，根为第一层；根的孩子为第二层</p>\n<p>6、 双亲在同一层的结点互为堂兄弟</p>\n<p>7、 树中结点的最大层次称为树的深度（Depth）或高度</p>\n<p>8、如果将树中结点的各个子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树</p>\n<p>9、 森林（Forest）是m（m&gt;=0）棵互不相交的树的集合</p>\n<p>10、 双亲表示法：在每个结点中，附设一个指示器指示其双亲结点在树组中的位置</p>\n<p>11、 存储结构的设计是一个非常灵活的过程，一个存储结构设计得是否合理，取决于基于该存储结构的运算是否合适，是否方便，时间复杂度好不好等</p>\n<p>12、 每个结点有多个指针域；其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表表示法</p>\n<p>13、孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有 n 个孩子链表，如果是叶子结点则次单链表为空，然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维中</p>\n<p>14、 孩子兄弟表示法： 任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的左兄弟如果存在也是唯一的，因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p>\n<p>15、 二叉树（Binary Tree）是 n （n&gt;=0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成</p>\n<p>16、 二叉树五种形态</p>\n<pre><code>16.1 空二叉树\n16.2 只有一个根结点\n16.3 根结点只有左子树\n16.4 根结点只有右子树\n16.5 根结点既有左子树又有右子树\n</code></pre><p>17、 斜树：所有的结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树</p>\n<p>18、 满二叉树： 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p>\n<p>19、 完全二叉树： 对一棵具有 n 个结点的二叉树按层序编号，如果编号为i（1&lt;=i&lt;=n）的结点与同样深度的满二叉树中编号为i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</p>\n<p>20、 二叉树的性质</p>\n<pre><code>20.1 在二叉树的第 i 层中至多有2^i-1个结点（i&gt;=1）\n\n20.2 深度为k 的二叉树至多有（2^k）-1个结点（k&gt;=1）\n\n20.3 对任何一棵二叉树T，如果其终端结点数为 n_0,度为2的结点数为n_2;则 n_0=n_2+1\n\n20.4 具有 n 个结点的完全二叉树的深度为【log_2 n】+1(|x|表示不大于x的最大整数)\n\n20.5 如果对一棵有 n 个结点的完全二叉树（其深度为【log_2 n】+1）的结点按层序编号（从第1层到【log_2 n】+1层，每个层从左到右），对任一结点 i (i&lt;=i&lt;=n)有：\n    20.5.1 如果i=1，则其双亲是结点【i／2】\n    20.5.2 如果2*i&gt;n;则结点 i 无左孩子（结点 i 为叶子结点）；否则左孩子是结点2*i\n    20.5.3 如果2*i+1&gt;n,则结点 i 无右孩子，否则右孩子结点2*i+1\n</code></pre><p>21、 二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等</p>\n<p>22、 二叉链表： 二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，这样称的链表叫做二叉树</p>\n<p>23、 二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点使得每个结点被访问一次且仅被访问一次</p>\n<p>24、 前序遍历：规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树</p>\n<p>25、 中序遍历： 规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点最后中序遍历右子树</p>\n<p>26、 后序遍历： 树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点</p>\n<p>27、 层序遍历：若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点，逐个访问</p>\n<p>28、 指向前驱荷后继的指针称为线索；加上线索的二叉树称为线索链表，相应地二叉树就称为线索二叉树（Threaded Binary Tree）</p>\n<pre><code>注： 如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱荷后继，那么采用线索二叉链表的存储结构就是非常不错的选择\n</code></pre><p>29、 赫夫曼树及其应用 –最基本压缩编码方法</p>\n<p>30、 设需要编码的字符集为{d_1,d_2,…,d_n} 各个字符在电文中出现的次数或频率集合为{w_1,w_2,…,w_n} 以d_1,d_2,…,d_n作为叶子结点，以w_1,w_2,…,w_n 作为相应叶子结点的权值来构造一棵赫夫曼树，规定赫夫曼树的左分支代表O，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的O和1的序列便为该结点对应字符的编码；这就是赫夫曼编码</p>\n<h2 id=\"第七章-图\"><a href=\"#第七章-图\" class=\"headerlink\" title=\"第七章 图\"></a>第七章 图</h2><p>1、 图（Graph）是由顶点的有穷非空集合和顶点之间的集合组成，通常表示为G（V，E），其中，G表示一个图，V是图，G中顶点的集合，E是图G中边的集合</p>\n<p>2、 有向边：若从顶点V_i 到V_j的边有方向，则称这条边为有向边，也称为弧（Arc）</p>\n<p>3、 在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单的图</p>\n<p>4、 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图</p>\n<p>5、 有很少边或弧的图称为稀疏图，反之称为稠密图</p>\n<p>6、 路径的长度是路径上的边或弧的数目。第一个顶点到最后一个顶点相同的路径称为回路或环。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点最后一个顶点之外，其余顶点不重复出现回路称为简单回路</p>\n<p>7、 在无向图G中，如果从顶点V到V1有路径，则称V和V1是连通的。如果对于图中任意两个顶点V_i,Vj属于V，Vi和Vj是连通的，则称G是连通图（Connected Graph）</p>\n<p>8、 无向图中的极大连通子图称为连通分量</p>\n<p>9、 在有向量图G中，如果对于每一对Vi，Vj属于V，Vi不等于Vj从Vi到Vj 和从Vj到Vi都存在路径，则称G是强连通图，有向图中的极大强连通子图称做有向图的强连通分量</p>\n<p>10、 图的邻接矩阵（Adjacency Matrix）存储方式，是用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息</p>\n<p>11、 邻接表：数组与链表相结合的存储方法称为邻接表</p>\n<p>12、 十子链表：能把邻接表与逆邻接表结合起来</p>\n<p>13、 ivex和jvex 是与某条边依附的两个顶点在顶点表中的下标，ilink 指向依附顶点ivex的下一条边，jlink 指向依附顶点jvex的下一条边。这就是邻接多重表结构</p>\n<p>14、 边集数组：是由两个一维数组构成。一个是存储顶点的信息，另一个是存储边的信息。这个边数组每个数据元素由一条边的起点下标（begin），终点下标（end）和权（weight）组成</p>\n<p>15、 深度优先遍历：也就称为深度优先搜索，简称为DFS</p>\n<p>16、 广度优先遍历：又称为广度优先搜索，简称BFS</p>\n<p>17、 我们把构造连通网的最少代价生成树称为最小生成树</p>\n<p>18、 普里姆算法</p>\n<p>19、 克鲁斯卡贝算法</p>\n<p>20、 最短路径 对于网图来说：最短路径：是指两顶点之间经过的边上权值之和最少的路径，并且我们称路经上的第一个顶点是源点，最后一个顶点是终点</p>\n<p>21、 迪杰斯特拉算法</p>\n<p>22、弗洛伊德算法： 如果你面临需要所有顶点至所有顶点的最短路径问题时，弗洛伊德算法应该是不错的选择</p>\n<p>23、 拓扑排序：在一个表示工程的有向图中，用顶点表示活动用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网（Activing On Vertex Network）<br>    拓扑排序：其实就是对一个有向图构造拓扑序排的过程</p>\n<p>24、 关键路径：路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动</p>\n<h2 id=\"第八章-查找\"><a href=\"#第八章-查找\" class=\"headerlink\" title=\"第八章 查找\"></a>第八章 查找</h2><p>1、 查找表（Search Table） 是由同一类型的数据元素（或记录）构成的集合</p>\n<p>2、 关键字（Key）是数据元素中某个数据项的值</p>\n<p>3、 查找（Searching）就是根据给定某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）</p>\n<p>4、 静态查找表（Static Search Table）：只作查找操作的查找表</p>\n<p>5、 动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从表中删除已经存在的某个数据元素</p>\n<p>6、 顺序查找（Sequential Search）：又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功</p>\n<p>7、 折半查找（Binary Search） 时间复杂度（O_log n）</p>\n<p>8、 插值查找（Interpolation Search）是根据要查找的关键字key 与 查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式</p>\n<pre><code>    key-a【low】\n-------------------\n    a【high】-a【low】\n</code></pre><p>9、 <strong>斐波那契查找</strong></p>\n<p>10、 折半查找是进行加法与除法运算 mid=（low + high）／2），插值查找进行复杂的四则运算<br>    （mid=low + （high-low））*（key-a【low】）／（a【high】-a【low】），<br>    而斐波那契查找只是最简单加减法运算（mid=low+F【k-1】-1），在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率</p>\n<p>11、 索引就是把一个关键字与它对应的记录相关联的过程</p>\n<p>12、 索引按照结构可以分为线性索引、树型索引和多级索引</p>\n<p>13、 线性索引就是将索引项集合组织为线性结构也称为索引表</p>\n<p>14、 稠密索引：将数据集中的每个记录对应一个索引项</p>\n<pre><code>注：对于稠密索引这个索引来说，索引项一定是按照关键码有序的排列\n</code></pre><p>15、 分块索引： 是把数据集的记录分成了若干块，并且这些块需要满足两个条件</p>\n<pre><code>15.1 块内无序 即每一块内的记录不要求有序\n\n15.2 块间有序\n\n15.3 最大关键码： 它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大\n\n15.4 存储了块中的记录个数，以便于循环时使用\n\n15.5 用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历\n</code></pre><p>16、 倒排索引</p>\n<p>17、 其中记录号表存储具有相同次关键字的所有记录号（可以是指向记录的指针或者是该记录的主关键字），这样的索引方法就是倒排索引（inverted index）</p>\n<p>18、 二叉排列树（Binary Sort Tree）又称为二叉查找树，它或者是一棵空树，或者是具有下列性质的二叉树</p>\n<pre><code>18.1 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值\n\n18.2 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值\n\n18.3 它的左右子树也分别为二叉排列树\n</code></pre><p>19、 二叉排序树插入操作</p>\n<p>20、 平衡二叉树（Self-Balancing Binary Search Tree 或Height-Balanced Binary Search Tree）是一种二叉树，其中一个节点的左子树和右子树的高度差至多等于1</p>\n<p>21、 将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor）</p>\n<pre><code>注：距离插入结点最近的，且平衡因子的绝对值大于1 的结点为根的子树，称为最小不平衡子树\n</code></pre><p>22、 多路查找树（muitl - way Search tree） 其每一个结点的孩子树可以多于两个，且每一个结点处可以存储对过元素</p>\n<p>23、 2-3树：是这样一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为 3 结点）<br>    23.1 一个2 结点包含一个元素和两个孩子，一个3 结点包含一小一大两个元素和三个孩子</p>\n<p>24、 2-3-4树：就是2-3树的概念扩展，包括了4结点的使用，一个4结点包含小、中大三个元素和四个孩子（或没有孩子）</p>\n<p>25、 B树（B-tree）是一种平衡的多路查找树</p>\n<p>26、 B+树的结构特别适合带有范围的查找，比如查找我们学校18～22岁的学生人数</p>\n<p>27、 散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）</p>\n<pre><code>注：这种对应关系f称为散列函数，又称为哈希（Hash）函数，按这个思想采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）\n</code></pre><p>28、 散列技术既是一种存储方法，也是一种查找方法</p>\n<p>29、 散列技术最适合的求解问题是查找与给定值相等的记录</p>\n<p>30、 散列函数因素参与：</p>\n<pre><code>30.1 计算散列地址所需的时间\n\n30.2 关键字的长度\n\n30.3 散列表的大小\n\n30.4 关键字的分布情况\n\n30.5 记录查找的频率，综合这些因素\n</code></pre><p>31、 开放定址法： 一旦发生了冲突；就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</p>\n<pre><code>f（key）=（f（key）+d_i）MODm(d_i=1,2,3,..,m-1)\n</code></pre><p>解决冲突的开放地址法称为线性探测法增加平方运算的目的是为了不让关键字都聚集在某一块区域我们称这种方法为二次探测法</p>\n<pre><code>f_i(key)=(f(key)+d_i)MOD m (d_i=1^2,-1^2,2^2,-2^2,...,q^2,-q^2) q&lt;=m/2\n</code></pre><p>在冲突时，对于移量d_i采用随机函数i+算得到，我们称之为随机探测法 </p>\n<h2 id=\"第九章-排序\"><a href=\"#第九章-排序\" class=\"headerlink\" title=\"第九章 排序\"></a>第九章 排序</h2><p>1、 排序：假设含有n个记录的序列为{r_1,r_2,…,r_n},其相应的关键字分别为{k_1,k_2,…,k_n},需确定1，2，。。。n的一种排列p_1,p_2,…,p_n,使其相应的关键字满足k_p1&lt;=k_p2&lt;=···&lt;=k_pn非递减（或非递增）关系，即使序列成为一个按关键字有序的序列{r_p1,r_p2,…,r_pn},这样的操作就称为排序。</p>\n<p>2、 排序的稳定性：假设k_i=k_j(1&lt;=i&lt;=n,1&lt;=j&lt;=n,j!=j)且在排序前的序列中r_i;则称所用的排序方法是稳定；反之，若可能使得排序后的序列r_i领先r_2,则称所用的排序方法是不稳定的。</p>\n<p>3、 内排序与外排序：内排序是在整个排序过程中，待排序的所有记录全部被放置在内存中。<br>                    外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行</p>\n<pre><code>3.1 时间性能\n3.2 辅助空间\n3.3 算法的复杂性\n</code></pre><p>4、 插入排序；交换排序；选择排序和归并排序</p>\n<p>5、 七种排序算法</p>\n<pre><code>5.1 简单算法：冒泡排序；简单选择排序；直接插入排序\n\n5.2 改进算法：希尔排序；堆排序；归并排序；快速排序\n</code></pre><p>6、 冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止</p>\n<pre><code>6.1 冒泡排序优化，时间复杂度O（n^2）\n</code></pre><p>7、 简单选择排序算法（Simple selection Sort）就是通过n-i 次关键字间比较，从n-i+1记录中选出关键字最小的记录，并和第i（1&lt;=i&lt;=n）个记录交换之 时间复杂度O（n^2）</p>\n<p>8、 直接插入排序算法（Straight Insertion Sort）基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表 时间复杂度O（n^2）</p>\n<p>9、 希尔排序</p>\n<p>10、 希尔排序原理：所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间。将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序</p>\n<p>11、 堆：堆是具有下列性质的完全二叉树；每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值；称为小顶堆</p>\n<p>12、 堆排序（Heap Sort）：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值。如此反复执行，便能得到一个有序序列</p>\n<p>13、 归并算法（Merging Sort）：假设初始序列含有 n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到【n/2】（【x】表示不小于x的最小整数）个长度为2或1的有序子序列，再两两归并，…如此重复，直至得到一个长度为n的有序序列为止，这种排序称为2路归并排序。<br>时间复杂度O（n+log n）</p>\n<p>14、 快速排序算法：通过一趟排序将待记录分割成独立的两个部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjy416sjw000180s6fs9ddltu","tag_id":"cjy416sk2000580s64mbhpzwc","_id":"cjy416sk8000a80s6i67dm3br"},{"post_id":"cjy416sk0000380s69nlakfkt","tag_id":"cjy416sk8000980s696fqyb9s","_id":"cjy416skb000f80s6c704ath3"},{"post_id":"cjy416sk5000680s69zukmmsl","tag_id":"cjy416ska000d80s68q1tyytx","_id":"cjy416skd000j80s6xlfj2imx"},{"post_id":"cjy416sk6000780s6k1lxd5sx","tag_id":"cjy416skc000h80s650529s65","_id":"cjy416skf000n80s6qv6itdap"},{"post_id":"cjy416sk7000880s6w0fdd2w5","tag_id":"cjy416ske000l80s6u6jz8sqv","_id":"cjy416skh000q80s6bn4oqjnt"},{"post_id":"cjy416sk8000b80s6ghn1ttfn","tag_id":"cjy416skg000p80s6stafntzj","_id":"cjy416skh000s80s6jukz83xs"},{"post_id":"cjy416sk9000c80s63xxqz621","tag_id":"cjy416skh000r80s61k4qz09b","_id":"cjy416skh000u80s6seizusop"},{"post_id":"cjy416ska000e80s6x6lqbink","tag_id":"cjy416skh000t80s69y5m4a7p","_id":"cjy416ski000w80s6yeuj4pv9"},{"post_id":"cjy416skb000g80s6iuv7whj2","tag_id":"cjy416skh000v80s6qloskl60","_id":"cjy416ski000y80s6qim2qyx6"},{"post_id":"cjy416ske000k80s69e3sd5g1","tag_id":"cjy416ski000x80s6rmtgxim8","_id":"cjy416skj001080s6725yvxit"},{"post_id":"cjy416skf000m80s6wi1iwp6b","tag_id":"cjy416skj000z80s64q8ifl3h","_id":"cjy416skk001280s6wyxq4n4h"},{"post_id":"cjy416skf000o80s6f3npr0m0","tag_id":"cjy416skk001180s6xnxhx7yv","_id":"cjy416skk001380s63tvw70ms"},{"post_id":"cjy416ssg001480s6nbugxq3h","tag_id":"cjy416ssq001680s6ph3gip8c","_id":"cjy416sss001980s6grmqhmom"},{"post_id":"cjy416ssp001580s6xteeahyi","tag_id":"cjy416sss001880s6cp2b7x7h","_id":"cjy416sst001b80s6whvsn71j"},{"post_id":"cjy416ssr001780s60eqz8tbq","tag_id":"cjy416sst001a80s6ya7ym1jo","_id":"cjy416ssv001c80s66xblpu5m"},{"post_id":"cjy416swo001d80s6fs5e32je","tag_id":"cjy416swq001e80s6sopxhk9w","_id":"cjy416swq001f80s6ip5tge2c"}],"Tag":[{"name":"数据结构 算法","_id":"cjy416sk2000580s64mbhpzwc"},{"name":"冒泡 排序","_id":"cjy416sk8000980s696fqyb9s"},{"name":"Jenkins 自动构建","_id":"cjy416ska000d80s68q1tyytx"},{"name":"简历 android","_id":"cjy416skc000h80s650529s65"},{"name":"大数据 企业电子商务智能","_id":"cjy416ske000l80s6u6jz8sqv"},{"name":"代码规范 cleancode 编程风格 重构","_id":"cjy416skg000p80s6stafntzj"},{"name":"hexo debug 异常 解决办法","_id":"cjy416skh000r80s61k4qz09b"},{"name":"android studio 异常 升级 gradle","_id":"cjy416skh000t80s69y5m4a7p"},{"name":"java 设计模式 状态模式","_id":"cjy416skh000v80s6qloskl60"},{"name":"Handler 框架 Android","_id":"cjy416ski000x80s6rmtgxim8"},{"name":"unity3d android","_id":"cjy416skj000z80s64q8ifl3h"},{"name":"Jenkins Email通知\t二维码","_id":"cjy416skk001180s6xnxhx7yv"},{"name":"开源框架 内存策略 缓存策略 android","_id":"cjy416ssq001680s6ph3gip8c"},{"name":"android 面试","_id":"cjy416sss001880s6cp2b7x7h"},{"name":"串口工具","_id":"cjy416sst001a80s6ya7ym1jo"},{"name":"数据结构 java","_id":"cjy416swq001e80s6sopxhk9w"}]}}